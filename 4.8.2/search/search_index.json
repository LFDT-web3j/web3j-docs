{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Web3j \u00b6 Web3j is a highly modular, reactive, type safe Java and Android library for working with Smart Contracts and integrating with clients (nodes) on the Ethereum network: This allows you to work with the Ethereum blockchain, without the additional overhead of having to write your own integration code for the platform. The Java and the Blockchain talk provides an overview of blockchain, Ethereum and web3j. Features \u00b6 Complete implementation of Ethereum's JSON-RPC client API over HTTP and IPC Ethereum wallet support Auto-generation of Java smart contract wrappers to create, deploy, transact with and call smart contracts from native Java code ( Solidity and Truffle definition formats supported) Reactive-functional API for working with filters Ethereum Name Service (ENS) support Support for OpenEthereum's Personal , and Geth's Personal client APIs Support for Infura , so you don't have to run an Ethereum client yourself Support for ERC20 and ERC721 token standards Comprehensive integration tests demonstrating a number of the above scenarios Command line tools Android compatible Support for JP Morgan's Quorum via web3j-quorum Dependencies \u00b6 It has five runtime dependencies: RxJava for its reactive-functional API OKHttp for HTTP connections Jackson Core for fast JSON serialisation/deserialization Bouncy Castle for crypto Jnr-unixsocket for *nix IPC (not available on Android) It also uses JavaPoet for generating smart contract wrappers Commercial support and training \u00b6 Commercial support and training is available from web3labs .","title":"Home"},{"location":"#web3j","text":"Web3j is a highly modular, reactive, type safe Java and Android library for working with Smart Contracts and integrating with clients (nodes) on the Ethereum network: This allows you to work with the Ethereum blockchain, without the additional overhead of having to write your own integration code for the platform. The Java and the Blockchain talk provides an overview of blockchain, Ethereum and web3j.","title":"Web3j"},{"location":"#features","text":"Complete implementation of Ethereum's JSON-RPC client API over HTTP and IPC Ethereum wallet support Auto-generation of Java smart contract wrappers to create, deploy, transact with and call smart contracts from native Java code ( Solidity and Truffle definition formats supported) Reactive-functional API for working with filters Ethereum Name Service (ENS) support Support for OpenEthereum's Personal , and Geth's Personal client APIs Support for Infura , so you don't have to run an Ethereum client yourself Support for ERC20 and ERC721 token standards Comprehensive integration tests demonstrating a number of the above scenarios Command line tools Android compatible Support for JP Morgan's Quorum via web3j-quorum","title":"Features"},{"location":"#dependencies","text":"It has five runtime dependencies: RxJava for its reactive-functional API OKHttp for HTTP connections Jackson Core for fast JSON serialisation/deserialization Bouncy Castle for crypto Jnr-unixsocket for *nix IPC (not available on Android) It also uses JavaPoet for generating smart contract wrappers","title":"Dependencies"},{"location":"#commercial-support-and-training","text":"Commercial support and training is available from web3labs .","title":"Commercial support and training"},{"location":"quickstart/","text":"Install Web3j \u00b6 To start using Web3j you have two options: Use Epirus CLI \u00b6 This is the recommended option for full project creation. Install Epirus CLI To install the command line tools you can follow these instruction . Create a new project $ epirus new This will create a sample project to get you started. It includes a HelloWorld smart contract and boilerplate code that is easy to follow. Run your project If you don't have an Epirus account yet, you can create one here . Then run the project with the command epirus run <network> where network is rinkeby or ropsten . You can also provide custom parameters to run your project locally. Use Web3j plugins \u00b6 To generate Java Wrappers for Solidity Contracts in your project, you need to add one of the Web3j's plugins available for Maven and Gradle. Gradle plugin To add the Gradle plugin to your project: plugins { id \"org.web3j\" version \"4.8.1\" } Once the plugin is downloaded you should see a new set of tasks under the Web3j label: The simplest way is to create a new folder src/main/solidity and place your smart contracts there. To generate the Java wrappers simply run generateContractWrappers or ./gradlew/generateContractWrappers . The wrappers will generate under build/generated/source/web3j/main/java . Maven plugin To add the Maven plugin to your project: <build> <plugins> <plugin> <groupId>org.web3j</groupId> <artifactId>web3j-maven-plugin</artifactId> <version>4.6.5</version> <configuration> <soliditySourceFiles/> </configuration> </plugin> </plugins> </build> Use Web3j \u00b6 Deploying a Smart Contract \u00b6 To deploy the HelloWorld contract from the previous example: Web3j web3j = Web3j . build ( new HttpService ( \"<your_node_url>\" )); HelloWorld helloWorld = HelloWorld . deploy ( web3j , Credentials . create ( \"your_private_key\" ), new DefaultGasProvider (), \"Hello Blockchain World\" ). send (); String greeting = helloWorld . greeting (). send (); web3j . shutdown (); There are many ways to create Credentials in Web3j, for more information go to the credentials section. Loading a Smart Contract \u00b6 If you have already deployed a contract and would like to interact with it through web3j then the Java Wrappers or your smart contract have a load method. Web3j web3j = Web3j . build ( new HttpService ( \"<your_node_url>\" )); String greeting ; HelloWorld helloWorld = HelloWorld . load ( \"your_contract_address\" , web3j , Credentials . create ( \"your_private_key\" ), new DefaultGasProvider ()); if ( helloWorld . isValid ()) { greeting = helloWorld . greeting (). send (); } web3j . shutdown (); It is important that the loaded contract is checked using the isValid() method. This method will return false if the contract's bytecode does not match with the deployed one.","title":"Quickstart"},{"location":"quickstart/#install-web3j","text":"To start using Web3j you have two options:","title":"Install Web3j"},{"location":"quickstart/#use-epirus-cli","text":"This is the recommended option for full project creation.","title":"Use Epirus CLI"},{"location":"quickstart/#use-web3j-plugins","text":"To generate Java Wrappers for Solidity Contracts in your project, you need to add one of the Web3j's plugins available for Maven and Gradle.","title":"Use Web3j plugins"},{"location":"quickstart/#use-web3j","text":"","title":"Use Web3j"},{"location":"quickstart/#deploying-a-smart-contract","text":"To deploy the HelloWorld contract from the previous example: Web3j web3j = Web3j . build ( new HttpService ( \"<your_node_url>\" )); HelloWorld helloWorld = HelloWorld . deploy ( web3j , Credentials . create ( \"your_private_key\" ), new DefaultGasProvider (), \"Hello Blockchain World\" ). send (); String greeting = helloWorld . greeting (). send (); web3j . shutdown (); There are many ways to create Credentials in Web3j, for more information go to the credentials section.","title":"Deploying a Smart Contract"},{"location":"quickstart/#loading-a-smart-contract","text":"If you have already deployed a contract and would like to interact with it through web3j then the Java Wrappers or your smart contract have a load method. Web3j web3j = Web3j . build ( new HttpService ( \"<your_node_url>\" )); String greeting ; HelloWorld helloWorld = HelloWorld . load ( \"your_contract_address\" , web3j , Credentials . create ( \"your_private_key\" ), new DefaultGasProvider ()); if ( helloWorld . isValid ()) { greeting = helloWorld . greeting (). send (); } web3j . shutdown (); It is important that the loaded contract is checked using the isValid() method. This method will return false if the contract's bytecode does not match with the deployed one.","title":"Loading a Smart Contract"},{"location":"web3j_evm/","text":"Web3j EVM \u00b6 Web3j-evm is an embedded freestanding Ethereum EVM and ledger running within a Java process, which can be used for unit and integration testing your Web3j projects. As everything is local and in-process, there is no need to start up external Ethereum nodes, which helps with easy of use and performance. Everything runs within the JVM process, including EVM bytecode, which allows for easy debugging of Solidity smart contracts. Getting started \u00b6 Often you'd use this together with the web3j-unit project, allowing you to run unit and integration tests without the need to start an Ethereum node. If you want to use this within our own project directly, you would need the EVM dependency + a few external libraries. Have a look at the example project on how to do this. repositories { mavenCentral () jcenter () } dependencies { implementation \"org.web3j:core:4.6.3\" implementation \"org.web3j:web3j-evm:4.6.3\" } Below is a simple demonstration of ETH transactions, contract deployment and simple contract interactions. Using the ConsoleDebugTracer, we're able to step through the EVM bytecode, inspect the stack and also see where in the related solidity code we're currently at. The demo also show to how get started with the EmbeddedWeb3jService which is what you'd use when building your web3j instance. This demo is available on the example project . Debugging smart contracts and transactions \u00b6 While running locally with the embedded EVM it is possible to debug the internal state when deploying and invoking functions on a contract. You do this by giving the embedded Web3j service what's called an operation tracer. We have developed one which allows for console-based debugging sessions and code walkthroughs called ConsoleDebugTracer . To enable this simply pass an instance of this in as a second parameter on the EmbeddedWeb3jService constructor. OperationTracer operationTracer = new ConsoleDebugTracer (); Web3j web3j = Web3j . build ( new EmbeddedWeb3jService ( configuration , operationTracer )); When your project leverages our gradle plugin the ConsoleDebugTracer will automatically pick up Solidity contract metadata and use that to display source code context. Usually, these meta data json files are stored within build/resources/main/solidity . If you have chosen to place these elsewhere you will need to specify their location when creating the debugger instance: OperationTracer operationTracer = new ConsoleDebugTracer ( new File ( \"alternative/metadata/file/location\" )); Options while debugging \u00b6 The ConsoleDebugTracer allows you to interact with the debugging session using your terminal. Several options are available as shown below. You can also see these in the terminal by using the help option. Command line option Description [enter] Continue running until next code section. [number] Step forward X number of opcodes. next Run until the next breakpoint. end Run until the end of current transaction. abort Terminate the function call. show|hide opcodes Show or hide opcodes. show|hide stack Show or hide the stack. break [file name] [line number] Add or remove a breakpoint. break list Show all breakpoint. break clear Remove all breakpoint. For example, assume I'm debugging a Solidity contract with its source code stored in a file called Greeter.sol. If I want to have the debugger stop at a specific line in that file I'd add a breakpoint with the break option: break Greeter.sol 13 . Hitting enter after adding that breakpoint will make the debugger progress until it reaches line 13 in Greeter.sol. Likewise, if I only want to see the Solidity source code and don't care to see opcodes and the stack, I'd execute the hide opcodes and hide stack commands. Embedded Ethereum \u00b6 Usually when interacting with Ethereum you do so by connecting to an Ethereum node. This node can either be hosted externally, or it might be one you've started locally. In either case, you need to connect to another process to make transactions, deploy contracts or interact with these contracts. This brings with it a few drawbacks: You need to manage this external dependency, either through connection configuration or through a separate local application Communication between your JVM, which runs your Web3j integrations, and this external Ethereum process breaks the flow and adds lag While sometimes you do want this external dependency, for example when you are doing transactions on Ethereum mainnet or a testnet, it is often unwanted while doing local development. The Web3j EVM library solves this by providing an embedded EVM and associated ledger. This EVM runs within the same JVM as your code, freeing you from needing to make external connections. No other processes are needed as the EVM and the ledger are themselves coded in Java, and the Web3j EVM is simply used as a library within your code. If you want to use this feature within your unit and integration tests, we would recommend you explore the Web3j unit library as that provides a more complete testing experience. How to run Web3j with embedded EVM \u00b6 As shown on the EVM example project , using the embedded EVM is as easy as adding required dependencies and then use the EmbeddedWeb3jService . repositories { mavenCentral () jcenter () } dependencies { implementation \"org.web3j:core:$web3jVersion\" implementation \"org.web3j:web3j-evm:$web3jVersion\" } Web3j web3j = Web3j . build ( new EmbeddedWeb3jService ( configuration )); The configuration given to the embedded Web3j service includes the address you want to make your own and also how much test Ether you want to pre-fund on this account. Assuming you have a Web3j wallet already, you can create this configuration object as shown next: Credentials credentials = WalletUtils . loadCredentials ( \"Wallet password\" , \"wallet.json\" ); Configuration configuration = new Configuration ( new Address ( credentials . getAddress ()), 10 ); With this configured you can now use your Web3j instance as normal.","title":"Web3j EVM"},{"location":"web3j_evm/#web3j-evm","text":"Web3j-evm is an embedded freestanding Ethereum EVM and ledger running within a Java process, which can be used for unit and integration testing your Web3j projects. As everything is local and in-process, there is no need to start up external Ethereum nodes, which helps with easy of use and performance. Everything runs within the JVM process, including EVM bytecode, which allows for easy debugging of Solidity smart contracts.","title":"Web3j EVM"},{"location":"web3j_evm/#getting-started","text":"Often you'd use this together with the web3j-unit project, allowing you to run unit and integration tests without the need to start an Ethereum node. If you want to use this within our own project directly, you would need the EVM dependency + a few external libraries. Have a look at the example project on how to do this. repositories { mavenCentral () jcenter () } dependencies { implementation \"org.web3j:core:4.6.3\" implementation \"org.web3j:web3j-evm:4.6.3\" } Below is a simple demonstration of ETH transactions, contract deployment and simple contract interactions. Using the ConsoleDebugTracer, we're able to step through the EVM bytecode, inspect the stack and also see where in the related solidity code we're currently at. The demo also show to how get started with the EmbeddedWeb3jService which is what you'd use when building your web3j instance. This demo is available on the example project .","title":"Getting started"},{"location":"web3j_evm/#debugging-smart-contracts-and-transactions","text":"While running locally with the embedded EVM it is possible to debug the internal state when deploying and invoking functions on a contract. You do this by giving the embedded Web3j service what's called an operation tracer. We have developed one which allows for console-based debugging sessions and code walkthroughs called ConsoleDebugTracer . To enable this simply pass an instance of this in as a second parameter on the EmbeddedWeb3jService constructor. OperationTracer operationTracer = new ConsoleDebugTracer (); Web3j web3j = Web3j . build ( new EmbeddedWeb3jService ( configuration , operationTracer )); When your project leverages our gradle plugin the ConsoleDebugTracer will automatically pick up Solidity contract metadata and use that to display source code context. Usually, these meta data json files are stored within build/resources/main/solidity . If you have chosen to place these elsewhere you will need to specify their location when creating the debugger instance: OperationTracer operationTracer = new ConsoleDebugTracer ( new File ( \"alternative/metadata/file/location\" ));","title":"Debugging smart contracts and transactions"},{"location":"web3j_evm/#options-while-debugging","text":"The ConsoleDebugTracer allows you to interact with the debugging session using your terminal. Several options are available as shown below. You can also see these in the terminal by using the help option. Command line option Description [enter] Continue running until next code section. [number] Step forward X number of opcodes. next Run until the next breakpoint. end Run until the end of current transaction. abort Terminate the function call. show|hide opcodes Show or hide opcodes. show|hide stack Show or hide the stack. break [file name] [line number] Add or remove a breakpoint. break list Show all breakpoint. break clear Remove all breakpoint. For example, assume I'm debugging a Solidity contract with its source code stored in a file called Greeter.sol. If I want to have the debugger stop at a specific line in that file I'd add a breakpoint with the break option: break Greeter.sol 13 . Hitting enter after adding that breakpoint will make the debugger progress until it reaches line 13 in Greeter.sol. Likewise, if I only want to see the Solidity source code and don't care to see opcodes and the stack, I'd execute the hide opcodes and hide stack commands.","title":"Options while debugging"},{"location":"web3j_evm/#embedded-ethereum","text":"Usually when interacting with Ethereum you do so by connecting to an Ethereum node. This node can either be hosted externally, or it might be one you've started locally. In either case, you need to connect to another process to make transactions, deploy contracts or interact with these contracts. This brings with it a few drawbacks: You need to manage this external dependency, either through connection configuration or through a separate local application Communication between your JVM, which runs your Web3j integrations, and this external Ethereum process breaks the flow and adds lag While sometimes you do want this external dependency, for example when you are doing transactions on Ethereum mainnet or a testnet, it is often unwanted while doing local development. The Web3j EVM library solves this by providing an embedded EVM and associated ledger. This EVM runs within the same JVM as your code, freeing you from needing to make external connections. No other processes are needed as the EVM and the ledger are themselves coded in Java, and the Web3j EVM is simply used as a library within your code. If you want to use this feature within your unit and integration tests, we would recommend you explore the Web3j unit library as that provides a more complete testing experience.","title":"Embedded Ethereum"},{"location":"web3j_evm/#how-to-run-web3j-with-embedded-evm","text":"As shown on the EVM example project , using the embedded EVM is as easy as adding required dependencies and then use the EmbeddedWeb3jService . repositories { mavenCentral () jcenter () } dependencies { implementation \"org.web3j:core:$web3jVersion\" implementation \"org.web3j:web3j-evm:$web3jVersion\" } Web3j web3j = Web3j . build ( new EmbeddedWeb3jService ( configuration )); The configuration given to the embedded Web3j service includes the address you want to make your own and also how much test Ether you want to pre-fund on this account. Assuming you have a Web3j wallet already, you can create this configuration object as shown next: Credentials credentials = WalletUtils . loadCredentials ( \"Wallet password\" , \"wallet.json\" ); Configuration configuration = new Configuration ( new Address ( credentials . getAddress ()), 10 ); With this configured you can now use your Web3j instance as normal.","title":"How to run Web3j with embedded EVM"},{"location":"web3j_openapi/","text":"Web3j-OpenAPI \u00b6 Web3j-OpenAPI is a OpenAPI client and server generator from Solidity smart contracts. It provides a way to interact with the Ethereum smart contracts using a simple RESTful API. These interactions can be done using plain HTTP requests or via the Swagger-UI , which is generated with every project. This workflow can be summed in the following steps: Writing a Solidity smart contract Generating the corresponding Web3j-OpenAPI project using Epirus-CLI Running the generated project as a standalone server Sending HTTP requests using the Swagger-UI , Java/Kotlin client, Curl or other. Example \u00b6 The following Hello World contract : // SPDX-License-Identifier: Apache-2.0 pragma solidity ^0.7.0; // Modified Greeter contract. Based on example at https://www.ethereum.org/greeter. contract Mortal { /* Define variable owner of the type address*/ address owner; /* this function is executed at initialization and sets the owner of the contract */ constructor () {owner = msg.sender;} modifier onlyOwner { require( msg.sender == owner, \"Only owner can call this function.\" ); _; } /* Function to recover the funds on the contract */ function kill() onlyOwner public {selfdestruct(msg.sender);} } contract HelloWorld is Mortal { /* define variable greeting of the type string */ string greet; /* this runs when the contract is executed */ constructor (string memory _greet) { greet = _greet; } function newGreeting(string memory _greet) onlyOwner public { emit Modified(greet, _greet, greet, _greet); greet = _greet; } /* main function */ function greeting() public view returns (string memory) { return greet; } event Modified( string indexed oldGreetingIdx, string indexed newGreetingIdx, string oldGreeting, string newGreeting); } generates the following OpenAPI specs : { \"openapi\":\"3.0.1\", \"info\":{ \"title\":\"Web3j OpenApi\", \"contact\":{ \"name\":\"Web3 Labs\", \"url\":\"http://web3labs.com\", \"email\":\"hi@web3labs.com\" }, \"version\":\"4.8.1\" }, \"tags\":[ { \"name\":\"default\", \"description\":\"Lists existing contracts and events\" }, { \"name\":\"HelloWorld Methods\", \"description\":\"List HelloWorld method&#39;s calls\" }, { \"name\":\"HelloWorld Events\", \"description\":\"List HelloWorld event&#39;s calls\" } ], \"paths\":{ \"/Web3App/contracts/helloworld/{contractAddress}/Kill\":{ \"get\":{ \"tags\":[ \"HelloWorld Methods\" ], \"summary\":\"Execute the Kill method\", \"operationId\":\"kill\", \"parameters\":[ { \"name\":\"contractAddress\", \"in\":\"path\", \"required\":true, \"schema\":{ \"type\":\"string\" } } ], \"responses\":{ \"default\":{ \"description\":\"default response\", \"content\":{ \"application/json\":{ \"schema\":{ \"$ref\":\"#/components/schemas/TransactionReceiptModel\" } } } } } } }, ... With a corresponding Swagger-UI : The available methods are: The available events are: Getting started with Web3j-OpenAPI \u00b6 Generate a project \u00b6 To generate an OpenAPI project using the Web3j-OpenAPI generator, you need to have the Epirus-CLI installed on your machine (Note - the Epirus CLI has replaced the Web3j CLI). It\u2019s easy to do (for Windows instructions head here ): $ curl -L get.epirus.io | sh Then, you can run the $ epirus openapi import --help To check the generator available options. In this case, we will be using the above Hello World contract. Put that contract in a file named HelloWorld.sol for starters. Then, execute the following command: $ epirus openapi import \\ -s=HelloWorld.sol \\ --package=com.tutorial \\ --project-name=HelloWorldProject \\ --output-dir=. You should be seeing logs similar to the following: Configure the project \u00b6 You can run the project easily, without specify any configuration, using the Epirus-cli . If not, you need to specify runtime parameters. for example, the private key or wallet file for the signing, the node endpoint to connect to, etc. To see the available options, run the distributions executable or the JAR with the --help flag. You'll get the following display: To specify these parameters, you can set the following environment variables: $ export WEB3J_ENDPOINT=<link_to_your_Ethereum_node> $ export WEB3J_PRIVATE_KEY=<your_private_key> $ export WEB3J_OPENAPI_HOST=localhost $ export WEB3J_OPENAPI_PORT=9090 For more ways to pass these parameters, check the configuration section below. Run the project \u00b6 We can run the project directly : $ ./gradlew run You should be able to run the server and see the following: Interact with the generated project \u00b6 Interactions can be done in multiple ways : SwaggerUI \u00b6 The generated SwaggerUI is located on {host}:{port}/swagger-ui and can be used to do all possible interactions with the API. eg: HTTP requests \u00b6 Sending HTTP requests via tools like Curl : $ curl -X POST \"http://{host}:{port}/HelloWorldProject/contracts/helloworld/{contract address}/NewGreeting\" -H \"accept: application/json\" -H \"Content-Type: application/json\" -d \"{\\\"_greet\\\":\\\"Hello Web3j-OpenAPI\\\"}\" Client application \u00b6 It is also possible to interact using a Java/Kotlin client application. This latter can be done using our client implementation. Make sure to add the client dependency to your project. dependencies { implementation \"org.web3j.openapi:web3j-openapi-client:4.8.1\" } Then, you will be able to interact with the API as follows: val service = ClientService(\"http://localhost:9090\") val helloWorldProject = ClientFactory.create(HelloWorldProjectApi::class.java, service) println(\"Deploying the HelloWorld contract...\") val receipt = helloWorldProject.contracts.helloWorld.deploy(HelloWorldDeployParameters(\"Hello\")) println(\"Deployed contract address: ${receipt.contractAddress}\") val newGreetingHash = helloWorldProject.contracts .helloWorld .load(receipt.contractAddress) .newGreeting(NewGreetingParameters(\"Hello Web3j-OpenAPI\")) .transactionHash println(\"NewGreeting method execution transaction hash: $newGreetingHash\") val greeting = helloWorldProject.contracts .helloWorld .load(receipt.contractAddress) .greeting() .result println(\"Greeting method result: $greeting\") Ways to generate an OpenAPI project \u00b6 First, you need to install the Epirus-CLI on your machine (Note - the Epirus CLI has replaced the Web3j CLI). It\u2019s easy to do (for Windows instructions head here ): $ curl -L get.epirus.io | sh Generate a Hello World project \u00b6 A Hello World project is a simple project based on a simple Solidity contract. It is generated using: $ epirus openapi new This project can be used as a minimal project to start building your custom application upon. Generate using custom Solidity smart contracts \u00b6 To generate a project using your desired smart contracts, use the following command: $ epirus openapi import \\ --solidity-path <path_to_Solidity_contracts> \\ --project-name <project name> \\ --package <package name> Generate an executable JAR \u00b6 The following command will generate an executable JAR ready to be run: $ epirus openapi jar \\ --solidity-path <path_to_Solidity_contracts> Generate the REST API only \u00b6 To generate only the API, ie the defined endpoints with their implementations, use the following: $ epirus openapi generate \\ --solidity-path <path_to_Solidity_contracts> \\ --with-implementations=true This command will not generate a whole project structure. Thus, you will not have a runnable application. To have one, check the above sections. The with-implementations flag is set to true by default. This means that the RESTful endpoints will be generated along their implementations. If you prefer to generate only the interfaces. Set that flag to false : --with-implementations=false Generate using the web3j-openapi-gradle-plugin \u00b6 It is possible to generate a Web3j-OpenAPI project directly from your gradle project using the web3j-openapi-gradle-plugin . Check the documentation for more information. Run the project \u00b6 Runtime parameters \u00b6 Before running the server, there are some parameters that need to be set. There are multiple ways of doing so: Environment variables Configuration file Passing the parameters directly to the JAR or the executable. Also, you can run the project without worrying about any of this using the Epirus-cli Supported parameters \u00b6 Name Default value Description name Generation project name The project name config file ~/.epirus/web3j.openapi.<extension> A custom configuration file to import extra parameters endpoint none Ethereum node endpoint to target when interacting with the blockchain private key none User private key in hex format prefixed by 0x wallet path none The path to the wallet file (can be absolute or relative) wallet password none The password of the specified wallet file in plain text host localhost The server host (can be an IP address or a hostname) port 8080 The server port contract addresses none Use pre-deployed contract addresses: contract1=0x123,contract2=0x1234 . All you need to provide to the generator is the ABIs. The necessary parameters are: The Ethereum node endpoint to target when interacting with the Ethereum network endpoint Credentials : which can be either private key , or wallet path and wallet password The remaining parameters are optional. Order of precedence \u00b6 The parameters can be specified interchangeably between different sources. ie, you can have some defined in a default configuration file and others in environment variables etc. However, for duplicated values, we enforce the following order : CLI arguments Custom configuration file specified in the CLI Custom configuration file specified in Environment variables Default configuration file Environment variables Check the following sections for more information. CLI arguments \u00b6 The CLI arguments can be passed to the command the usual way. Example Check the Starting the server section below to choose a command. $ <command> \\ --private-key 0x1234 \\ --name OpenApiProject \\ --endpoint <Ethereum node endpoint> \\ --host localhost \\ --port 9090 \\ --contract-addresses contract1=0x1234,contract2=0x123 Configuration file \u00b6 You can put the parameters in a configuration file . This latter, can be YAML , Json or Java properties type of files. The configuration file can be : Put in the default directory : ~/.epirus/web3j.openapi.<extension> Set in an environment variable: WEB3J_OPENAPI_CONFIG_FILE where the value is the path to the file. eg. export WEB3J_OPENAPI_CONFIG_FILE=<path_to_the_config_file} Set as an argument when running the JAR or the executable: --config-file The supported extensions are : yaml for a YAML configuration. Example: contractAddresses : helloworld : \"0x1234\" helloworld2 : \"0x1234\" credentials : privateKey : \"0x1234\" network : endpoint : \"<your_node_endpoint_address>\" project : name : \"OpenApiProject\" server : host : \"localhost\" port : 9090 json for a Json configuration. Example: { \"contractAddresses\" : { \"helloworld\" : \"0x1234\" , \"helloworld2\" : \"0x1234\" }, \"credentials\" : { \"privateKey\" : \"0x1234\" }, \"network\" : { \"endpoint\" : \"your node endpoint address\" }, \"project\" : { \"name\" : \"OpenApiProject\" }, \"server\" : { \"host\" : \"localhost\" , \"port\" : 9090 } } properties for a Java properties configuration. Example: contractAddresses=helloworld=0x1234,helloworld2=0x1234 credentials.privateKey=0x1234 network.endpoint=your node endpoint address project.name=OpenApiProject server.host=localhost server.port=9090 Environment variables \u00b6 The easiest way to provide the runtime parameters is through environment variables. The rule is to: Replace the - with a _ : private-key => private_key Upper case the options' names : private-key => PRIVATE_KEY Example $ export WEB3J_ENDPOINT=<link_to_your_Ethereum_node> $ export WEB3J_OPENAPI_HOST=localhost $ export WEB3J_OPENAPI_PORT=9090 $ export WEB3J_OPENAPI_NAME=Web3jOpenAPI $ export WEB3J_OPENAPI_CONTRACT_ADDRESSES=helloworld=0x1234,helloworld2=0x12345 $ export WEB3J_OEPNAPI_CONFIG_FILE=~/myConfig.yaml And one of the following: A raw private key : $ export WEB3J_PRIVATE_KEY=0x1234 A wallet : $ export WEB3J_WALLET_PATH=~/myWallet.json $ export WEB3J_WALLET_PASSWORD=myStrongPassword Start the server \u00b6 Starting the server can be done in the following ways: The generated JAR \u00b6 A JAR can be generated using the following command: $ ./gradlew shadowJar It will be found under the build/libs directory. The generated JAR can be run using the following: $ java -jar build/libs/<project name>-all.jar <parameters> check the parameters section above for the supported parameters. The distribution executable \u00b6 A server executable can be generated using the following: $ ./gradlew installShadowDist <parameters> Which can be found in build/install/<app name>-shadow/bin/ Using gradle \u00b6 To run the project using gradle. Make sure to have set some environment variables or configuration file as specified above. Then, run the following : $ ./gradlew run The Web3j-OpenAPI client \u00b6 Among the available ways to interact with a Web3j-OpenAPI server, there is the Kotlin client. It is easy to use. Start by adding dependency to the client: dependencies { implementation \"org.web3j.openapi:web3j-openapi-client:4.8.1\" } Then, within a client application: val service = ClientService ( \"http://localhost:9090\" ) val app = ClientFactory . create (< AppNameApi > :: class . java , service ) // Then you have access to all the API resources val receipt = app . contracts . contractName . deploy () println ( \"Deployment receipt: ${receipt.contractAddress}\" ) // ... Handling events \u00b6 In web3j-OpenAPI, we handle events using Server-Sent Events SSE . In a nutshell, SSE is a one way mechanism that allows a server to asynchronously push data from the server to the client once the client-server connection is established by the client. To query events from Kotlin/Java . Add the web3j-openapi-client dependency as done above. Then, use the following code: val service = ClientService ( \"http://localhost:9090\" ) val app = ClientFactory . create ( AppNameApi :: class . java , service ) // Start listening for events val event = app . contracts .< contract_name >. load (< contract_Address >) . events .< event_name > . onEvent { println ( \"Received event: $it\" ) } // Trigger an event app . contracts .< contract_name > . load (< contract_Address >) .< method_triggering_event >(< method_parameters >) Then run this code. You should be able to see events printing on the screen.","title":"Web3j OpenAPI"},{"location":"web3j_openapi/#web3j-openapi","text":"Web3j-OpenAPI is a OpenAPI client and server generator from Solidity smart contracts. It provides a way to interact with the Ethereum smart contracts using a simple RESTful API. These interactions can be done using plain HTTP requests or via the Swagger-UI , which is generated with every project. This workflow can be summed in the following steps: Writing a Solidity smart contract Generating the corresponding Web3j-OpenAPI project using Epirus-CLI Running the generated project as a standalone server Sending HTTP requests using the Swagger-UI , Java/Kotlin client, Curl or other.","title":"Web3j-OpenAPI"},{"location":"web3j_openapi/#example","text":"The following Hello World contract : // SPDX-License-Identifier: Apache-2.0 pragma solidity ^0.7.0; // Modified Greeter contract. Based on example at https://www.ethereum.org/greeter. contract Mortal { /* Define variable owner of the type address*/ address owner; /* this function is executed at initialization and sets the owner of the contract */ constructor () {owner = msg.sender;} modifier onlyOwner { require( msg.sender == owner, \"Only owner can call this function.\" ); _; } /* Function to recover the funds on the contract */ function kill() onlyOwner public {selfdestruct(msg.sender);} } contract HelloWorld is Mortal { /* define variable greeting of the type string */ string greet; /* this runs when the contract is executed */ constructor (string memory _greet) { greet = _greet; } function newGreeting(string memory _greet) onlyOwner public { emit Modified(greet, _greet, greet, _greet); greet = _greet; } /* main function */ function greeting() public view returns (string memory) { return greet; } event Modified( string indexed oldGreetingIdx, string indexed newGreetingIdx, string oldGreeting, string newGreeting); } generates the following OpenAPI specs : { \"openapi\":\"3.0.1\", \"info\":{ \"title\":\"Web3j OpenApi\", \"contact\":{ \"name\":\"Web3 Labs\", \"url\":\"http://web3labs.com\", \"email\":\"hi@web3labs.com\" }, \"version\":\"4.8.1\" }, \"tags\":[ { \"name\":\"default\", \"description\":\"Lists existing contracts and events\" }, { \"name\":\"HelloWorld Methods\", \"description\":\"List HelloWorld method&#39;s calls\" }, { \"name\":\"HelloWorld Events\", \"description\":\"List HelloWorld event&#39;s calls\" } ], \"paths\":{ \"/Web3App/contracts/helloworld/{contractAddress}/Kill\":{ \"get\":{ \"tags\":[ \"HelloWorld Methods\" ], \"summary\":\"Execute the Kill method\", \"operationId\":\"kill\", \"parameters\":[ { \"name\":\"contractAddress\", \"in\":\"path\", \"required\":true, \"schema\":{ \"type\":\"string\" } } ], \"responses\":{ \"default\":{ \"description\":\"default response\", \"content\":{ \"application/json\":{ \"schema\":{ \"$ref\":\"#/components/schemas/TransactionReceiptModel\" } } } } } } }, ... With a corresponding Swagger-UI : The available methods are: The available events are:","title":"Example"},{"location":"web3j_openapi/#getting-started-with-web3j-openapi","text":"","title":"Getting started with Web3j-OpenAPI"},{"location":"web3j_openapi/#generate-a-project","text":"To generate an OpenAPI project using the Web3j-OpenAPI generator, you need to have the Epirus-CLI installed on your machine (Note - the Epirus CLI has replaced the Web3j CLI). It\u2019s easy to do (for Windows instructions head here ): $ curl -L get.epirus.io | sh Then, you can run the $ epirus openapi import --help To check the generator available options. In this case, we will be using the above Hello World contract. Put that contract in a file named HelloWorld.sol for starters. Then, execute the following command: $ epirus openapi import \\ -s=HelloWorld.sol \\ --package=com.tutorial \\ --project-name=HelloWorldProject \\ --output-dir=. You should be seeing logs similar to the following:","title":"Generate a project"},{"location":"web3j_openapi/#configure-the-project","text":"You can run the project easily, without specify any configuration, using the Epirus-cli . If not, you need to specify runtime parameters. for example, the private key or wallet file for the signing, the node endpoint to connect to, etc. To see the available options, run the distributions executable or the JAR with the --help flag. You'll get the following display: To specify these parameters, you can set the following environment variables: $ export WEB3J_ENDPOINT=<link_to_your_Ethereum_node> $ export WEB3J_PRIVATE_KEY=<your_private_key> $ export WEB3J_OPENAPI_HOST=localhost $ export WEB3J_OPENAPI_PORT=9090 For more ways to pass these parameters, check the configuration section below.","title":"Configure the project"},{"location":"web3j_openapi/#run-the-project","text":"We can run the project directly : $ ./gradlew run You should be able to run the server and see the following:","title":"Run the project"},{"location":"web3j_openapi/#interact-with-the-generated-project","text":"Interactions can be done in multiple ways :","title":"Interact with the generated project"},{"location":"web3j_openapi/#swaggerui","text":"The generated SwaggerUI is located on {host}:{port}/swagger-ui and can be used to do all possible interactions with the API. eg:","title":"SwaggerUI"},{"location":"web3j_openapi/#http-requests","text":"Sending HTTP requests via tools like Curl : $ curl -X POST \"http://{host}:{port}/HelloWorldProject/contracts/helloworld/{contract address}/NewGreeting\" -H \"accept: application/json\" -H \"Content-Type: application/json\" -d \"{\\\"_greet\\\":\\\"Hello Web3j-OpenAPI\\\"}\"","title":"HTTP requests"},{"location":"web3j_openapi/#client-application","text":"It is also possible to interact using a Java/Kotlin client application. This latter can be done using our client implementation. Make sure to add the client dependency to your project. dependencies { implementation \"org.web3j.openapi:web3j-openapi-client:4.8.1\" } Then, you will be able to interact with the API as follows: val service = ClientService(\"http://localhost:9090\") val helloWorldProject = ClientFactory.create(HelloWorldProjectApi::class.java, service) println(\"Deploying the HelloWorld contract...\") val receipt = helloWorldProject.contracts.helloWorld.deploy(HelloWorldDeployParameters(\"Hello\")) println(\"Deployed contract address: ${receipt.contractAddress}\") val newGreetingHash = helloWorldProject.contracts .helloWorld .load(receipt.contractAddress) .newGreeting(NewGreetingParameters(\"Hello Web3j-OpenAPI\")) .transactionHash println(\"NewGreeting method execution transaction hash: $newGreetingHash\") val greeting = helloWorldProject.contracts .helloWorld .load(receipt.contractAddress) .greeting() .result println(\"Greeting method result: $greeting\")","title":"Client application"},{"location":"web3j_openapi/#ways-to-generate-an-openapi-project","text":"First, you need to install the Epirus-CLI on your machine (Note - the Epirus CLI has replaced the Web3j CLI). It\u2019s easy to do (for Windows instructions head here ): $ curl -L get.epirus.io | sh","title":"Ways to generate an OpenAPI project"},{"location":"web3j_openapi/#generate-a-hello-world-project","text":"A Hello World project is a simple project based on a simple Solidity contract. It is generated using: $ epirus openapi new This project can be used as a minimal project to start building your custom application upon.","title":"Generate a Hello World project"},{"location":"web3j_openapi/#generate-using-custom-solidity-smart-contracts","text":"To generate a project using your desired smart contracts, use the following command: $ epirus openapi import \\ --solidity-path <path_to_Solidity_contracts> \\ --project-name <project name> \\ --package <package name>","title":"Generate using custom Solidity smart contracts"},{"location":"web3j_openapi/#generate-an-executable-jar","text":"The following command will generate an executable JAR ready to be run: $ epirus openapi jar \\ --solidity-path <path_to_Solidity_contracts>","title":"Generate an executable JAR"},{"location":"web3j_openapi/#generate-the-rest-api-only","text":"To generate only the API, ie the defined endpoints with their implementations, use the following: $ epirus openapi generate \\ --solidity-path <path_to_Solidity_contracts> \\ --with-implementations=true This command will not generate a whole project structure. Thus, you will not have a runnable application. To have one, check the above sections. The with-implementations flag is set to true by default. This means that the RESTful endpoints will be generated along their implementations. If you prefer to generate only the interfaces. Set that flag to false : --with-implementations=false","title":"Generate the REST API only"},{"location":"web3j_openapi/#generate-using-the-web3j-openapi-gradle-plugin","text":"It is possible to generate a Web3j-OpenAPI project directly from your gradle project using the web3j-openapi-gradle-plugin . Check the documentation for more information.","title":"Generate using the web3j-openapi-gradle-plugin"},{"location":"web3j_openapi/#run-the-project_1","text":"","title":"Run the project"},{"location":"web3j_openapi/#runtime-parameters","text":"Before running the server, there are some parameters that need to be set. There are multiple ways of doing so: Environment variables Configuration file Passing the parameters directly to the JAR or the executable. Also, you can run the project without worrying about any of this using the Epirus-cli","title":"Runtime parameters"},{"location":"web3j_openapi/#supported-parameters","text":"Name Default value Description name Generation project name The project name config file ~/.epirus/web3j.openapi.<extension> A custom configuration file to import extra parameters endpoint none Ethereum node endpoint to target when interacting with the blockchain private key none User private key in hex format prefixed by 0x wallet path none The path to the wallet file (can be absolute or relative) wallet password none The password of the specified wallet file in plain text host localhost The server host (can be an IP address or a hostname) port 8080 The server port contract addresses none Use pre-deployed contract addresses: contract1=0x123,contract2=0x1234 . All you need to provide to the generator is the ABIs. The necessary parameters are: The Ethereum node endpoint to target when interacting with the Ethereum network endpoint Credentials : which can be either private key , or wallet path and wallet password The remaining parameters are optional.","title":"Supported parameters"},{"location":"web3j_openapi/#order-of-precedence","text":"The parameters can be specified interchangeably between different sources. ie, you can have some defined in a default configuration file and others in environment variables etc. However, for duplicated values, we enforce the following order : CLI arguments Custom configuration file specified in the CLI Custom configuration file specified in Environment variables Default configuration file Environment variables Check the following sections for more information.","title":"Order of precedence"},{"location":"web3j_openapi/#cli-arguments","text":"The CLI arguments can be passed to the command the usual way.","title":"CLI arguments"},{"location":"web3j_openapi/#configuration-file","text":"You can put the parameters in a configuration file . This latter, can be YAML , Json or Java properties type of files. The configuration file can be : Put in the default directory : ~/.epirus/web3j.openapi.<extension> Set in an environment variable: WEB3J_OPENAPI_CONFIG_FILE where the value is the path to the file. eg. export WEB3J_OPENAPI_CONFIG_FILE=<path_to_the_config_file} Set as an argument when running the JAR or the executable: --config-file The supported extensions are : yaml for a YAML configuration. Example: contractAddresses : helloworld : \"0x1234\" helloworld2 : \"0x1234\" credentials : privateKey : \"0x1234\" network : endpoint : \"<your_node_endpoint_address>\" project : name : \"OpenApiProject\" server : host : \"localhost\" port : 9090 json for a Json configuration. Example: { \"contractAddresses\" : { \"helloworld\" : \"0x1234\" , \"helloworld2\" : \"0x1234\" }, \"credentials\" : { \"privateKey\" : \"0x1234\" }, \"network\" : { \"endpoint\" : \"your node endpoint address\" }, \"project\" : { \"name\" : \"OpenApiProject\" }, \"server\" : { \"host\" : \"localhost\" , \"port\" : 9090 } } properties for a Java properties configuration. Example: contractAddresses=helloworld=0x1234,helloworld2=0x1234 credentials.privateKey=0x1234 network.endpoint=your node endpoint address project.name=OpenApiProject server.host=localhost server.port=9090","title":"Configuration file"},{"location":"web3j_openapi/#environment-variables","text":"The easiest way to provide the runtime parameters is through environment variables. The rule is to: Replace the - with a _ : private-key => private_key Upper case the options' names : private-key => PRIVATE_KEY","title":"Environment variables"},{"location":"web3j_openapi/#start-the-server","text":"Starting the server can be done in the following ways:","title":"Start the server"},{"location":"web3j_openapi/#the-generated-jar","text":"A JAR can be generated using the following command: $ ./gradlew shadowJar It will be found under the build/libs directory. The generated JAR can be run using the following: $ java -jar build/libs/<project name>-all.jar <parameters> check the parameters section above for the supported parameters.","title":"The generated JAR"},{"location":"web3j_openapi/#the-distribution-executable","text":"A server executable can be generated using the following: $ ./gradlew installShadowDist <parameters> Which can be found in build/install/<app name>-shadow/bin/","title":"The distribution executable"},{"location":"web3j_openapi/#using-gradle","text":"To run the project using gradle. Make sure to have set some environment variables or configuration file as specified above. Then, run the following : $ ./gradlew run","title":"Using gradle"},{"location":"web3j_openapi/#the-web3j-openapi-client","text":"Among the available ways to interact with a Web3j-OpenAPI server, there is the Kotlin client. It is easy to use. Start by adding dependency to the client: dependencies { implementation \"org.web3j.openapi:web3j-openapi-client:4.8.1\" } Then, within a client application: val service = ClientService ( \"http://localhost:9090\" ) val app = ClientFactory . create (< AppNameApi > :: class . java , service ) // Then you have access to all the API resources val receipt = app . contracts . contractName . deploy () println ( \"Deployment receipt: ${receipt.contractAddress}\" ) // ...","title":"The Web3j-OpenAPI client"},{"location":"web3j_openapi/#handling-events","text":"In web3j-OpenAPI, we handle events using Server-Sent Events SSE . In a nutshell, SSE is a one way mechanism that allows a server to asynchronously push data from the server to the client once the client-server connection is established by the client. To query events from Kotlin/Java . Add the web3j-openapi-client dependency as done above. Then, use the following code: val service = ClientService ( \"http://localhost:9090\" ) val app = ClientFactory . create ( AppNameApi :: class . java , service ) // Start listening for events val event = app . contracts .< contract_name >. load (< contract_Address >) . events .< event_name > . onEvent { println ( \"Received event: $it\" ) } // Trigger an event app . contracts .< contract_name > . load (< contract_Address >) .< method_triggering_event >(< method_parameters >) Then run this code. You should be able to see events printing on the screen.","title":"Handling events"},{"location":"web3j_sokt/","text":"Sokt \u00b6 Sokt is a Kotlin wrapper for the Solidity compiler (solc). Given a solidity file, it can identify the ideal compiler version to use from the pragma statement at the top of the file. It can then download, install and invoke the compiler. Rather than using Dockerized versions of Solc, Sokt uses native builds and is compatible with Mac, Windows and Linux (x86/64 only). This means that the only dependency is a Java installation. Sokt also plays nicely with GraalVM, eliminating the Java dependency if necessary. Sokt is currently under active development. You can use it in one of your own projects by adding the following dependency to your build.gradle : dependencies { compile group: 'org.web3j' , name: 'web3j-sokt' , version: '0.2.1' } For other build systems, see here . Example usage: String fileName = filePath . substringAfterLast ( \"/\" ); System . out . println ( \"sokt Processing \" + fileName ); SolidityFile solidityFile = new SolidityFile ( filePath ); System . out . println ( \"Resolving compiler version for \" + fileName ); SolcInstance compilerInstance = solidityFile . getCompilerInstance (); System . out . println ( \"Resolved\" + compilerInstance . getSolcRelease (). getVersion () + \" for \" + fileName ); SolcOutput result = compilerInstance . execute ( SolcArguments . OUTPUT_DIR . param (() -> \"/tmp\" ), SolcArguments . AST , SolcArguments . BIN , SolcArguments . OVERWRITE ); System . out . println ( \"Solc exited with code: \" + result . getExitCode ()); System . out . println ( \"Solc standard output: \" + result . getStdOut ()); System . out . println ( \"Solc standard error: \" + result . getStdErr ());","title":"Web3j Sokt"},{"location":"web3j_sokt/#sokt","text":"Sokt is a Kotlin wrapper for the Solidity compiler (solc). Given a solidity file, it can identify the ideal compiler version to use from the pragma statement at the top of the file. It can then download, install and invoke the compiler. Rather than using Dockerized versions of Solc, Sokt uses native builds and is compatible with Mac, Windows and Linux (x86/64 only). This means that the only dependency is a Java installation. Sokt also plays nicely with GraalVM, eliminating the Java dependency if necessary. Sokt is currently under active development. You can use it in one of your own projects by adding the following dependency to your build.gradle : dependencies { compile group: 'org.web3j' , name: 'web3j-sokt' , version: '0.2.1' } For other build systems, see here . Example usage: String fileName = filePath . substringAfterLast ( \"/\" ); System . out . println ( \"sokt Processing \" + fileName ); SolidityFile solidityFile = new SolidityFile ( filePath ); System . out . println ( \"Resolving compiler version for \" + fileName ); SolcInstance compilerInstance = solidityFile . getCompilerInstance (); System . out . println ( \"Resolved\" + compilerInstance . getSolcRelease (). getVersion () + \" for \" + fileName ); SolcOutput result = compilerInstance . execute ( SolcArguments . OUTPUT_DIR . param (() -> \"/tmp\" ), SolcArguments . AST , SolcArguments . BIN , SolcArguments . OVERWRITE ); System . out . println ( \"Solc exited with code: \" + result . getExitCode ()); System . out . println ( \"Solc standard output: \" + result . getStdOut ()); System . out . println ( \"Solc standard error: \" + result . getStdErr ());","title":"Sokt"},{"location":"web3j_unit/","text":"Web3j Unit \u00b6 Web3j-unit is an extension to JUnit 5 which enables you to test solidity contracts like any other Java code. It allows you to test with both an embedded and dockerized Ethereum nodes, with out-of-the box support for Geth, Besu, and OpenEthereum nodes. A docker-compose network can also be configured easily for more complex setups. Usage \u00b6 First, let's add the gradle dependency. repositories { mavenCentral () jcenter () } implementation \"org.web3j:core:4.5.11\" testCompile \"org.web3j:web3j-unit:4.5.11\" Using EVMTest annotation \u00b6 Create a new test with the @EVMTest annotation. An embedded EVM is used by default. To use Geth or Besu pass the node type into the annotation: @EVMTest(NodeType.GETH) or @EVMTest(NodeType.BESU) @EVMTest public class GreeterTest { } Inject instance of Web3j , TransactionManager and ContractGasProvider in your test method. @EVMTest public class GreeterTest { @Test public void greeterDeploys ( Web3j web3j , TransactionManager transactionManager , ContractGasProvider gasProvider ) { } } Deploy your contract in the test. @EVMTest public class GreeterTest { @Test public void greeterDeploys ( Web3j web3j , TransactionManager transactionManager , ContractGasProvider gasProvider ) { Greeter greeter = Greeter . deploy ( web3j , transactionManager , gasProvider , \"Hello EVM\" ). send (); String greeting = greeter . greet (). send (); assertEquals ( \"Hello EVM\" , greeting ); } } Run the test! Using EVMComposeTest annotation \u00b6 Create a new test with the @EVMComposeTest annotation. By default, it uses test.yml file in the project home, and runs web3j on service named node1 exposing the port 8545 . Can be customised to use specific docker-compose file, service name and port by @EVMComposeTest(\"src/test/resources/geth.yml\", \"ethnode1\", 8080) Here, we connect to the service named ethnode1 in the src/test/resources/geth.yml docker-compose file which exposes the port 8080 for web3j to connect to. @EVMComposeTest ( \"src/test/resources/geth.yml\" , \"ethnode1\" , 8080 ) public class GreeterTest { } Inject instance of Web3j , TransactionManager and ContractGasProvider in your test method. @EVMComposeTest ( \"src/test/resources/geth.yml\" , \"ethnode1\" , 8080 ) public class GreeterTest { @Test public void greeterDeploys ( Web3j web3j , TransactionManager transactionManager , ContractGasProvider gasProvider ) { } } Deploy your contract in the test. @EVMComposeTest ( \"src/test/resources/geth.yml\" , \"ethnode1\" , 8080 ) public class GreeterTest { @Test public void greeterDeploys ( Web3j web3j , TransactionManager transactionManager , ContractGasProvider gasProvider ) { Greeter greeter = Greeter . deploy ( web3j , transactionManager , gasProvider , \"Hello EVM\" ). send (); String greeting = greeter . greet (). send (); assertEquals ( \"Hello EVM\" , greeting ); } } Run the test! Sample projects \u00b6 Sample project using @EVMTest can be found here . This uses @EVMComposeTest to test the Greeter contract using VMWare Concord nodes using a docker-compose file.","title":"Web3j Unit"},{"location":"web3j_unit/#web3j-unit","text":"Web3j-unit is an extension to JUnit 5 which enables you to test solidity contracts like any other Java code. It allows you to test with both an embedded and dockerized Ethereum nodes, with out-of-the box support for Geth, Besu, and OpenEthereum nodes. A docker-compose network can also be configured easily for more complex setups.","title":"Web3j Unit"},{"location":"web3j_unit/#usage","text":"First, let's add the gradle dependency. repositories { mavenCentral () jcenter () } implementation \"org.web3j:core:4.5.11\" testCompile \"org.web3j:web3j-unit:4.5.11\"","title":"Usage"},{"location":"web3j_unit/#using-evmtest-annotation","text":"Create a new test with the @EVMTest annotation. An embedded EVM is used by default. To use Geth or Besu pass the node type into the annotation: @EVMTest(NodeType.GETH) or @EVMTest(NodeType.BESU) @EVMTest public class GreeterTest { } Inject instance of Web3j , TransactionManager and ContractGasProvider in your test method. @EVMTest public class GreeterTest { @Test public void greeterDeploys ( Web3j web3j , TransactionManager transactionManager , ContractGasProvider gasProvider ) { } } Deploy your contract in the test. @EVMTest public class GreeterTest { @Test public void greeterDeploys ( Web3j web3j , TransactionManager transactionManager , ContractGasProvider gasProvider ) { Greeter greeter = Greeter . deploy ( web3j , transactionManager , gasProvider , \"Hello EVM\" ). send (); String greeting = greeter . greet (). send (); assertEquals ( \"Hello EVM\" , greeting ); } } Run the test!","title":"Using EVMTest annotation"},{"location":"web3j_unit/#using-evmcomposetest-annotation","text":"Create a new test with the @EVMComposeTest annotation. By default, it uses test.yml file in the project home, and runs web3j on service named node1 exposing the port 8545 . Can be customised to use specific docker-compose file, service name and port by @EVMComposeTest(\"src/test/resources/geth.yml\", \"ethnode1\", 8080) Here, we connect to the service named ethnode1 in the src/test/resources/geth.yml docker-compose file which exposes the port 8080 for web3j to connect to. @EVMComposeTest ( \"src/test/resources/geth.yml\" , \"ethnode1\" , 8080 ) public class GreeterTest { } Inject instance of Web3j , TransactionManager and ContractGasProvider in your test method. @EVMComposeTest ( \"src/test/resources/geth.yml\" , \"ethnode1\" , 8080 ) public class GreeterTest { @Test public void greeterDeploys ( Web3j web3j , TransactionManager transactionManager , ContractGasProvider gasProvider ) { } } Deploy your contract in the test. @EVMComposeTest ( \"src/test/resources/geth.yml\" , \"ethnode1\" , 8080 ) public class GreeterTest { @Test public void greeterDeploys ( Web3j web3j , TransactionManager transactionManager , ContractGasProvider gasProvider ) { Greeter greeter = Greeter . deploy ( web3j , transactionManager , gasProvider , \"Hello EVM\" ). send (); String greeting = greeter . greet (). send (); assertEquals ( \"Hello EVM\" , greeting ); } } Run the test!","title":"Using EVMComposeTest annotation"},{"location":"web3j_unit/#sample-projects","text":"Sample project using @EVMTest can be found here . This uses @EVMComposeTest to test the Greeter contract using VMWare Concord nodes using a docker-compose file.","title":"Sample projects"},{"location":"advanced/ethereum_name_service/","text":"Ethereum Name Service \u00b6 The Ethereum Name Service (ENS) provides a human readable names to identify addresses on the Ethereum network. It is similar to the internet's domain name service (DNS) which provides human-readable domain names which are mapped to IP addresses. In the case of ENS, the addresses are either wallet or smart contract addresses. E.g. instead of using the wallet address 0x19e03255f667bdfd50a32722df860b1eeaf4d635 , you can use web3j.eth . Usage in web3j \u00b6 You can use ENS names anywhere you wish to transact in web3j. In practice this means, in smart contract wrappers, when you load them, such as: YourSmartContract contract = YourSmartContract . load ( \"0x<address>|<ensName>\" , web3j , credentials , GAS_PRICE , GAS_LIMIT ); Also, when performing Ether transfers, such as using the command line tools: $ web3j wallet send <walletfile> 0x<address> | <ensName> web3j implementation \u00b6 Behind the scenes, whenever you using web3j's transaction managers (which are derived from the ManagedTransaction class), the EnsResolver is invoked to perform an ENS lookup if applicable. The resolution process is as follows: Check to see if our Ethereum node is fully synced If not fail If it is synced, check the timestamp on the most recent block it has. If it's more than 3 minutes old, fail. Otherwise perform the lookup If you need to change the threshold parameter of what constitutes being synced to something other then 3 minutes, this can be done via the setSyncThreshold method in the ManagedTransaction class. Unicode Technical Standard (UTS) #46 \u00b6 UTS #46 is the standard used to sanitise input on domain names. The web3j ENS implementation performs this sanitation on all inputs before attempting resolution. For details of the implementation, refer to the NameHash class. Registering domain names \u00b6 Currently, web3j only supports the resolution of ENS domains. It does not support the registration. For instructions on how to do this, refer to the ENS documentation .","title":"Ethereum Name Service"},{"location":"advanced/ethereum_name_service/#ethereum-name-service","text":"The Ethereum Name Service (ENS) provides a human readable names to identify addresses on the Ethereum network. It is similar to the internet's domain name service (DNS) which provides human-readable domain names which are mapped to IP addresses. In the case of ENS, the addresses are either wallet or smart contract addresses. E.g. instead of using the wallet address 0x19e03255f667bdfd50a32722df860b1eeaf4d635 , you can use web3j.eth .","title":"Ethereum Name Service"},{"location":"advanced/ethereum_name_service/#usage-in-web3j","text":"You can use ENS names anywhere you wish to transact in web3j. In practice this means, in smart contract wrappers, when you load them, such as: YourSmartContract contract = YourSmartContract . load ( \"0x<address>|<ensName>\" , web3j , credentials , GAS_PRICE , GAS_LIMIT ); Also, when performing Ether transfers, such as using the command line tools: $ web3j wallet send <walletfile> 0x<address> | <ensName>","title":"Usage in web3j"},{"location":"advanced/ethereum_name_service/#web3j-implementation","text":"Behind the scenes, whenever you using web3j's transaction managers (which are derived from the ManagedTransaction class), the EnsResolver is invoked to perform an ENS lookup if applicable. The resolution process is as follows: Check to see if our Ethereum node is fully synced If not fail If it is synced, check the timestamp on the most recent block it has. If it's more than 3 minutes old, fail. Otherwise perform the lookup If you need to change the threshold parameter of what constitutes being synced to something other then 3 minutes, this can be done via the setSyncThreshold method in the ManagedTransaction class.","title":"web3j implementation"},{"location":"advanced/ethereum_name_service/#unicode-technical-standard-uts-46","text":"UTS #46 is the standard used to sanitise input on domain names. The web3j ENS implementation performs this sanitation on all inputs before attempting resolution. For details of the implementation, refer to the NameHash class.","title":"Unicode Technical Standard (UTS) #46"},{"location":"advanced/ethereum_name_service/#registering-domain-names","text":"Currently, web3j only supports the resolution of ENS domains. It does not support the registration. For instructions on how to do this, refer to the ENS documentation .","title":"Registering domain names"},{"location":"advanced/filters_and_events/","text":"Filters and Events \u00b6 Filters provide notifications of certain events taking place in the Ethereum network. There are three classes of filter supported in Ethereum: Block filters Pending transaction filters Topic filters Block filters and pending transaction filters provide notification of the creation of new transactions or blocks on the network. Topic filters are more flexible. These allow you to create a filter based on specific criteria that you provide. Unfortunately, unless you are using a WebSocket connection to Geth, working with filters via the JSON-RPC API is a tedious process, where you need to poll the Ethereum client in order to find out if there are any updates to your filters due to the synchronous nature of HTTP and IPC requests. Additionally the block and transaction filters only provide the transaction or block hash, so a further request is required to obtain the actual transaction or block referred to by the hash. web3j's managed Filter implementation address these issues, so you have a fully asynchronous event based API for working with filters. It uses RxJava 's Flowables which provides a consistent API for working with events, which facilitates the chaining together of JSON-RPC calls via functional composition. Note: filters are not supported on Infura. Block and transaction filters \u00b6 To receive all new blocks as they are added to the blockchain (the false parameter specifies that we only want the blocks, not the embedded transactions too): Subscription subscription = web3j . blockFlowable ( false ). subscribe ( block -> { ... }); To receive all new transactions as they are added to the blockchain: Subscription subscription = web3j . transactionFlowable (). subscribe ( tx -> { ... }); To receive all pending transactions as they are submitted to the network (i.e. before they have been grouped into a block together): Subscription subscription = web3j . pendingTransactionFlowable (). subscribe ( tx -> { ... }); Subscriptions should always be cancelled when no longer required via unsubscribe : subscription . unsubscribe (); Other callbacks are also provided which provide simply the block or transaction hashes, for details of these refer to the Web3jRx interface. Replay filters \u00b6 web3j also provides filters for replaying block and transaction history. To replay a range of blocks from the blockchain: Subscription subscription = web3j . replayBlocksFlowable ( < startBlockNumber > , < endBlockNumber > , < fullTxObjects > ) . subscribe ( block -> { ... }); To replay the individual transactions contained within a range of blocks: Subscription subscription = web3j . replayTransactionsFlowable ( < startBlockNumber > , < endBlockNumber > ) . subscribe ( tx -> { ... }); You can also get web3j to replay all blocks up to the most current, and provide notification (via the submitted Flowable) once you've caught up: Subscription subscription = web3j . replayPastBlocksFlowable ( < startBlockNumber > , < fullTxObjects > , < onCompleteFlowable > ) . subscribe ( block -> { ... }); Or, if you'd rather replay all blocks to the most current, then be notified of new subsequent blocks being created: Subscription subscription = web3j . replayPastAndFutureBlocksFlowable ( < startBlockNumber > , < fullTxObjects > ) . subscribe ( block -> { ... }); As above, but with transactions contained within blocks: Subscription subscription = web3j . replayPastAndFutureTransactionsFlowable ( < startBlockNumber > ) . subscribe ( tx -> { ... }); All of the above filters are exported via the Web3jRx interface. Topic filters and EVM events \u00b6 Topic filters capture details of Ethereum Virtual Machine (EVM) events taking place in the network. These events are created by smart contracts and stored in the transaction log associated with a smart contract. The Solidity documentation provides a good overview of EVM events. You use the EthFilter type to specify the topics that you wish to apply to the filter. This can include the address of the smart contract you wish to apply the filter to. You can also provide specific topics to filter on. Where the individual topics represent indexed parameters on the smart contract: EthFilter filter = new EthFilter ( DefaultBlockParameterName . EARLIEST , DefaultBlockParameterName . LATEST , < contract - address > ) [ . addSingleTopic (...) | . addOptionalTopics (..., ...) | ... ] ; This filter can then be created using a similar syntax to the block and transaction filters above: web3j . ethLogFlowable ( filter ). subscribe ( log -> { ... }); The filter topics can only refer to the indexed Solidity event parameters. It is not possible to filter on the non-indexed event parameters. Additionally, for any indexed event parameters that are variable length array types such as string and bytes, the Keccak-256 hash of their value is stored on the EVM log. It is not possible to store or filter using their full value. If you create a filter instance with no topics associated with it, all EVM events taking place in the network will be captured by the filter. A note on functional composition \u00b6 In addition to send() and sendAsync , all JSON-RPC method implementations in web3j support the flowable() method to create a Flowable to execute the request asynchronously. This makes it very straight forwards to compose JSON-RPC calls together into new functions. For instance, the blockFlowable is itself composed of a number of separate JSON-RPC calls: public Flowable < EthBlock > blockFlowable ( boolean fullTransactionObjects , long pollingInterval ) { return this . ethBlockHashFlowable ( pollingInterval ) . flatMap ( blockHash -> web3j . ethGetBlockByHash ( blockHash , fullTransactionObjects ). flowable ()); } Here we first create a flowable that provides notifications of the block hash of each newly created block. We then use flatMap to invoke a call to ethGetBlockByHash to obtain the full block details which is what is passed to the subscriber of the flowable. Further examples \u00b6 Please refer to the integration test FlowableIT for further examples. For a demonstration of using the manual filter API, you can take a look at the test EventFilterIT .","title":"Filters and Events"},{"location":"advanced/filters_and_events/#filters-and-events","text":"Filters provide notifications of certain events taking place in the Ethereum network. There are three classes of filter supported in Ethereum: Block filters Pending transaction filters Topic filters Block filters and pending transaction filters provide notification of the creation of new transactions or blocks on the network. Topic filters are more flexible. These allow you to create a filter based on specific criteria that you provide. Unfortunately, unless you are using a WebSocket connection to Geth, working with filters via the JSON-RPC API is a tedious process, where you need to poll the Ethereum client in order to find out if there are any updates to your filters due to the synchronous nature of HTTP and IPC requests. Additionally the block and transaction filters only provide the transaction or block hash, so a further request is required to obtain the actual transaction or block referred to by the hash. web3j's managed Filter implementation address these issues, so you have a fully asynchronous event based API for working with filters. It uses RxJava 's Flowables which provides a consistent API for working with events, which facilitates the chaining together of JSON-RPC calls via functional composition. Note: filters are not supported on Infura.","title":"Filters and Events"},{"location":"advanced/filters_and_events/#block-and-transaction-filters","text":"To receive all new blocks as they are added to the blockchain (the false parameter specifies that we only want the blocks, not the embedded transactions too): Subscription subscription = web3j . blockFlowable ( false ). subscribe ( block -> { ... }); To receive all new transactions as they are added to the blockchain: Subscription subscription = web3j . transactionFlowable (). subscribe ( tx -> { ... }); To receive all pending transactions as they are submitted to the network (i.e. before they have been grouped into a block together): Subscription subscription = web3j . pendingTransactionFlowable (). subscribe ( tx -> { ... }); Subscriptions should always be cancelled when no longer required via unsubscribe : subscription . unsubscribe (); Other callbacks are also provided which provide simply the block or transaction hashes, for details of these refer to the Web3jRx interface.","title":"Block and transaction filters"},{"location":"advanced/filters_and_events/#replay-filters","text":"web3j also provides filters for replaying block and transaction history. To replay a range of blocks from the blockchain: Subscription subscription = web3j . replayBlocksFlowable ( < startBlockNumber > , < endBlockNumber > , < fullTxObjects > ) . subscribe ( block -> { ... }); To replay the individual transactions contained within a range of blocks: Subscription subscription = web3j . replayTransactionsFlowable ( < startBlockNumber > , < endBlockNumber > ) . subscribe ( tx -> { ... }); You can also get web3j to replay all blocks up to the most current, and provide notification (via the submitted Flowable) once you've caught up: Subscription subscription = web3j . replayPastBlocksFlowable ( < startBlockNumber > , < fullTxObjects > , < onCompleteFlowable > ) . subscribe ( block -> { ... }); Or, if you'd rather replay all blocks to the most current, then be notified of new subsequent blocks being created: Subscription subscription = web3j . replayPastAndFutureBlocksFlowable ( < startBlockNumber > , < fullTxObjects > ) . subscribe ( block -> { ... }); As above, but with transactions contained within blocks: Subscription subscription = web3j . replayPastAndFutureTransactionsFlowable ( < startBlockNumber > ) . subscribe ( tx -> { ... }); All of the above filters are exported via the Web3jRx interface.","title":"Replay filters"},{"location":"advanced/filters_and_events/#topic-filters-and-evm-events","text":"Topic filters capture details of Ethereum Virtual Machine (EVM) events taking place in the network. These events are created by smart contracts and stored in the transaction log associated with a smart contract. The Solidity documentation provides a good overview of EVM events. You use the EthFilter type to specify the topics that you wish to apply to the filter. This can include the address of the smart contract you wish to apply the filter to. You can also provide specific topics to filter on. Where the individual topics represent indexed parameters on the smart contract: EthFilter filter = new EthFilter ( DefaultBlockParameterName . EARLIEST , DefaultBlockParameterName . LATEST , < contract - address > ) [ . addSingleTopic (...) | . addOptionalTopics (..., ...) | ... ] ; This filter can then be created using a similar syntax to the block and transaction filters above: web3j . ethLogFlowable ( filter ). subscribe ( log -> { ... }); The filter topics can only refer to the indexed Solidity event parameters. It is not possible to filter on the non-indexed event parameters. Additionally, for any indexed event parameters that are variable length array types such as string and bytes, the Keccak-256 hash of their value is stored on the EVM log. It is not possible to store or filter using their full value. If you create a filter instance with no topics associated with it, all EVM events taking place in the network will be captured by the filter.","title":"Topic filters and EVM events"},{"location":"advanced/filters_and_events/#a-note-on-functional-composition","text":"In addition to send() and sendAsync , all JSON-RPC method implementations in web3j support the flowable() method to create a Flowable to execute the request asynchronously. This makes it very straight forwards to compose JSON-RPC calls together into new functions. For instance, the blockFlowable is itself composed of a number of separate JSON-RPC calls: public Flowable < EthBlock > blockFlowable ( boolean fullTransactionObjects , long pollingInterval ) { return this . ethBlockHashFlowable ( pollingInterval ) . flatMap ( blockHash -> web3j . ethGetBlockByHash ( blockHash , fullTransactionObjects ). flowable ()); } Here we first create a flowable that provides notifications of the block hash of each newly created block. We then use flatMap to invoke a call to ethGetBlockByHash to obtain the full block details which is what is passed to the subscriber of the flowable.","title":"A note on functional composition"},{"location":"advanced/filters_and_events/#further-examples","text":"Please refer to the integration test FlowableIT for further examples. For a demonstration of using the manual filter API, you can take a look at the test EventFilterIT .","title":"Further examples"},{"location":"advanced/management_apis/","text":"Management APIs \u00b6 In addition to implementing the standard JSON-RPC API, Ethereum clients, such as Geth and OpenEthereum provide additional management via JSON-RPC. One of the key common pieces of functionality that they provide is the ability to create and unlock Ethereum accounts for transacting on the network. In Geth and OpenEthereum, this is implemented in their Personal modules, details of which are available below: OpenEthereum Geth Support for the personal modules is available in web3j. Those methods that are common to both Geth and OpenEthereum reside in the Admin module of web3j. You can initialise a new web3j connector that supports this module using the factory method: Admin web3j = Admin . build ( new HttpService ()); // defaults to http://localhost:8545/ PersonalUnlockAccount personalUnlockAccount = admin . personalUnlockAccount ( \"0x000...\" , \"a password\" ). send (); if ( personalUnlockAccount . accountUnlocked ()) { // send a transaction } For Geth specific methods, you can use the Geth connector, and for OpenEthereum you can use the associated OpenEthereum connector. The Parity connector also provides support for OpenEthereum's Trace module. These connectors are available in the web3j geth and parity modules respectively. You can refer to the integration test ParityIT for further examples of working with these APIs.","title":"Management Apis"},{"location":"advanced/management_apis/#management-apis","text":"In addition to implementing the standard JSON-RPC API, Ethereum clients, such as Geth and OpenEthereum provide additional management via JSON-RPC. One of the key common pieces of functionality that they provide is the ability to create and unlock Ethereum accounts for transacting on the network. In Geth and OpenEthereum, this is implemented in their Personal modules, details of which are available below: OpenEthereum Geth Support for the personal modules is available in web3j. Those methods that are common to both Geth and OpenEthereum reside in the Admin module of web3j. You can initialise a new web3j connector that supports this module using the factory method: Admin web3j = Admin . build ( new HttpService ()); // defaults to http://localhost:8545/ PersonalUnlockAccount personalUnlockAccount = admin . personalUnlockAccount ( \"0x000...\" , \"a password\" ). send (); if ( personalUnlockAccount . accountUnlocked ()) { // send a transaction } For Geth specific methods, you can use the Geth connector, and for OpenEthereum you can use the associated OpenEthereum connector. The Parity connector also provides support for OpenEthereum's Trace module. These connectors are available in the web3j geth and parity modules respectively. You can refer to the integration test ParityIT for further examples of working with these APIs.","title":"Management APIs"},{"location":"advanced/recursive_length_prefix/","text":"Recursive Length Prefix \u00b6 The Recursive Length Prefix (RLP) encoding scheme is a space efficient object serialization scheme used in Ethereum. The specification itself is defined in the Yellow Paper , and the following page on the Ethereum Wiki . RLP Types \u00b6 The RLP encoder defined two supported types: string list The list type can be nested an arbitrary number of times allowing complex data structures to be encoded. The RLP module in web3j provides RLP encoding capabilities, with the RlpEncoderTest demonstrating encoding of a number of different values. Transaction encoding \u00b6 Within web3j, RLP encoding is used to encode Ethereum transaction objects into a byte array which is signed before submission to the network. The transaction types and signing logic are located within the Crypto module, with the TransactionEncoderTest providing examples of transaction signing and encoding. Dependencies \u00b6 This is a very lightweight module, with no other dependencies. The hope is that other projects wishing to work with Ethereum's RLP encoding on the JVM or Android will choose to make use of this module rather then write their own implementations.","title":"Recursive Length Prefix"},{"location":"advanced/recursive_length_prefix/#recursive-length-prefix","text":"The Recursive Length Prefix (RLP) encoding scheme is a space efficient object serialization scheme used in Ethereum. The specification itself is defined in the Yellow Paper , and the following page on the Ethereum Wiki .","title":"Recursive Length Prefix"},{"location":"advanced/recursive_length_prefix/#rlp-types","text":"The RLP encoder defined two supported types: string list The list type can be nested an arbitrary number of times allowing complex data structures to be encoded. The RLP module in web3j provides RLP encoding capabilities, with the RlpEncoderTest demonstrating encoding of a number of different values.","title":"RLP Types"},{"location":"advanced/recursive_length_prefix/#transaction-encoding","text":"Within web3j, RLP encoding is used to encode Ethereum transaction objects into a byte array which is signed before submission to the network. The transaction types and signing logic are located within the Crypto module, with the TransactionEncoderTest providing examples of transaction signing and encoding.","title":"Transaction encoding"},{"location":"advanced/recursive_length_prefix/#dependencies","text":"This is a very lightweight module, with no other dependencies. The hope is that other projects wishing to work with Ethereum's RLP encoding on the JVM or Android will choose to make use of this module rather then write their own implementations.","title":"Dependencies"},{"location":"advanced/tls_websockets/","text":"TLS over Websockets \u00b6 It is also possible to use TLS with the WebSocketConnection, remember to change your protocol from ws to wss . For stricter requirements one can define a custom keystore for their SSL certificates by passing in a modified WebSocketClient to the WebSocketService : final WebSocketClient webSocketClient = new WebSocketClient ( new URI ( \"<WSS-ENDPOINT>\" )); final WebSocketService webSocketService = new WebSocketService ( webSocketClient , false ); // Load the keystore final KeyStore ks = KeyStore . getInstance ( STORETYPE ); final File kf = new File ( KEYSTORE_PATH ); ks . load ( new FileInputStream ( kf ), STOREPASSWORD . toCharArray ()); final KeyManagerFactory kmf = KeyManagerFactory . getInstance ( \"SunX509\" ); kmf . init ( ks , KEYPASSWORD . toCharArray ()); final TrustManagerFactory tmf = TrustManagerFactory . getInstance ( \"SunX509\" ); tmf . init ( ks ); // Create SSL socket final SSLContext sslContext = SSLContext . getInstance ( \"TLS\" ); sslContext . init ( kmf . getKeyManagers (), tmf . getTrustManagers (), null ); final SSLSocketFactory sslSocketFactory = sslContext . getSocketFactory (); // Use SSL socket in websocket client webSocketClient . setSocket ( sslSocketFactory . createSocket ()); webSocketService . connect (); final Web3j web3j = Web3j . build ( webSocketService );","title":"TLS over Websockets"},{"location":"advanced/tls_websockets/#tls-over-websockets","text":"It is also possible to use TLS with the WebSocketConnection, remember to change your protocol from ws to wss . For stricter requirements one can define a custom keystore for their SSL certificates by passing in a modified WebSocketClient to the WebSocketService : final WebSocketClient webSocketClient = new WebSocketClient ( new URI ( \"<WSS-ENDPOINT>\" )); final WebSocketService webSocketService = new WebSocketService ( webSocketClient , false ); // Load the keystore final KeyStore ks = KeyStore . getInstance ( STORETYPE ); final File kf = new File ( KEYSTORE_PATH ); ks . load ( new FileInputStream ( kf ), STOREPASSWORD . toCharArray ()); final KeyManagerFactory kmf = KeyManagerFactory . getInstance ( \"SunX509\" ); kmf . init ( ks , KEYPASSWORD . toCharArray ()); final TrustManagerFactory tmf = TrustManagerFactory . getInstance ( \"SunX509\" ); tmf . init ( ks ); // Create SSL socket final SSLContext sslContext = SSLContext . getInstance ( \"TLS\" ); sslContext . init ( kmf . getKeyManagers (), tmf . getTrustManagers (), null ); final SSLSocketFactory sslSocketFactory = sslContext . getSocketFactory (); // Use SSL socket in websocket client webSocketClient . setSocket ( sslSocketFactory . createSocket ()); webSocketService . connect (); final Web3j web3j = Web3j . build ( webSocketService );","title":"TLS over Websockets"},{"location":"advanced/web3j_core_modules/","text":"Web3j Core Modules \u00b6 To provide greater flexibility for developers wishing to work with web3j, the project is made up of a number of modules. In dependency order, they are as follows: utils - Minimal set of utility classes rlp - Recursive Length Prefix (RLP) encoders abi - Application Binary Interface (ABI) encoders crypto - cryptographic library for transaction signing and key/wallet management in Ethereum tuples - Simple tuples library core - Much like the previous web3j core artifact without the code generators codegen - code generators console - command-line tools The below modules only depend on the core module. geth - Geth specific JSON-RPC module parity - OpenEthereum specific JSON-RPC module infura - Infura specific HTTP header support contracts - Support for specific EIP's (Ethereum Improvement Proposals) besu - Support for private transactions on Hyperledger Besu For most use cases (interacting with the network and smart contracts) the core module should be all you need. The dependencies of the core module are very granular and only likely to be of use if your project is focussed on a very specific interaction with the Ethereum network (such as ABI/RLP encoding, transaction signing but not submission, etc). All modules are published to both Maven Central and Bintray, with the published artifact names using the names listed above, i.e.: For Java: org.web3j: <module-name\\> : <version\\> For Android: org.web3j: <module-name\\> : <version\\>-android Further details \u00b6 In the Java build: Web3j provides type safe access to all responses. Optional or null responses are wrapped in Java's Optional type. Asynchronous requests are wrapped in a Java CompletableFutures . Web3j provides a wrapper around all async requests to ensure that any exceptions during execution will be captured rather then silently discarded. This is due to the lack of support in CompletableFutures for checked exceptions, which are often rethrown as unchecked exception causing problems with detection. See the Async.run() and its associated test for details. In both the Java and Android builds: Quantity payload types are returned as BigIntegers . For simple results, you can obtain the quantity as a String via Response .getResult(). It's also possible to include the raw JSON payload in responses via the includeRawResponse parameter, present in the HttpService and IpcService classes.","title":"Web3j Core Modules"},{"location":"advanced/web3j_core_modules/#web3j-core-modules","text":"To provide greater flexibility for developers wishing to work with web3j, the project is made up of a number of modules. In dependency order, they are as follows: utils - Minimal set of utility classes rlp - Recursive Length Prefix (RLP) encoders abi - Application Binary Interface (ABI) encoders crypto - cryptographic library for transaction signing and key/wallet management in Ethereum tuples - Simple tuples library core - Much like the previous web3j core artifact without the code generators codegen - code generators console - command-line tools The below modules only depend on the core module. geth - Geth specific JSON-RPC module parity - OpenEthereum specific JSON-RPC module infura - Infura specific HTTP header support contracts - Support for specific EIP's (Ethereum Improvement Proposals) besu - Support for private transactions on Hyperledger Besu For most use cases (interacting with the network and smart contracts) the core module should be all you need. The dependencies of the core module are very granular and only likely to be of use if your project is focussed on a very specific interaction with the Ethereum network (such as ABI/RLP encoding, transaction signing but not submission, etc). All modules are published to both Maven Central and Bintray, with the published artifact names using the names listed above, i.e.: For Java: org.web3j: <module-name\\> : <version\\> For Android: org.web3j: <module-name\\> : <version\\>-android","title":"Web3j Core Modules"},{"location":"advanced/web3j_core_modules/#further-details","text":"In the Java build: Web3j provides type safe access to all responses. Optional or null responses are wrapped in Java's Optional type. Asynchronous requests are wrapped in a Java CompletableFutures . Web3j provides a wrapper around all async requests to ensure that any exceptions during execution will be captured rather then silently discarded. This is due to the lack of support in CompletableFutures for checked exceptions, which are often rethrown as unchecked exception causing problems with detection. See the Async.run() and its associated test for details. In both the Java and Android builds: Quantity payload types are returned as BigIntegers . For simple results, you can obtain the quantity as a String via Response .getResult(). It's also possible to include the raw JSON payload in responses via the includeRawResponse parameter, present in the HttpService and IpcService classes.","title":"Further details"},{"location":"getting_started/deploy_interact_smart_contracts/","text":"Working with smart contracts and Java smart contract wrappers \u00b6 Web3j can auto-generate smart contract wrapper code to deploy and interact with smart contracts without leaving the JVM. To generate the wrapper code, compile your smart contract: $ solc <contract>.sol --bin --abi --optimize -o <output-dir>/ Then generate the wrapper code using the Epirus CLI : epirus solidity generate -b /path/to/<smart-contract>.bin -a /path/to/<smart-contract>.abi -o /path/to/src/main/java -p com.your.organisation.name Now you can create and deploy your smart contract: Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils . loadCredentials ( \"password\" , \"/path/to/walletfile\" ); YourSmartContract contract = YourSmartContract . deploy ( < web3j > , < credentials > , GAS_PRICE , GAS_LIMIT , < param1 > , ..., < paramN > ). send (); // constructor params Or use an existing contract: YourSmartContract contract = YourSmartContract . load ( \"0x<address>|<ensName>\" , < web3j > , < credentials > , GAS_PRICE , GAS_LIMIT ); To transact with a smart contract: TransactionReceipt transactionReceipt = contract . someMethod ( < param1 > , ...). send (); To call a smart contract: Type result = contract . someMethod ( < param1 > , ...). send (); For more information refer to Solidity smart contract wrappers . Smart contract examples \u00b6 Web3j provides a number of smart contract examples in the project directory codegen/src/test/resources/solidity It also provides integration tests for demonstrating the deploying and working with those smart contracts in the integration-tests/src/test/java/org/web3j/protocol/scenarios module. EIP-20 Ethereum token standard smart contract \u00b6 There an Ethereum standard, EIP-20 which started off as an Ethereum Improvement Proposal (EIP) , that defines the standard functions that a smart contract providing tokens should implement. The EIP-20 standard provides function definitions, but does not provide an implementation example. However, there is an implementation provided in codegen/src/test/resources/solidity/contracts , which has been taken from ConsenSys' Tokens project . Open Zeppelin also provide an example implementation on GitHub . There are two integration tests that have been written to fully demonstrate the functionality of this token smart contract. HumanStandardTokenGeneratedIT uses the generated HumanStandardTokenGenerated Solidity smart contract wrappers to demonstrate this. Alternatively, if you do not wish to use a smart contract wrapper and would like to work directly with the underlying JSON-RPC calls, please refer to HumanStandardTokenIT .","title":"Deploy and Interact with Smart Contracts"},{"location":"getting_started/deploy_interact_smart_contracts/#working-with-smart-contracts-and-java-smart-contract-wrappers","text":"Web3j can auto-generate smart contract wrapper code to deploy and interact with smart contracts without leaving the JVM. To generate the wrapper code, compile your smart contract: $ solc <contract>.sol --bin --abi --optimize -o <output-dir>/ Then generate the wrapper code using the Epirus CLI : epirus solidity generate -b /path/to/<smart-contract>.bin -a /path/to/<smart-contract>.abi -o /path/to/src/main/java -p com.your.organisation.name Now you can create and deploy your smart contract: Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils . loadCredentials ( \"password\" , \"/path/to/walletfile\" ); YourSmartContract contract = YourSmartContract . deploy ( < web3j > , < credentials > , GAS_PRICE , GAS_LIMIT , < param1 > , ..., < paramN > ). send (); // constructor params Or use an existing contract: YourSmartContract contract = YourSmartContract . load ( \"0x<address>|<ensName>\" , < web3j > , < credentials > , GAS_PRICE , GAS_LIMIT ); To transact with a smart contract: TransactionReceipt transactionReceipt = contract . someMethod ( < param1 > , ...). send (); To call a smart contract: Type result = contract . someMethod ( < param1 > , ...). send (); For more information refer to Solidity smart contract wrappers .","title":"Working with smart contracts and Java smart contract wrappers"},{"location":"getting_started/deploy_interact_smart_contracts/#smart-contract-examples","text":"Web3j provides a number of smart contract examples in the project directory codegen/src/test/resources/solidity It also provides integration tests for demonstrating the deploying and working with those smart contracts in the integration-tests/src/test/java/org/web3j/protocol/scenarios module.","title":"Smart contract examples"},{"location":"getting_started/deploy_interact_smart_contracts/#eip-20-ethereum-token-standard-smart-contract","text":"There an Ethereum standard, EIP-20 which started off as an Ethereum Improvement Proposal (EIP) , that defines the standard functions that a smart contract providing tokens should implement. The EIP-20 standard provides function definitions, but does not provide an implementation example. However, there is an implementation provided in codegen/src/test/resources/solidity/contracts , which has been taken from ConsenSys' Tokens project . Open Zeppelin also provide an example implementation on GitHub . There are two integration tests that have been written to fully demonstrate the functionality of this token smart contract. HumanStandardTokenGeneratedIT uses the generated HumanStandardTokenGenerated Solidity smart contract wrappers to demonstrate this. Alternatively, if you do not wish to use a smart contract wrapper and would like to work directly with the underlying JSON-RPC calls, please refer to HumanStandardTokenIT .","title":"EIP-20 Ethereum token standard smart contract"},{"location":"getting_started/interacting_with_node/","text":"Start sending requests \u00b6 To send synchronous requests: Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ Web3ClientVersion web3ClientVersion = web3 . web3ClientVersion (). send (); String clientVersion = web3ClientVersion . getWeb3ClientVersion (); To send asynchronous requests using a CompletableFuture (Future on Android): Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ Web3ClientVersion web3ClientVersion = web3 . web3ClientVersion (). sendAsync (). get (); String clientVersion = web3ClientVersion . getWeb3ClientVersion (); To use an RxJava Flowable: Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ web3 . web3ClientVersion (). flowable (). subscribe ( x -> { String clientVersion = x . getWeb3ClientVersion (); ... }); IPC \u00b6 Web3j also supports fast inter-process communication (IPC) via file sockets to clients running on the same host as web3j. To connect simply use the relevant IpcService implementation instead of HttpService when you create your service: // OS X/Linux/Unix: Web3j web3 = Web3j . build ( new UnixIpcService ( \"/path/to/socketfile\" )); ... // Windows Web3j web3 = Web3j . build ( new WindowsIpcService ( \"/path/to/namedpipefile\" )); ... Note: IPC is not available on web3j-android . Transactions \u00b6 Web3j provides support for both working with Ethereum wallet files ( recommended ) and Ethereum client admin commands for sending transactions. Send Ether \u00b6 To send Ether to another party using your Ethereum wallet file: Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils . loadCredentials ( \"password\" , \"/path/to/walletfile\" ); TransactionReceipt transactionReceipt = Transfer . sendFunds ( web3 , credentials , \"0x<address>|<ensName>\" , BigDecimal . valueOf ( 1.0 ), Convert . Unit . ETHER ) . send (); Custom Transaction \u00b6 Or if you wish to create your own custom transaction: Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils . loadCredentials ( \"password\" , \"/path/to/walletfile\" ); // get the next available nonce EthGetTransactionCount ethGetTransactionCount = web3j . ethGetTransactionCount ( address , DefaultBlockParameterName . LATEST ). send (); BigInteger nonce = ethGetTransactionCount . getTransactionCount (); // create our transaction RawTransaction rawTransaction = RawTransaction . createEtherTransaction ( nonce , < gas price > , < gas limit > , < toAddress > , < value > ); // sign & send our transaction byte [] signedMessage = TransactionEncoder . signMessage ( rawTransaction , credentials ); String hexValue = Numeric . toHexString ( signedMessage ); EthSendTransaction ethSendTransaction = web3j . ethSendRawTransaction ( hexValue ). send (); // ... Although it's far simpler using Web3j's Transfer for transacting with Ether. Using an Ethereum client's admin commands (make sure you have your wallet in the client's keystore): Admin web3j = Admin . build ( new HttpService ()); // defaults to http://localhost:8545/ PersonalUnlockAccount personalUnlockAccount = web3j . personalUnlockAccount ( \"0x000...\" , \"a password\" ). sendAsync (). get (); if ( personalUnlockAccount . accountUnlocked ()) { // send a transaction } If you want to make use of OpenEthereum's Personal or Trace , or Geth's Personal client APIs, you can use the org.web3j:parity and org.web3j:geth modules respectively.","title":"Interacting with a Node"},{"location":"getting_started/interacting_with_node/#start-sending-requests","text":"To send synchronous requests: Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ Web3ClientVersion web3ClientVersion = web3 . web3ClientVersion (). send (); String clientVersion = web3ClientVersion . getWeb3ClientVersion (); To send asynchronous requests using a CompletableFuture (Future on Android): Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ Web3ClientVersion web3ClientVersion = web3 . web3ClientVersion (). sendAsync (). get (); String clientVersion = web3ClientVersion . getWeb3ClientVersion (); To use an RxJava Flowable: Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ web3 . web3ClientVersion (). flowable (). subscribe ( x -> { String clientVersion = x . getWeb3ClientVersion (); ... });","title":"Start sending requests"},{"location":"getting_started/interacting_with_node/#ipc","text":"Web3j also supports fast inter-process communication (IPC) via file sockets to clients running on the same host as web3j. To connect simply use the relevant IpcService implementation instead of HttpService when you create your service: // OS X/Linux/Unix: Web3j web3 = Web3j . build ( new UnixIpcService ( \"/path/to/socketfile\" )); ... // Windows Web3j web3 = Web3j . build ( new WindowsIpcService ( \"/path/to/namedpipefile\" )); ... Note: IPC is not available on web3j-android .","title":"IPC"},{"location":"getting_started/interacting_with_node/#transactions","text":"Web3j provides support for both working with Ethereum wallet files ( recommended ) and Ethereum client admin commands for sending transactions.","title":"Transactions"},{"location":"getting_started/interacting_with_node/#send-ether","text":"To send Ether to another party using your Ethereum wallet file: Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils . loadCredentials ( \"password\" , \"/path/to/walletfile\" ); TransactionReceipt transactionReceipt = Transfer . sendFunds ( web3 , credentials , \"0x<address>|<ensName>\" , BigDecimal . valueOf ( 1.0 ), Convert . Unit . ETHER ) . send ();","title":"Send Ether"},{"location":"getting_started/interacting_with_node/#custom-transaction","text":"Or if you wish to create your own custom transaction: Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils . loadCredentials ( \"password\" , \"/path/to/walletfile\" ); // get the next available nonce EthGetTransactionCount ethGetTransactionCount = web3j . ethGetTransactionCount ( address , DefaultBlockParameterName . LATEST ). send (); BigInteger nonce = ethGetTransactionCount . getTransactionCount (); // create our transaction RawTransaction rawTransaction = RawTransaction . createEtherTransaction ( nonce , < gas price > , < gas limit > , < toAddress > , < value > ); // sign & send our transaction byte [] signedMessage = TransactionEncoder . signMessage ( rawTransaction , credentials ); String hexValue = Numeric . toHexString ( signedMessage ); EthSendTransaction ethSendTransaction = web3j . ethSendRawTransaction ( hexValue ). send (); // ... Although it's far simpler using Web3j's Transfer for transacting with Ether. Using an Ethereum client's admin commands (make sure you have your wallet in the client's keystore): Admin web3j = Admin . build ( new HttpService ()); // defaults to http://localhost:8545/ PersonalUnlockAccount personalUnlockAccount = web3j . personalUnlockAccount ( \"0x000...\" , \"a password\" ). sendAsync (). get (); if ( personalUnlockAccount . accountUnlocked ()) { // send a transaction } If you want to make use of OpenEthereum's Personal or Trace , or Geth's Personal client APIs, you can use the org.web3j:parity and org.web3j:geth modules respectively.","title":"Custom Transaction"},{"location":"getting_started/manual_configuration/","text":"Manual Configuration \u00b6 The simplest way to get started with Web3j is via the powerful Epirus CLI . However, if you wish to configure your project manually, you can follow the steps outlined here. Add the latest Web3j version to your project build configuration. Maven \u00b6 Java: <dependency> <groupId> org.web3j </groupId> <artifactId> core </artifactId> <version> 4.8.1 </version> </dependency> Android: <dependency> <groupId> org.web3j </groupId> <artifactId> core </artifactId> <version> 4.6.0-android </version> </dependency> Gradle \u00b6 Java: compile ( 'org.web3j:core:4.8.1' ) Android: compile ( 'org.web3j:core:4.6.0-android' ) Plugins \u00b6 There are also gradle and maven plugins to help you generate Web3j Java wrappers for your Solidity smart contracts, thus allowing you to integrate such activities into your project lifecycle. Take a look at the project homepage for the web3j-gradle-plugin and web3j-maven-plugin for details on how to use these plugins.","title":"Manual Configuration"},{"location":"getting_started/manual_configuration/#manual-configuration","text":"The simplest way to get started with Web3j is via the powerful Epirus CLI . However, if you wish to configure your project manually, you can follow the steps outlined here. Add the latest Web3j version to your project build configuration.","title":"Manual Configuration"},{"location":"getting_started/manual_configuration/#maven","text":"Java: <dependency> <groupId> org.web3j </groupId> <artifactId> core </artifactId> <version> 4.8.1 </version> </dependency> Android: <dependency> <groupId> org.web3j </groupId> <artifactId> core </artifactId> <version> 4.6.0-android </version> </dependency>","title":"Maven"},{"location":"getting_started/manual_configuration/#gradle","text":"Java: compile ( 'org.web3j:core:4.8.1' ) Android: compile ( 'org.web3j:core:4.6.0-android' )","title":"Gradle"},{"location":"getting_started/manual_configuration/#plugins","text":"There are also gradle and maven plugins to help you generate Web3j Java wrappers for your Solidity smart contracts, thus allowing you to integrate such activities into your project lifecycle. Take a look at the project homepage for the web3j-gradle-plugin and web3j-maven-plugin for details on how to use these plugins.","title":"Plugins"},{"location":"getting_started/pub_sub/","text":"Filters \u00b6 Web3j functional-reactive nature makes it really simple to setup observers that notify subscribers of events taking place on the blockchain. To receive all new blocks as they are added to the blockchain: Subscription subscription = web3j . blockFlowable ( false ). subscribe ( block -> { ... }); To receive all new transactions as they are added to the blockchain: Subscription subscription = web3j . transactionFlowable (). subscribe ( tx -> { ... }); To receive all pending transactions as they are submitted to the network (i.e. before they have been grouped into a block together): Subscription subscription = web3j . pendingTransactionFlowable (). subscribe ( tx -> { ... }); Or, if you'd rather replay all blocks to the most current, and be notified of new subsequent blocks being created: Subscription subscription = replayPastAndFutureBlocksFlowable ( < startBlockNumber > , < fullTxObjects > ) . subscribe ( block -> { ... }); There are a number of other transaction and block replay Flowables described in Filters and Events . Topic filters are also supported: EthFilter filter = new EthFilter ( DefaultBlockParameterName . EARLIEST , DefaultBlockParameterName . LATEST , < contract - address > ) . addSingleTopic (...) | . addOptionalTopics (..., ...) | ...; web3j . ethLogFlowable ( filter ). subscribe ( log -> { ... }); Subscriptions should always be cancelled when no longer required: subscription . unsubscribe (); Note: filters are not supported on Infura. For further information refer to Filters and Events and the Web3jRx interface. Publish/Subscribe \u00b6 Ethereum clients implement the pub/sub mechanism that provides the capability to subscribe to events from the network, allowing these clients to take custom actions as needed. In doing so it alleviates the need to use polling and is more efficient. This is achieved by using the WebSocket protocol instead of HTTP protocol. Pub/Sub methods are available via the WebSocketService class, and allows the client to: send an RPC call over WebSocket protocol subscribe to WebSocket events unsubscribe from a stream of events To create an instance of the WebSocketService class you need to first to create an instance of the WebSocketClient that connects to an Ethereum client via WebSocket protocol, and then pass it to the WebSocketService constructor: final WebSocketClient webSocketClient = new WebSocketClient ( new URI ( \"ws://localhost/\" )); final boolean includeRawResponses = false ; final WebSocketService webSocketService = new WebSocketService ( webSocketClient , includeRawResponses ) To send an RPC request using the WebSocket protocol one need to use the sendAsync method on the WebSocketService instance: // Request to get a version of an Ethereum client final Request <? , Web3ClientVersion > request = new Request <> ( // Name of an RPC method to call \"web3_clientVersion\" , // Parameters for the method. \"web3_clientVersion\" does not expect any Collections . < String > emptyList (), // Service that is used to send a request webSocketService , // Type of an RPC call to get an Ethereum client version Web3ClientVersion . class ); // Send an asynchronous request via WebSocket protocol final CompletableFuture < Web3ClientVersion > reply = webSocketService . sendAsync ( request , Web3ClientVersion . class ); // Get result of the reply final Web3ClientVersion clientVersion = reply . get (); To use synchronous communication (i.e send a request and await a response) one would need to use the sync method instead: // Send a (synchronous) request via WebSocket protocol final Web3ClientVersion clientVersion = webSocketService . send ( request , Web3ClientVersion . class ); To subscribe to WebSocket events WebSocketService provides the subscribe method. subscribe returns an instance of the Flowable interface from the RxJava library, which allows the processing of incoming events from an Ethereum network as a reactive stream. To subscribe to a stream of events you should use WebSocketService to send an RPC method via WebSocket; this is usually eth_subscribe . Events that it subscribes to depend on parameters to the eth_subscribe method. You can find more in the RPC documentation : // A request to subscribe to a stream of events final Request <? , EthSubscribe > subscribeRequest = new Request <> ( // RPC method to subscribe to events \"eth_subscribe\" , // Parameters that specify what events to subscribe to Arrays . asList ( \"newHeads\" , Collections . emptyMap ()), // Service that is used to send a request webSocketService , EthSubscribe . class ); final Flowable < NewHeadsNotification > events = webSocketService . subscribe ( subscribeRequest , // RPC method that should be used to unsubscribe from events \"eth_unsubscribe\" , // Type of events returned by a request NewHeadsNotification . class ); // Subscribe to incoming events and process incoming events final Disposable disposable = events . subscribe ( event -> { // Process new heads event }); Notice that we need to provide a name of a method to WebSocketService that needs to be called to unsubscribe from a stream of events. This is because different Ethereum clients may have different methods to unsubscribe from particular events. For example, the OpenEthereum client requires use of the parity_unsubscribe method to unsubscribe from pub/sub events . To unsubscribe from a stream of events one needs to use a Flowable instance for a particular events stream: final Flowable < NewHeadsNotification > events = ... final Disposable disposable = events . subscribe (...) disposable . dispose (); The methods described above are quite low-level, so we can use Web3j implementation instead: final WebSocketService webSocketService = ... final Web3j web3j = Web3j . build ( webSocketService ) final Flowable < NewHeadsNotification > notifications = web3j . newHeadsNotifications ()","title":"Filters and Flowables"},{"location":"getting_started/pub_sub/#filters","text":"Web3j functional-reactive nature makes it really simple to setup observers that notify subscribers of events taking place on the blockchain. To receive all new blocks as they are added to the blockchain: Subscription subscription = web3j . blockFlowable ( false ). subscribe ( block -> { ... }); To receive all new transactions as they are added to the blockchain: Subscription subscription = web3j . transactionFlowable (). subscribe ( tx -> { ... }); To receive all pending transactions as they are submitted to the network (i.e. before they have been grouped into a block together): Subscription subscription = web3j . pendingTransactionFlowable (). subscribe ( tx -> { ... }); Or, if you'd rather replay all blocks to the most current, and be notified of new subsequent blocks being created: Subscription subscription = replayPastAndFutureBlocksFlowable ( < startBlockNumber > , < fullTxObjects > ) . subscribe ( block -> { ... }); There are a number of other transaction and block replay Flowables described in Filters and Events . Topic filters are also supported: EthFilter filter = new EthFilter ( DefaultBlockParameterName . EARLIEST , DefaultBlockParameterName . LATEST , < contract - address > ) . addSingleTopic (...) | . addOptionalTopics (..., ...) | ...; web3j . ethLogFlowable ( filter ). subscribe ( log -> { ... }); Subscriptions should always be cancelled when no longer required: subscription . unsubscribe (); Note: filters are not supported on Infura. For further information refer to Filters and Events and the Web3jRx interface.","title":"Filters"},{"location":"getting_started/pub_sub/#publishsubscribe","text":"Ethereum clients implement the pub/sub mechanism that provides the capability to subscribe to events from the network, allowing these clients to take custom actions as needed. In doing so it alleviates the need to use polling and is more efficient. This is achieved by using the WebSocket protocol instead of HTTP protocol. Pub/Sub methods are available via the WebSocketService class, and allows the client to: send an RPC call over WebSocket protocol subscribe to WebSocket events unsubscribe from a stream of events To create an instance of the WebSocketService class you need to first to create an instance of the WebSocketClient that connects to an Ethereum client via WebSocket protocol, and then pass it to the WebSocketService constructor: final WebSocketClient webSocketClient = new WebSocketClient ( new URI ( \"ws://localhost/\" )); final boolean includeRawResponses = false ; final WebSocketService webSocketService = new WebSocketService ( webSocketClient , includeRawResponses ) To send an RPC request using the WebSocket protocol one need to use the sendAsync method on the WebSocketService instance: // Request to get a version of an Ethereum client final Request <? , Web3ClientVersion > request = new Request <> ( // Name of an RPC method to call \"web3_clientVersion\" , // Parameters for the method. \"web3_clientVersion\" does not expect any Collections . < String > emptyList (), // Service that is used to send a request webSocketService , // Type of an RPC call to get an Ethereum client version Web3ClientVersion . class ); // Send an asynchronous request via WebSocket protocol final CompletableFuture < Web3ClientVersion > reply = webSocketService . sendAsync ( request , Web3ClientVersion . class ); // Get result of the reply final Web3ClientVersion clientVersion = reply . get (); To use synchronous communication (i.e send a request and await a response) one would need to use the sync method instead: // Send a (synchronous) request via WebSocket protocol final Web3ClientVersion clientVersion = webSocketService . send ( request , Web3ClientVersion . class ); To subscribe to WebSocket events WebSocketService provides the subscribe method. subscribe returns an instance of the Flowable interface from the RxJava library, which allows the processing of incoming events from an Ethereum network as a reactive stream. To subscribe to a stream of events you should use WebSocketService to send an RPC method via WebSocket; this is usually eth_subscribe . Events that it subscribes to depend on parameters to the eth_subscribe method. You can find more in the RPC documentation : // A request to subscribe to a stream of events final Request <? , EthSubscribe > subscribeRequest = new Request <> ( // RPC method to subscribe to events \"eth_subscribe\" , // Parameters that specify what events to subscribe to Arrays . asList ( \"newHeads\" , Collections . emptyMap ()), // Service that is used to send a request webSocketService , EthSubscribe . class ); final Flowable < NewHeadsNotification > events = webSocketService . subscribe ( subscribeRequest , // RPC method that should be used to unsubscribe from events \"eth_unsubscribe\" , // Type of events returned by a request NewHeadsNotification . class ); // Subscribe to incoming events and process incoming events final Disposable disposable = events . subscribe ( event -> { // Process new heads event }); Notice that we need to provide a name of a method to WebSocketService that needs to be called to unsubscribe from a stream of events. This is because different Ethereum clients may have different methods to unsubscribe from particular events. For example, the OpenEthereum client requires use of the parity_unsubscribe method to unsubscribe from pub/sub events . To unsubscribe from a stream of events one needs to use a Flowable instance for a particular events stream: final Flowable < NewHeadsNotification > events = ... final Disposable disposable = events . subscribe (...) disposable . dispose (); The methods described above are quite low-level, so we can use Web3j implementation instead: final WebSocketService webSocketService = ... final Web3j web3j = Web3j . build ( webSocketService ) final Flowable < NewHeadsNotification > notifications = web3j . newHeadsNotifications ()","title":"Publish/Subscribe"},{"location":"getting_started/run_node_locally/","text":"Web3j interacts with Ethereum client nodes. If you don't want to connect to one of the existing networks, you have different options to start a local node. Use Geth, Besu or OpenEthereum \u00b6 Geth : $ geth --rpcapi personal,db,eth,net,web3 --rpc --testnet Hyperledger Besu : $ besu ----network = dev The dev network uses has some handy default parameters . OpenEthereum : $ openethereum --chain testnet Instructions on obtaining Ether to transact on the network can be found in the testnet section of the docs . Use Epirus Local \u00b6 Epirus-local is a local ethereum client, similar to what Ganache provides, written in Kotlin. This project relies on web3-evm to execute user requests. Features \u00b6 Allows json-rpc interactions with a local ethereum blockchain. Generates a default genesis file containing 10 ethereum accounts or lets you use your own genesis. Provides a CLI to run the client. Handles these operations: eth_blockNumber eth_getTransactionCount eth_getBalance eth_sendTransaction eth_sendRawTransaction eth_estimateGas eth_getBlockTransactionCountByHash eth_getBlockTransactionCountByNumber eth_getTransactionReceipt eth_getCode eth_call Getting started \u00b6 git clone https://github.com/epirus-io/epirus-local && cd epirus-local ./gradlew installDist Run in Linux: build/install/epirus-local/bin/epirus-local [command] Run in Windows build\\install\\epirus-local\\bin\\epirus-local.bat [command] Start the client \u00b6 epirus-local start -d=/path/to/directory -p=9090 This command generates a new genesis file with 10 accounts filled with 100 ether. Load from previous configuration \u00b6 epirus-local load -g=/path/to/genesis This command loads a pre-existing genesis-file from a certain path. Send requests \u00b6 Example of a request curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\":[{ \"from\": \"0x8f496c16955a7bb9b5e1ea0383d01f87372ab520\", \"to\": \"0xd46e8dd67c5d32be8058bb8eb970870f07244567\", \"gas\": \"0x76c0\", \"gasPrice\": \"0x9184e72a000\", \"value\": \"0x9184e72a\", \"nonce\": \"0x1\" }],\"id\":1}' host:port Example of a response {\"id\" : 1, \"jsonrpc\" : \"2.0\", \"result\" : \"0xc631caa67cab48ead77a58321bbb0c76f4060751a4bb3d5b45b99c4a68b1a7b7\"} For more information about the requests, check out the Ethereum json-rpc api.","title":"Run a Node locally"},{"location":"getting_started/run_node_locally/#use-geth-besu-or-openethereum","text":"Geth : $ geth --rpcapi personal,db,eth,net,web3 --rpc --testnet Hyperledger Besu : $ besu ----network = dev The dev network uses has some handy default parameters . OpenEthereum : $ openethereum --chain testnet Instructions on obtaining Ether to transact on the network can be found in the testnet section of the docs .","title":"Use Geth, Besu or OpenEthereum"},{"location":"getting_started/run_node_locally/#use-epirus-local","text":"Epirus-local is a local ethereum client, similar to what Ganache provides, written in Kotlin. This project relies on web3-evm to execute user requests.","title":"Use Epirus Local"},{"location":"getting_started/run_node_locally/#features","text":"Allows json-rpc interactions with a local ethereum blockchain. Generates a default genesis file containing 10 ethereum accounts or lets you use your own genesis. Provides a CLI to run the client. Handles these operations: eth_blockNumber eth_getTransactionCount eth_getBalance eth_sendTransaction eth_sendRawTransaction eth_estimateGas eth_getBlockTransactionCountByHash eth_getBlockTransactionCountByNumber eth_getTransactionReceipt eth_getCode eth_call","title":"Features"},{"location":"getting_started/run_node_locally/#getting-started","text":"git clone https://github.com/epirus-io/epirus-local && cd epirus-local ./gradlew installDist","title":"Getting started"},{"location":"getting_started/run_node_locally/#start-the-client","text":"epirus-local start -d=/path/to/directory -p=9090 This command generates a new genesis file with 10 accounts filled with 100 ether.","title":"Start the client"},{"location":"getting_started/run_node_locally/#load-from-previous-configuration","text":"epirus-local load -g=/path/to/genesis This command loads a pre-existing genesis-file from a certain path.","title":"Load from previous configuration"},{"location":"getting_started/run_node_locally/#send-requests","text":"","title":"Send requests"},{"location":"plugins/solidity_gradle_plugin/","text":"Solidity Gradle Plugin \u00b6 Simple Gradle plugin used by the Web3j plugin to compile Solidity contracts, but it can be used in any standalone project for this purpose. Plugin configuration \u00b6 To configure the Solidity Gradle Plugin using the plugins DSL or the legacy plugin application, check the plugin page . The minimum Gradle version to run the plugin is 5.+ . Then run this command from your project containing Solidity contracts: ./gradlew build After the task execution, the base directory for compiled code (by default $buildDir/resources/solidity ) will contain a directory for each source set (by default main and test ), and each of those a directory with the compiled code. Code generation \u00b6 The solidity DSL allows to configure the generated code, e.g.: solidity { outputComponents = [ BIN , ABI , ASM_JSON ] optimizeRuns = 500 } The properties accepted by the DSL are listed in the following table: Name Type Default value Description executable String null (bundled with the plugin) Solidity compiler path. version String null (defined by contract's pragma) Solidity compiler version. overwrite Boolean true Overwrite existing files. resolvePackages Boolean true Resolve third-party contract packages. optimize Boolean true Enable byte code optimizer. optimizeRuns Integer 200 Set for how many contract runs to optimize. prettyJson Boolean false Output JSON in pretty format. Enables the combined JSON output. ignoreMissing Boolean false Ignore missing files. allowPaths List<String> ['src/main/solidity', 'src/test/solidity', ...] Allow a given path for imports. pathRemappings Map<String,String> [ : ] Remaps contract imports to target path. evmVersion EVMVersion BYZANTIUM Select desired EVM version. outputComponents OutputComponent[] [BIN, ABI] List of output components to produce. combinedOutputComponents CombinedOutputComponent[] [BIN, BIN_RUNTIME, SRCMAP, SRCMAP_RUNTIME] List of output components in combined JSON output. Notes: Setting the executable property will disable the bundled solc and use your local or containerized executable: solidity { executable = \"docker run --rm -v $projectDir/src:/src -v $projectDir/build:/build ethereum/solc:0.6.4-alpine\" version = '0.4.15' } Use version to change the bundled Solidity version. Check the Solidity releases for all available versions. allowPaths contains all project's Solidity source sets by default. Source sets \u00b6 By default, all .sol files in $projectDir/src/main/solidity will be processed by the plugin. To specify and add different source sets, use the sourceSets DSL. You can also set your preferred output directory for compiled code. sourceSets { main { solidity { srcDir { \"my/custom/path/to/solidity\" } output . resourcesDir = file ( 'out/bin/compiledSol' ) } } } Gradle Node Plugin \u00b6 The plugin makes use of the Node plugin to resolve third-party contract dependencies. It currently supports: Open Zeppelin Uniswap When importing libraries from @openzeppeling/contracts in your Solidity contract the plugin will use the task resolveSolidity to generate a package.json file in order to be used by the Node plugin . By default, package.json will be generated under the build/ directory. If you with do define your own package.json you need to add the following snippet in your build.gradle file. node { nodeProjectDir = file(\"my/custom/node/directory\") } The plugin will look for the package.json file in the directory set and will also download the node modules under the same directory. Plugin tasks \u00b6 The Java Plugin adds tasks to your project build using a naming convention on a per source set basis (i.e. compileJava , compileTestJava ). Similarly, the Solidity plugin will add a: resolveSolidity task for all project Solidity sources. compileSolidity task for the project main source set. compile<SourceSet>Solidity for each remaining source set. (e.g. compileTestSolidity for the test source set, etc.). To obtain a list and description of all added tasks, run the command: ./gradlew tasks --all","title":"Solidity Gradle Plugin"},{"location":"plugins/solidity_gradle_plugin/#solidity-gradle-plugin","text":"Simple Gradle plugin used by the Web3j plugin to compile Solidity contracts, but it can be used in any standalone project for this purpose.","title":"Solidity Gradle Plugin"},{"location":"plugins/solidity_gradle_plugin/#plugin-configuration","text":"To configure the Solidity Gradle Plugin using the plugins DSL or the legacy plugin application, check the plugin page . The minimum Gradle version to run the plugin is 5.+ . Then run this command from your project containing Solidity contracts: ./gradlew build After the task execution, the base directory for compiled code (by default $buildDir/resources/solidity ) will contain a directory for each source set (by default main and test ), and each of those a directory with the compiled code.","title":"Plugin configuration"},{"location":"plugins/solidity_gradle_plugin/#code-generation","text":"The solidity DSL allows to configure the generated code, e.g.: solidity { outputComponents = [ BIN , ABI , ASM_JSON ] optimizeRuns = 500 } The properties accepted by the DSL are listed in the following table: Name Type Default value Description executable String null (bundled with the plugin) Solidity compiler path. version String null (defined by contract's pragma) Solidity compiler version. overwrite Boolean true Overwrite existing files. resolvePackages Boolean true Resolve third-party contract packages. optimize Boolean true Enable byte code optimizer. optimizeRuns Integer 200 Set for how many contract runs to optimize. prettyJson Boolean false Output JSON in pretty format. Enables the combined JSON output. ignoreMissing Boolean false Ignore missing files. allowPaths List<String> ['src/main/solidity', 'src/test/solidity', ...] Allow a given path for imports. pathRemappings Map<String,String> [ : ] Remaps contract imports to target path. evmVersion EVMVersion BYZANTIUM Select desired EVM version. outputComponents OutputComponent[] [BIN, ABI] List of output components to produce. combinedOutputComponents CombinedOutputComponent[] [BIN, BIN_RUNTIME, SRCMAP, SRCMAP_RUNTIME] List of output components in combined JSON output. Notes: Setting the executable property will disable the bundled solc and use your local or containerized executable: solidity { executable = \"docker run --rm -v $projectDir/src:/src -v $projectDir/build:/build ethereum/solc:0.6.4-alpine\" version = '0.4.15' } Use version to change the bundled Solidity version. Check the Solidity releases for all available versions. allowPaths contains all project's Solidity source sets by default.","title":"Code generation"},{"location":"plugins/solidity_gradle_plugin/#source-sets","text":"By default, all .sol files in $projectDir/src/main/solidity will be processed by the plugin. To specify and add different source sets, use the sourceSets DSL. You can also set your preferred output directory for compiled code. sourceSets { main { solidity { srcDir { \"my/custom/path/to/solidity\" } output . resourcesDir = file ( 'out/bin/compiledSol' ) } } }","title":"Source sets"},{"location":"plugins/solidity_gradle_plugin/#gradle-node-plugin","text":"The plugin makes use of the Node plugin to resolve third-party contract dependencies. It currently supports: Open Zeppelin Uniswap When importing libraries from @openzeppeling/contracts in your Solidity contract the plugin will use the task resolveSolidity to generate a package.json file in order to be used by the Node plugin . By default, package.json will be generated under the build/ directory. If you with do define your own package.json you need to add the following snippet in your build.gradle file. node { nodeProjectDir = file(\"my/custom/node/directory\") } The plugin will look for the package.json file in the directory set and will also download the node modules under the same directory.","title":"Gradle Node Plugin"},{"location":"plugins/solidity_gradle_plugin/#plugin-tasks","text":"The Java Plugin adds tasks to your project build using a naming convention on a per source set basis (i.e. compileJava , compileTestJava ). Similarly, the Solidity plugin will add a: resolveSolidity task for all project Solidity sources. compileSolidity task for the project main source set. compile<SourceSet>Solidity for each remaining source set. (e.g. compileTestSolidity for the test source set, etc.). To obtain a list and description of all added tasks, run the command: ./gradlew tasks --all","title":"Plugin tasks"},{"location":"plugins/web3j_gradle_plugin/","text":"Web3j Gradle Plugin \u00b6 Gradle plugin that generates Web3j Java wrappers from Solidity smart contracts. It smoothly integrates with your project's build lifecycle by adding specific tasks that can be also run independently. Plugin configuration \u00b6 To configure the Web3j Gradle Plugin using the plugins DSL or the legacy plugin application, check the plugin page . The minimum Gradle version to run the plugin is 5.+ . Then run your project containing Solidity contracts: ./gradlew build After applying the plugin, the base directory for generated code (by default $buildDir/generated/sources/web3j ) will contain a directory for each source set (by default main and test ) containing the smart contract wrappers Java classes. Code generation \u00b6 The web3j DSL allows to configure the generated code, e.g.: web3j { generatedPackageName = 'com.mycompany.{0}' generatedFilesBaseDir = \"$buildDir/custom/destination\" excludedContracts = [ 'Ownable' ] useNativeJavaTypes = false } The properties accepted by the DSL are listed in the following table: Name Type Default value Description generatedPackageName String ${group}.web3j or org.web3j.{0} Generated contract wrappers package. generatedFilesBaseDir String $buildDir/generated/sources/web3j Generated Java code output directory. excludedContracts String[] [] Excluded contract names from wrapper generation. includedContracts String[] [] Included contract names from wrapper generation. Has preference over excludedContracts . useNativeJavaTypes Boolean true Generate smart contract wrappers using native Java types. addressBitLength int 160 Supported address length in bits, by default Ethereum addresses. The generatedPackageName is evaluated as a message format string accepting a single parameter between curly brackets ( {0} ), allowing to format the generated value using the contract name. For convenience, when applied to a Java package name it will be converted to lower case. For instance, a generatedPackageName set to ${group}.{0} in a project with group com.mycompany , a Solidity contract named MyToken.sol will be generated in the package com.mycompany.mytoken . Also, the default value contains the ${group} property, which corresponds to your project artifact group (e.g. com.mycompany ). If the project does not define a group property, the generated package name will be org.web3j.{0} . Note that message format parameters are not Gradle properties and should not be preceded by $ . Source sets \u00b6 By default, all .sol files in $projectDir/src/main/solidity will be processed by the plugin. To specify and add different source sets, use the sourceSets DSL: sourceSets { main { solidity { srcDir { \"my/custom/path/to/solidity\" } } } } Check the Solidity Plugin documentation to configure the smart contracts source code directories. Output directories for generated smart contract wrappers Java code will be added to your build automatically. Plugin tasks \u00b6 The Java Plugin adds tasks to your project build using a naming convention on a per source set basis (i.e. compileJava , compileTestJava ). Similarly, the Solidity plugin will add the generateContractWrappers task for the project main source set, and a generate[SourceSet]ContractWrappers for each remaining source set (e.g. test ). To obtain a list and description of all added tasks, run the command: ./gradlew tasks --all","title":"Web3j Gradle Plugin"},{"location":"plugins/web3j_gradle_plugin/#web3j-gradle-plugin","text":"Gradle plugin that generates Web3j Java wrappers from Solidity smart contracts. It smoothly integrates with your project's build lifecycle by adding specific tasks that can be also run independently.","title":"Web3j Gradle Plugin"},{"location":"plugins/web3j_gradle_plugin/#plugin-configuration","text":"To configure the Web3j Gradle Plugin using the plugins DSL or the legacy plugin application, check the plugin page . The minimum Gradle version to run the plugin is 5.+ . Then run your project containing Solidity contracts: ./gradlew build After applying the plugin, the base directory for generated code (by default $buildDir/generated/sources/web3j ) will contain a directory for each source set (by default main and test ) containing the smart contract wrappers Java classes.","title":"Plugin configuration"},{"location":"plugins/web3j_gradle_plugin/#code-generation","text":"The web3j DSL allows to configure the generated code, e.g.: web3j { generatedPackageName = 'com.mycompany.{0}' generatedFilesBaseDir = \"$buildDir/custom/destination\" excludedContracts = [ 'Ownable' ] useNativeJavaTypes = false } The properties accepted by the DSL are listed in the following table: Name Type Default value Description generatedPackageName String ${group}.web3j or org.web3j.{0} Generated contract wrappers package. generatedFilesBaseDir String $buildDir/generated/sources/web3j Generated Java code output directory. excludedContracts String[] [] Excluded contract names from wrapper generation. includedContracts String[] [] Included contract names from wrapper generation. Has preference over excludedContracts . useNativeJavaTypes Boolean true Generate smart contract wrappers using native Java types. addressBitLength int 160 Supported address length in bits, by default Ethereum addresses. The generatedPackageName is evaluated as a message format string accepting a single parameter between curly brackets ( {0} ), allowing to format the generated value using the contract name. For convenience, when applied to a Java package name it will be converted to lower case. For instance, a generatedPackageName set to ${group}.{0} in a project with group com.mycompany , a Solidity contract named MyToken.sol will be generated in the package com.mycompany.mytoken . Also, the default value contains the ${group} property, which corresponds to your project artifact group (e.g. com.mycompany ). If the project does not define a group property, the generated package name will be org.web3j.{0} . Note that message format parameters are not Gradle properties and should not be preceded by $ .","title":"Code generation"},{"location":"plugins/web3j_gradle_plugin/#source-sets","text":"By default, all .sol files in $projectDir/src/main/solidity will be processed by the plugin. To specify and add different source sets, use the sourceSets DSL: sourceSets { main { solidity { srcDir { \"my/custom/path/to/solidity\" } } } } Check the Solidity Plugin documentation to configure the smart contracts source code directories. Output directories for generated smart contract wrappers Java code will be added to your build automatically.","title":"Source sets"},{"location":"plugins/web3j_gradle_plugin/#plugin-tasks","text":"The Java Plugin adds tasks to your project build using a naming convention on a per source set basis (i.e. compileJava , compileTestJava ). Similarly, the Solidity plugin will add the generateContractWrappers task for the project main source set, and a generate[SourceSet]ContractWrappers for each remaining source set (e.g. test ). To obtain a list and description of all added tasks, run the command: ./gradlew tasks --all","title":"Plugin tasks"},{"location":"plugins/web3j_maven_plugin/","text":"Web3j-maven-plugin \u00b6 Web3j maven plugin is used to create java classes based on the solidity contract files. Usage \u00b6 The base configuration for the plugin will take the solidity files from src/main/resources and generates the java classes into the folder src/main/java . <build> <plugins> <plugin> <groupId> org.web3j </groupId> <artifactId> web3j-maven-plugin </artifactId> <version> 4.8.1 </version> <configuration> <soliditySourceFiles/> </configuration> </plugin> </plugins> </build> to run the plugin execute the goal generate-sources mvn web3j:generate-sources Configuration \u00b6 The are several variable to select the solidity source files, define a source destination path or change the package name. Name Format Default value <packageName/> valid java package name org.web3j.model <outputDirectory><java/></outputDirectory> relative or absolute path of the generated for 'Java files value in <sourceDestination/> <outputDirectory><bin/></outputDirectory> relative or absolute path of the generated for 'Bin' files value in <sourceDestination/> <outputDirectory><abi/></outputDirectory> relative or absolute path of the generated for 'ABI' files value in <sourceDestination/> <sourceDestination/> relative or absolute path of the generated files (java, bin, abi) src/main/java <outputFormat/> generate Java Classes( java ), ABI( abi ) and/or BIN ( bin ) Files (comma separated) java <nativeJavaType/> Creates Java Native Types (instead of Solidity Types) true <soliditySourceFiles> Standard maven fileset <soliditySourceFiles> <directory>src/main/resources</directory> <includes> <include>**/*.sol</include> </includes> </soliditySourceFiles> <contract> Filter ( <include> or <exclude> ) contracts based on the name. <contract> <includes> <include>greeter</include> </includes> <excludes> <exclude>mortal</exclude> <excludes> </contracts> <pathPrefixes> A list ( <pathPrefixe> ) of replacements of dependency replacements inside Solidity contract. Configuration of outputDirectory has priority over sourceDestination Getting Started \u00b6 Create a standard java maven project. Add following <plugin> - configuration into the pom.xml file: <plugin> <groupId> org.web3j </groupId> <artifactId> web3j-maven-plugin </artifactId> <version> 4.5.11 </version> <configuration> <packageName> com.zuehlke.blockchain.model </packageName> <sourceDestination> src/main/java/generated </sourceDestination> <nativeJavaType> true </nativeJavaType> <outputFormat> java,bin </outputFormat> <soliditySourceFiles> <directory> src/main/resources </directory> <includes> <include> **/*.sol </include> </includes> </soliditySourceFiles> <outputDirectory> <java> src/java/generated </java> <bin> src/bin/generated </bin> <abi> src/abi/generated </abi> </outputDirectory> <contract> <includes> <include> greeter </include> </includes> <excludes> <exclude> mortal </exclude> </excludes> </contract> <pathPrefixes> <pathPrefix> dep=../dependencies </pathPrefix> </pathPrefixes> </configuration> </plugin> Add your solidity contract files into the folder src/main/resources . Make sure that the solidity files ends with .sol . Start the generating process: > mvn web3j:generate-sources [INFO] --- web3j-maven-plugin:0.1.2:generate-sources (default-cli) @ hotel-showcase --- [INFO] process 'HotelShowCaseProxy.sol' [INFO] Built Class for contract 'HotelShowCaseProxy' [INFO] Built Class for contract 'HotelShowCaseV2' [INFO] Built Class for contract 'Owned' [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 4.681 s [INFO] Finished at: 2017-06-13T07:07:04+02:00 [INFO] Final Memory: 14M/187M [INFO] ------------------------------------------------------------------------ Process finished with exit code 0 You find the generated java classes inside the directory src/main/java/generated/ . Next step is to interact with the smart contract. See for that deploying and interacting with smart contracts in the official web3j documentation. For a multi module project configuration see following post from @fcorneli . In short: For pick up the generated java source files, you need the build-helper-maven-plugin configuration. Also, ${basedir} prefix is required within a multi-module project.","title":"Web3j Maven Plugin"},{"location":"plugins/web3j_maven_plugin/#web3j-maven-plugin","text":"Web3j maven plugin is used to create java classes based on the solidity contract files.","title":"Web3j-maven-plugin"},{"location":"plugins/web3j_maven_plugin/#usage","text":"The base configuration for the plugin will take the solidity files from src/main/resources and generates the java classes into the folder src/main/java . <build> <plugins> <plugin> <groupId> org.web3j </groupId> <artifactId> web3j-maven-plugin </artifactId> <version> 4.8.1 </version> <configuration> <soliditySourceFiles/> </configuration> </plugin> </plugins> </build> to run the plugin execute the goal generate-sources mvn web3j:generate-sources","title":"Usage"},{"location":"plugins/web3j_maven_plugin/#configuration","text":"The are several variable to select the solidity source files, define a source destination path or change the package name. Name Format Default value <packageName/> valid java package name org.web3j.model <outputDirectory><java/></outputDirectory> relative or absolute path of the generated for 'Java files value in <sourceDestination/> <outputDirectory><bin/></outputDirectory> relative or absolute path of the generated for 'Bin' files value in <sourceDestination/> <outputDirectory><abi/></outputDirectory> relative or absolute path of the generated for 'ABI' files value in <sourceDestination/> <sourceDestination/> relative or absolute path of the generated files (java, bin, abi) src/main/java <outputFormat/> generate Java Classes( java ), ABI( abi ) and/or BIN ( bin ) Files (comma separated) java <nativeJavaType/> Creates Java Native Types (instead of Solidity Types) true <soliditySourceFiles> Standard maven fileset <soliditySourceFiles> <directory>src/main/resources</directory> <includes> <include>**/*.sol</include> </includes> </soliditySourceFiles> <contract> Filter ( <include> or <exclude> ) contracts based on the name. <contract> <includes> <include>greeter</include> </includes> <excludes> <exclude>mortal</exclude> <excludes> </contracts> <pathPrefixes> A list ( <pathPrefixe> ) of replacements of dependency replacements inside Solidity contract. Configuration of outputDirectory has priority over sourceDestination","title":"Configuration"},{"location":"plugins/web3j_maven_plugin/#getting-started","text":"Create a standard java maven project. Add following <plugin> - configuration into the pom.xml file: <plugin> <groupId> org.web3j </groupId> <artifactId> web3j-maven-plugin </artifactId> <version> 4.5.11 </version> <configuration> <packageName> com.zuehlke.blockchain.model </packageName> <sourceDestination> src/main/java/generated </sourceDestination> <nativeJavaType> true </nativeJavaType> <outputFormat> java,bin </outputFormat> <soliditySourceFiles> <directory> src/main/resources </directory> <includes> <include> **/*.sol </include> </includes> </soliditySourceFiles> <outputDirectory> <java> src/java/generated </java> <bin> src/bin/generated </bin> <abi> src/abi/generated </abi> </outputDirectory> <contract> <includes> <include> greeter </include> </includes> <excludes> <exclude> mortal </exclude> </excludes> </contract> <pathPrefixes> <pathPrefix> dep=../dependencies </pathPrefix> </pathPrefixes> </configuration> </plugin> Add your solidity contract files into the folder src/main/resources . Make sure that the solidity files ends with .sol . Start the generating process: > mvn web3j:generate-sources [INFO] --- web3j-maven-plugin:0.1.2:generate-sources (default-cli) @ hotel-showcase --- [INFO] process 'HotelShowCaseProxy.sol' [INFO] Built Class for contract 'HotelShowCaseProxy' [INFO] Built Class for contract 'HotelShowCaseV2' [INFO] Built Class for contract 'Owned' [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 4.681 s [INFO] Finished at: 2017-06-13T07:07:04+02:00 [INFO] Final Memory: 14M/187M [INFO] ------------------------------------------------------------------------ Process finished with exit code 0 You find the generated java classes inside the directory src/main/java/generated/ . Next step is to interact with the smart contract. See for that deploying and interacting with smart contracts in the official web3j documentation. For a multi module project configuration see following post from @fcorneli . In short: For pick up the generated java source files, you need the build-helper-maven-plugin configuration. Also, ${basedir} prefix is required within a multi-module project.","title":"Getting Started"},{"location":"privacy/besu_quickstart/","text":"Besu Quickstart \u00b6 In order to get off the group quickly with Web3j and privacy on Besu, Besu Quickstart should be used. Besu quickstart is a collection of dockerfiles and associated configuration files which allows you to start up a local private-transaction-enabled Ethereum network. In order to get started, ensure you have Docker and Docker Compose installed on your system. Then clone the Besu Quickstart repository likeso: git clone https://github.com/PegaSysEng/besu-quickstart.git In order to start an Ethereum network with privacy enabled, invoke the run-privacy.sh shell script. This should result in a number of containers being started, including 3 Besu nodes which will communicate using the ports localhost:20000-20004 . It should be noted that starting the full network generally uses 12GB+ of RAM. Once the network has been started, the output of the netstat command should indicate that ports 20000-20004 are in use.","title":"Besu Quickstart"},{"location":"privacy/besu_quickstart/#besu-quickstart","text":"In order to get off the group quickly with Web3j and privacy on Besu, Besu Quickstart should be used. Besu quickstart is a collection of dockerfiles and associated configuration files which allows you to start up a local private-transaction-enabled Ethereum network. In order to get started, ensure you have Docker and Docker Compose installed on your system. Then clone the Besu Quickstart repository likeso: git clone https://github.com/PegaSysEng/besu-quickstart.git In order to start an Ethereum network with privacy enabled, invoke the run-privacy.sh shell script. This should result in a number of containers being started, including 3 Besu nodes which will communicate using the ports localhost:20000-20004 . It should be noted that starting the full network generally uses 12GB+ of RAM. Once the network has been started, the output of the netstat command should indicate that ports 20000-20004 are in use.","title":"Besu Quickstart"},{"location":"privacy/privacy_support_web3j/","text":"Privacy Support in Web3j \u00b6 As mentioned earlier, the Besu module in Web3j can be used to create privacy groups and send private transactions in Besu. The Besu privacy quickstart starts up three nodes with their associated Orion instances, which will henceforth be called Alice, Bob and Charlie for ease of use. The keys associated with each are predetermined, and can be represented in Java as follows: private static final Credentials ALICE = Credentials . create ( \"8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\" ); private static final Credentials BOB = Credentials . create ( \"c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3\" ); private static final Credentials CHARLIE = Credentials . create ( \"ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f\" ); private static final Base64String ENCLAVE_KEY_ALICE = Base64String . wrap ( \"A1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\" ); private static final Base64String ENCLAVE_KEY_BOB = Base64String . wrap ( \"Ko2bVqD+nNlNYL5EE7y3IdOnviftjiizpjRt+HTuFBs=\" ); private static final Base64String ENCLAVE_KEY_CHARLIE = Base64String . wrap ( \"k2zXEin4Ip/qBGlRkJejnGWdP9cjkK+DAvKNW31L2C8=\" ); The instances of the class Credentials above are the private keys associated with the default account of each Besu node in the network. These are configured in the config files for Besu in the privacy quickstart. The Base64Strings are the Orion keys associated with each member, and are configured in the config files for Orion in the privacy quickstart. If you choose to create your own network, these values will differ from the defaults as specified in the privacy quickstart. Web3j provides the class org.web3j.protocol.besu.Besu which encapsulates all Besu specific methods with all of the usual Web3j commands. We can use several instances of these to talk to the running quickstart instance: private static Besu nodeAlice = Besu . build ( new HttpService ( \"http://localhost:20000\" )); private static Besu nodeBob = Besu . build ( new HttpService ( \"http://localhost:20002\" )); private static Besu nodeCharlie = Besu . build ( new HttpService ( \"http://localhost:20004\" )); private static PollingPrivateTransactionReceiptProcessor processor = new PollingPrivateTransactionReceiptProcessor ( nodeAlice , 1000 , 15 ); Creating a privacy group \u00b6 In order to create a new privacy group, first a random 32 byte base64 string is generated to form the group ID. Then the create group function is called, and we wait for the transaction receipt to be returned. Finally, we can call the privOnChainFindPrivacyGroup method, which will find the privacy group which was just created by using the two Orion keys of the group members. // Generate a new random Base64 string for the privacy group ID Base64String privacyGroupId = Base64String . wrap ( generateRandomBytes ( 32 )); // Create the privacy group final String txHash = nodeAlice . privOnChainCreatePrivacyGroup ( privacyGroupId , ALICE , ENCLAVE_KEY_ALICE , Collections . singletonList ( ENCLAVE_KEY_BOB )) . send () . getTransactionHash (); // Wait for the transaction to be mined & get the receipt TransactionReceipt receipt = processor . waitForTransactionReceipt ( txHash ); // Find the privacy group based on the two members Optional < PrivacyGroup > group = nodeAlice . privOnChainFindPrivacyGroup ( Arrays . asList ( ENCLAVE_KEY_ALICE , ENCLAVE_KEY_BOB )) . send () . getGroups (). stream (). filter ( x -> x . getPrivacyGroupId (). equals ( privacyGroupId )). findFirst (); Adding & removing members \u00b6 After a privacy group has been created, users can be added to the group using the privOnChainAddToPrivacyGroup method, and removed from the group using the privOnChainRemoveFromPrivacyGroup method. Base64String privacyGroupId = Base64String . wrap ( generateRandomBytes ( 32 )); final String createTxHash = nodeAlice . privOnChainCreatePrivacyGroup ( privacyGroupId , ALICE , ENCLAVE_KEY_ALICE , Collections . singletonList ( ENCLAVE_KEY_BOB )) . send () . getTransactionHash (); TransactionReceipt createReceipt = processor . waitForTransactionReceipt ( createTxHash ); // Once the group has been created, add Charlie from Alice's node final String addTxHash = nodeAlice . privOnChainAddToPrivacyGroup ( privacyGroupId , ALICE , ENCLAVE_KEY_ALICE , Collections . singletonList ( ENCLAVE_KEY_CHARLIE )) . send () . getTransactionHash (); TransactionReceipt addReceipt = processor . waitForTransactionReceipt ( addTxHash ); // Once the add transaction has been mined, find the privacy group which contains Alice, Bob & Charlie List < PrivacyGroup > groups = nodeAlice . privOnChainFindPrivacyGroup ( Arrays . asList ( ENCLAVE_KEY_ALICE , ENCLAVE_KEY_BOB , ENCLAVE_KEY_CHARLIE )) . send () . getGroups (); // Remove Charlie from the privacy group final String removeTxHash = nodeAlice . privOnChainRemoveFromPrivacyGroup ( privacyGroupId , ALICE , ENCLAVE_KEY_ALICE , ENCLAVE_KEY_CHARLIE ) . send () . getTransactionHash (); TransactionReceipt removeReceipt = processor . waitForTransactionReceipt ( removeTxHash ); // Get the privacy group with only Alice and Bob now in it. List < PrivacyGroup > removedGroups = nodeAlice . privOnChainFindPrivacyGroup ( Arrays . asList ( ENCLAVE_KEY_ALICE , ENCLAVE_KEY_BOB )) . send () . getGroups (); Creating & interacting with a smart contract \u00b6 Once a privacy group has been created, smart contracts can be created & executed within the privacy group. The state of the contract and all of the associated transactions will only be viewable to those within the privacy group. In this example, an instance of a HumanStandardToken is deployed within the group, and is visible to each member: // Create a new privacy group Base64String aliceBobGroup = Base64String . wrap ( generateRandomBytes ( 32 )); final String createTxHash = nodeAlice . privOnChainCreatePrivacyGroup ( aliceBobGroup , ALICE , ENCLAVE_KEY_ALICE , Collections . singletonList ( ENCLAVE_KEY_BOB )) . send () . getTransactionHash (); TransactionReceipt createReceipt = processor . waitForTransactionReceipt ( createTxHash ); // Find the privacy group that was built by Alice from Bob's node final Base64String aliceBobGroupFromBobNode = nodeBob . privOnChainFindPrivacyGroup ( Arrays . asList ( ENCLAVE_KEY_ALICE , ENCLAVE_KEY_BOB )) . send (). getGroups (). stream () . filter ( g -> g . getPrivacyGroupId (). equals ( aliceBobGroup )) . findFirst () . orElseThrow ( RuntimeException :: new ) . getPrivacyGroupId (); // Create two private transaction manager instances for Alice and Bob in order to interact with smart contracts final PrivateTransactionManager tmAlice = new BesuPrivateTransactionManager ( nodeAlice , ZERO_GAS_PROVIDER , ALICE , 2018 , ENCLAVE_KEY_ALICE , aliceBobGroup ); final PrivateTransactionManager tmBob = new BesuPrivateTransactionManager ( nodeBob , ZERO_GAS_PROVIDER , BOB , 2018 , ENCLAVE_KEY_BOB , aliceBobGroupFromBobNode ); // Deploy the token from Alice's node final HumanStandardToken tokenAlice = HumanStandardToken . deploy ( nodeAlice , tmAlice , ZERO_GAS_PROVIDER , BigInteger . TEN , \"eea_token\" , BigInteger . TEN , \"EEATKN\" ) . send (); // Get an instance of the token from Bob's node final HumanStandardToken tokenBob = HumanStandardToken . load ( tokenAlice . getContractAddress (), nodeBob , tmBob , ZERO_GAS_PROVIDER );","title":"Privacy Support in Web3j"},{"location":"privacy/privacy_support_web3j/#privacy-support-in-web3j","text":"As mentioned earlier, the Besu module in Web3j can be used to create privacy groups and send private transactions in Besu. The Besu privacy quickstart starts up three nodes with their associated Orion instances, which will henceforth be called Alice, Bob and Charlie for ease of use. The keys associated with each are predetermined, and can be represented in Java as follows: private static final Credentials ALICE = Credentials . create ( \"8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\" ); private static final Credentials BOB = Credentials . create ( \"c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3\" ); private static final Credentials CHARLIE = Credentials . create ( \"ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f\" ); private static final Base64String ENCLAVE_KEY_ALICE = Base64String . wrap ( \"A1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\" ); private static final Base64String ENCLAVE_KEY_BOB = Base64String . wrap ( \"Ko2bVqD+nNlNYL5EE7y3IdOnviftjiizpjRt+HTuFBs=\" ); private static final Base64String ENCLAVE_KEY_CHARLIE = Base64String . wrap ( \"k2zXEin4Ip/qBGlRkJejnGWdP9cjkK+DAvKNW31L2C8=\" ); The instances of the class Credentials above are the private keys associated with the default account of each Besu node in the network. These are configured in the config files for Besu in the privacy quickstart. The Base64Strings are the Orion keys associated with each member, and are configured in the config files for Orion in the privacy quickstart. If you choose to create your own network, these values will differ from the defaults as specified in the privacy quickstart. Web3j provides the class org.web3j.protocol.besu.Besu which encapsulates all Besu specific methods with all of the usual Web3j commands. We can use several instances of these to talk to the running quickstart instance: private static Besu nodeAlice = Besu . build ( new HttpService ( \"http://localhost:20000\" )); private static Besu nodeBob = Besu . build ( new HttpService ( \"http://localhost:20002\" )); private static Besu nodeCharlie = Besu . build ( new HttpService ( \"http://localhost:20004\" )); private static PollingPrivateTransactionReceiptProcessor processor = new PollingPrivateTransactionReceiptProcessor ( nodeAlice , 1000 , 15 );","title":"Privacy Support in Web3j"},{"location":"privacy/privacy_support_web3j/#creating-a-privacy-group","text":"In order to create a new privacy group, first a random 32 byte base64 string is generated to form the group ID. Then the create group function is called, and we wait for the transaction receipt to be returned. Finally, we can call the privOnChainFindPrivacyGroup method, which will find the privacy group which was just created by using the two Orion keys of the group members. // Generate a new random Base64 string for the privacy group ID Base64String privacyGroupId = Base64String . wrap ( generateRandomBytes ( 32 )); // Create the privacy group final String txHash = nodeAlice . privOnChainCreatePrivacyGroup ( privacyGroupId , ALICE , ENCLAVE_KEY_ALICE , Collections . singletonList ( ENCLAVE_KEY_BOB )) . send () . getTransactionHash (); // Wait for the transaction to be mined & get the receipt TransactionReceipt receipt = processor . waitForTransactionReceipt ( txHash ); // Find the privacy group based on the two members Optional < PrivacyGroup > group = nodeAlice . privOnChainFindPrivacyGroup ( Arrays . asList ( ENCLAVE_KEY_ALICE , ENCLAVE_KEY_BOB )) . send () . getGroups (). stream (). filter ( x -> x . getPrivacyGroupId (). equals ( privacyGroupId )). findFirst ();","title":"Creating a privacy group"},{"location":"privacy/privacy_support_web3j/#adding-removing-members","text":"After a privacy group has been created, users can be added to the group using the privOnChainAddToPrivacyGroup method, and removed from the group using the privOnChainRemoveFromPrivacyGroup method. Base64String privacyGroupId = Base64String . wrap ( generateRandomBytes ( 32 )); final String createTxHash = nodeAlice . privOnChainCreatePrivacyGroup ( privacyGroupId , ALICE , ENCLAVE_KEY_ALICE , Collections . singletonList ( ENCLAVE_KEY_BOB )) . send () . getTransactionHash (); TransactionReceipt createReceipt = processor . waitForTransactionReceipt ( createTxHash ); // Once the group has been created, add Charlie from Alice's node final String addTxHash = nodeAlice . privOnChainAddToPrivacyGroup ( privacyGroupId , ALICE , ENCLAVE_KEY_ALICE , Collections . singletonList ( ENCLAVE_KEY_CHARLIE )) . send () . getTransactionHash (); TransactionReceipt addReceipt = processor . waitForTransactionReceipt ( addTxHash ); // Once the add transaction has been mined, find the privacy group which contains Alice, Bob & Charlie List < PrivacyGroup > groups = nodeAlice . privOnChainFindPrivacyGroup ( Arrays . asList ( ENCLAVE_KEY_ALICE , ENCLAVE_KEY_BOB , ENCLAVE_KEY_CHARLIE )) . send () . getGroups (); // Remove Charlie from the privacy group final String removeTxHash = nodeAlice . privOnChainRemoveFromPrivacyGroup ( privacyGroupId , ALICE , ENCLAVE_KEY_ALICE , ENCLAVE_KEY_CHARLIE ) . send () . getTransactionHash (); TransactionReceipt removeReceipt = processor . waitForTransactionReceipt ( removeTxHash ); // Get the privacy group with only Alice and Bob now in it. List < PrivacyGroup > removedGroups = nodeAlice . privOnChainFindPrivacyGroup ( Arrays . asList ( ENCLAVE_KEY_ALICE , ENCLAVE_KEY_BOB )) . send () . getGroups ();","title":"Adding &amp; removing members"},{"location":"privacy/privacy_support_web3j/#creating-interacting-with-a-smart-contract","text":"Once a privacy group has been created, smart contracts can be created & executed within the privacy group. The state of the contract and all of the associated transactions will only be viewable to those within the privacy group. In this example, an instance of a HumanStandardToken is deployed within the group, and is visible to each member: // Create a new privacy group Base64String aliceBobGroup = Base64String . wrap ( generateRandomBytes ( 32 )); final String createTxHash = nodeAlice . privOnChainCreatePrivacyGroup ( aliceBobGroup , ALICE , ENCLAVE_KEY_ALICE , Collections . singletonList ( ENCLAVE_KEY_BOB )) . send () . getTransactionHash (); TransactionReceipt createReceipt = processor . waitForTransactionReceipt ( createTxHash ); // Find the privacy group that was built by Alice from Bob's node final Base64String aliceBobGroupFromBobNode = nodeBob . privOnChainFindPrivacyGroup ( Arrays . asList ( ENCLAVE_KEY_ALICE , ENCLAVE_KEY_BOB )) . send (). getGroups (). stream () . filter ( g -> g . getPrivacyGroupId (). equals ( aliceBobGroup )) . findFirst () . orElseThrow ( RuntimeException :: new ) . getPrivacyGroupId (); // Create two private transaction manager instances for Alice and Bob in order to interact with smart contracts final PrivateTransactionManager tmAlice = new BesuPrivateTransactionManager ( nodeAlice , ZERO_GAS_PROVIDER , ALICE , 2018 , ENCLAVE_KEY_ALICE , aliceBobGroup ); final PrivateTransactionManager tmBob = new BesuPrivateTransactionManager ( nodeBob , ZERO_GAS_PROVIDER , BOB , 2018 , ENCLAVE_KEY_BOB , aliceBobGroupFromBobNode ); // Deploy the token from Alice's node final HumanStandardToken tokenAlice = HumanStandardToken . deploy ( nodeAlice , tmAlice , ZERO_GAS_PROVIDER , BigInteger . TEN , \"eea_token\" , BigInteger . TEN , \"EEATKN\" ) . send (); // Get an instance of the token from Bob's node final HumanStandardToken tokenBob = HumanStandardToken . load ( tokenAlice . getContractAddress (), nodeBob , tmBob , ZERO_GAS_PROVIDER );","title":"Creating &amp; interacting with a smart contract"},{"location":"privacy/privacy_with_besu/","text":"Privacy with Hyperledger Besu \u00b6 The Besu module in Web3j provides support for creating private transactions and privacy groups on Hyperledger Besu. For information as to how privacy is implemented in Besu, please see the Besu privacy documentation . Privacy in Besu refers to the ability to keep transactions private between the involved participants. Other participants cannot access the transaction content or list of participants. Besu uses Orion, a separate software component, to manage private transactions. Orion is able to maintain public/private keypair, store privacy group details, and discover other Orion nodes on a network. A privacy group is a group of nodes identified by a unique privacy group ID in Orion. Each private transaction is stored in Orion and is associated with the privacy group ID. The Besu nodes maintain the public world state for the blockchain and a private state for each privacy group. The private states contain data that is not shared in the globally replicated public world state. Private transactions have additional attributes to public Ethereum transactions: privateFrom - Orion public key of transaction sender privacyGroupId - Privacy group to receive transaction restriction - Private transactions are restricted or unrestricted: In restricted private transactions the payload of the private transaction is received and stored only by the nodes participating in the transaction. In unrestricted private transactions the payload of the private transaction is transmitted to all nodes in the network but is readable only by nodes participating in the transaction.","title":"Privacy with Hyperledger Besu"},{"location":"privacy/privacy_with_besu/#privacy-with-hyperledger-besu","text":"The Besu module in Web3j provides support for creating private transactions and privacy groups on Hyperledger Besu. For information as to how privacy is implemented in Besu, please see the Besu privacy documentation . Privacy in Besu refers to the ability to keep transactions private between the involved participants. Other participants cannot access the transaction content or list of participants. Besu uses Orion, a separate software component, to manage private transactions. Orion is able to maintain public/private keypair, store privacy group details, and discover other Orion nodes on a network. A privacy group is a group of nodes identified by a unique privacy group ID in Orion. Each private transaction is stored in Orion and is associated with the privacy group ID. The Besu nodes maintain the public world state for the blockchain and a private state for each privacy group. The private states contain data that is not shared in the globally replicated public world state. Private transactions have additional attributes to public Ethereum transactions: privateFrom - Orion public key of transaction sender privacyGroupId - Privacy group to receive transaction restriction - Private transactions are restricted or unrestricted: In restricted private transactions the payload of the private transaction is received and stored only by the nodes participating in the transaction. In unrestricted private transactions the payload of the private transaction is transmitted to all nodes in the network but is readable only by nodes participating in the transaction.","title":"Privacy with Hyperledger Besu"},{"location":"references/companies_using_web3j/","text":"Companies using Web3j \u00b6 Amberdata Web3Labs comitFS ConsenSys ING Othera Pactum TrustWallet Impetus Argent Labs Alpha Wallet Lab10 Collective BinarApps PegaSys Arkane FreightTrust Othera","title":"Companies using Web3j"},{"location":"references/companies_using_web3j/#companies-using-web3j","text":"Amberdata Web3Labs comitFS ConsenSys ING Othera Pactum TrustWallet Impetus Argent Labs Alpha Wallet Lab10 Collective BinarApps PegaSys Arkane FreightTrust Othera","title":"Companies using Web3j"},{"location":"references/developer_guide/","text":"Developer Guide \u00b6 Dependency management \u00b6 We recommend you use formal releases of web3j, these can be found on most public maven repositories . Release versions follow the <major>.<minor>.<build> convention, for example: 4.2.0 Snapshot versions of web3j follow the . . -SNAPSHOT` convention, for example: 4.2.0-SNAPSHOT. If you would like to use snapshots instead please add a new maven repository pointing to: https://oss.sonatype.org/content/repositories/snapshots Please refer to the Maven or Gradle documentation for further detail. Sample gradle configuration: repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } } Sample maven configuration: <repositories> <repository> <id> sonatype-snasphots </id> <name> Sonatype snapshots repo </name> <url> https://oss.sonatype.org/content/repositories/snapshots </url> </repository> </repositories> Building web3j \u00b6 web3j includes integration tests for running against a live Ethereum client. If you do not have a client running, you can exclude their execution as per the below instructions. To run a full build (excluding integration tests): $ ./gradlew check To run the integration tests: $ ./gradlew -Pintegration-tests = true :integration-tests:test Generating documentation \u00b6 web3j uses the Sphinx documentation generator. All documentation (apart from the project README.md) resides under the /docs directory. To build a copy of the documentation, from the project root: $ cd docs $ make clean html Then browse the build documentation via: $ open build/html/index.html","title":"Developer Guide"},{"location":"references/developer_guide/#developer-guide","text":"","title":"Developer Guide"},{"location":"references/developer_guide/#dependency-management","text":"We recommend you use formal releases of web3j, these can be found on most public maven repositories . Release versions follow the <major>.<minor>.<build> convention, for example: 4.2.0 Snapshot versions of web3j follow the . . -SNAPSHOT` convention, for example: 4.2.0-SNAPSHOT. If you would like to use snapshots instead please add a new maven repository pointing to: https://oss.sonatype.org/content/repositories/snapshots Please refer to the Maven or Gradle documentation for further detail. Sample gradle configuration: repositories { maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" } } Sample maven configuration: <repositories> <repository> <id> sonatype-snasphots </id> <name> Sonatype snapshots repo </name> <url> https://oss.sonatype.org/content/repositories/snapshots </url> </repository> </repositories>","title":"Dependency management"},{"location":"references/developer_guide/#building-web3j","text":"web3j includes integration tests for running against a live Ethereum client. If you do not have a client running, you can exclude their execution as per the below instructions. To run a full build (excluding integration tests): $ ./gradlew check To run the integration tests: $ ./gradlew -Pintegration-tests = true :integration-tests:test","title":"Building web3j"},{"location":"references/developer_guide/#generating-documentation","text":"web3j uses the Sphinx documentation generator. All documentation (apart from the project README.md) resides under the /docs directory. To build a copy of the documentation, from the project root: $ cd docs $ make clean html Then browse the build documentation via: $ open build/html/index.html","title":"Generating documentation"},{"location":"references/links_and_useful_resources/","text":"Links and Useful Resources \u00b6 Ethereum Homestead Documentation Ethereum Wiki Ethereum JSON-RPC specification Ethereum Yellow Paper on the GitHub repository Solidity docs Layout of variables in storage Ethereum tests contains lots of common tests for clients Etherscan is very useful for exploring blocks and transactions. Ethstats provides a useful network dashboard. There is also a dedicated Rinkeby testnet dashboard . Ethereum reddit","title":"Links and Useful Resources"},{"location":"references/links_and_useful_resources/#links-and-useful-resources","text":"Ethereum Homestead Documentation Ethereum Wiki Ethereum JSON-RPC specification Ethereum Yellow Paper on the GitHub repository Solidity docs Layout of variables in storage Ethereum tests contains lots of common tests for clients Etherscan is very useful for exploring blocks and transactions. Ethstats provides a useful network dashboard. There is also a dedicated Rinkeby testnet dashboard . Ethereum reddit","title":"Links and Useful Resources"},{"location":"references/projects_using_web3j/","text":"Projects using Web3j \u00b6 AlphaWallet Android Wallet Minerva Digital Wallet ERC-20 RESTful Service Trust Ethereum Wallet Presto Ethereum Ethereum JDBC Connector by @impetus-opensource Kundera-Ethereum data importer and sync utility by @impetus-opensource Ethereum Tool for secure offline key management. Ethereum Java EE JCA Resource Adapter Provides integration of Ethereum within Java EE 6+. Etherlinker for UE4 Interact with Ethereum blockchain from Unreal Engine 4. Ethereum ingest utility Import and stream blocks/transactions into Hazelcast, Elasticsearch and MongoDB. EtherWallet by @vikulin Apache Camel Ethereum Component by @bibryam eth-contract-api by @adridadou Ethereum Paper Wallet by @matthiaszimmermann web3j-scala by @mslinn","title":"Projects using Web3j"},{"location":"references/projects_using_web3j/#projects-using-web3j","text":"AlphaWallet Android Wallet Minerva Digital Wallet ERC-20 RESTful Service Trust Ethereum Wallet Presto Ethereum Ethereum JDBC Connector by @impetus-opensource Kundera-Ethereum data importer and sync utility by @impetus-opensource Ethereum Tool for secure offline key management. Ethereum Java EE JCA Resource Adapter Provides integration of Ethereum within Java EE 6+. Etherlinker for UE4 Interact with Ethereum blockchain from Unreal Engine 4. Ethereum ingest utility Import and stream blocks/transactions into Hazelcast, Elasticsearch and MongoDB. EtherWallet by @vikulin Apache Camel Ethereum Component by @bibryam eth-contract-api by @adridadou Ethereum Paper Wallet by @matthiaszimmermann web3j-scala by @mslinn","title":"Projects using Web3j"},{"location":"references/thanks_and_credits/","text":"Thanks and Credits \u00b6 The Nethereum project for the inspiration Othera for the great things they are building on the platform Finhaus guys for putting me onto Nethereum bitcoinj for the reference Elliptic Curve crypto implementation Everyone involved in the Ethererum project and its surrounding ecosystem And of course the users of the library, who've provided valuable input & feedback","title":"Thanks and Credits"},{"location":"references/thanks_and_credits/#thanks-and-credits","text":"The Nethereum project for the inspiration Othera for the great things they are building on the platform Finhaus guys for putting me onto Nethereum bitcoinj for the reference Elliptic Curve crypto implementation Everyone involved in the Ethererum project and its surrounding ecosystem And of course the users of the library, who've provided valuable input & feedback","title":"Thanks and Credits"},{"location":"references/troubleshooting/","text":"Troubleshooting \u00b6 Do you have a sample web3j project \u00b6 Yes, refer to the web3j sample project outlined in the Quickstart . I'm submitting a transaction, but it's not being mined \u00b6 After creating and sending a transaction, you receive a transaction hash, however calling eth_getTransactionReceipt always returns a blank value, indicating the transaction has not been mined: String transactionHash = sendTransaction (...); // you loop through the following expecting to eventually get a receipt once the transaction // is mined EthGetTransactionReceipt . TransactionReceipt transactionReceipt = web3j . ethGetTransactionReceipt ( transactionHash ). sendAsync (). get (); if ( ! transactionReceipt . isPresent ()) { // try again, ad infinitum } However, you never receive a transaction receipt. Unfortunately there may not be a an error in your Ethereum client indicating any issues with the transaction: I1025 18 : 13 : 32.817691 eth / api . go : 1185 ] Tx ( 0xeaac9aab7f9aeab189acd8714c5a60c7424f86820884b815c4448cfcd4d9fc79 ) to : 0x9c98e381edc5fe1ac514935f3cc3edaa764cf004 The easiest way to see if the submission is waiting to mined is to refer to Etherscan and search for the address the transaction was sent using https://testnet.etherscan.io/address/0x ... If the submission has been successful it should be visible in Etherscan within seconds of you performing the transaction submission. The wait is for the mining to take place. If there is no sign of it then the transaction has vanished into the ether (sorry). The likely cause of this is likely to be to do with the transaction's nonce either not being set, or being too low. Please refer to the section Transaction nonce for more information. I want to see details of the JSON-RPC requests and responses \u00b6 web3j uses the SLF4J logging facade, which you can easily integrate with your preferred logging framework. One lightweight approach is to use LOGBack , which is already configured in the integration-tests module. Include the LOGBack dependencies listed in integration-tests/build.gradle and associated log configuration as per integration-tests/src/test/resources/logback-test.xml . Note: if you are configuring logging for an application (not tests), you will need to ensure that the Logback dependencies are configured as compile dependencies, and that the configuration file is named and located in src/main/resources/logback.xml . I want to obtain some Ether on Testnet, but don't want to have to mine it myself \u00b6 Please refer to the Ethereum testnets for how to obtain some Ether. How do I obtain the return value from a smart contract method invoked by a transaction? \u00b6 You can't. It is not possible to return values from methods on smart contracts that are called as part of a transaction. If you wish to read a value during a transaction, you must use Events . To query values from smart contracts you must use a call, which is separate to a transaction. These methods should be marked as constant functions. Solidity smart contract wrappers created by web3j handle these differences for you. The following StackExchange post is useful for background. Is it possible to send arbitrary text with transactions? \u00b6 Yes it is. Text should be ASCII encoded and provided as a hexadecimal String in the data field of the transaction. This is demonstrated below: RawTransaction . createTransaction ( < nonce > , GAS_PRICE , GAS_LIMIT , \"0x<address>\" , < amount > , \"0x<hex encoded text>\" ); byte [] signedMessage = TransactionEncoder . signMessage ( rawTransaction , ALICE ); String hexValue = Numeric . toHexString ( signedMessage ); EthSendTransaction ethSendTransaction = web3j . ethSendRawTransaction ( hexValue ). send (); String transactionHash = ethSendTransaction . getTransactionHash (); ... Note : Please ensure you increase the gas limit on the transaction to allow for the storage of text. The following StackExchange post is useful for background. I've generated my smart contract wrapper, but the binary for the smart contract is empty? \u00b6 If you have defined an interface in Solidity, but one of your method implementations doesn't match the original interface definitions, the produced binary will be blank. In the following example: contract Web3jToken is ERC20Basic , Ownable { ... function transfer ( address _from , address _to , uint256 _value ) onlyOwner returns ( bool ) { ... } We forgot to define the from parameter in one of the inherited contracts: contract ERC20Basic { ... function transfer ( address to , uint256 value ) returns ( bool ); ... } The Solidity compiler will not complain about this, however, the produced binary file for the Web3jToken will be blank. My ENS lookups are failing \u00b6 Are you sure that you are connecting to the correct network to perform the lookup? If web3j is telling you that the node is not in sync, you may need to change the syncThreshold in the ENS resolver . Where can I get commercial support for web3j? \u00b6 Commercial support and training is available from web3labs .","title":"Troubleshooting"},{"location":"references/troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"references/troubleshooting/#do-you-have-a-sample-web3j-project","text":"Yes, refer to the web3j sample project outlined in the Quickstart .","title":"Do you have a sample web3j project"},{"location":"references/troubleshooting/#im-submitting-a-transaction-but-its-not-being-mined","text":"After creating and sending a transaction, you receive a transaction hash, however calling eth_getTransactionReceipt always returns a blank value, indicating the transaction has not been mined: String transactionHash = sendTransaction (...); // you loop through the following expecting to eventually get a receipt once the transaction // is mined EthGetTransactionReceipt . TransactionReceipt transactionReceipt = web3j . ethGetTransactionReceipt ( transactionHash ). sendAsync (). get (); if ( ! transactionReceipt . isPresent ()) { // try again, ad infinitum } However, you never receive a transaction receipt. Unfortunately there may not be a an error in your Ethereum client indicating any issues with the transaction: I1025 18 : 13 : 32.817691 eth / api . go : 1185 ] Tx ( 0xeaac9aab7f9aeab189acd8714c5a60c7424f86820884b815c4448cfcd4d9fc79 ) to : 0x9c98e381edc5fe1ac514935f3cc3edaa764cf004 The easiest way to see if the submission is waiting to mined is to refer to Etherscan and search for the address the transaction was sent using https://testnet.etherscan.io/address/0x ... If the submission has been successful it should be visible in Etherscan within seconds of you performing the transaction submission. The wait is for the mining to take place. If there is no sign of it then the transaction has vanished into the ether (sorry). The likely cause of this is likely to be to do with the transaction's nonce either not being set, or being too low. Please refer to the section Transaction nonce for more information.","title":"I'm submitting a transaction, but it's not being mined"},{"location":"references/troubleshooting/#i-want-to-see-details-of-the-json-rpc-requests-and-responses","text":"web3j uses the SLF4J logging facade, which you can easily integrate with your preferred logging framework. One lightweight approach is to use LOGBack , which is already configured in the integration-tests module. Include the LOGBack dependencies listed in integration-tests/build.gradle and associated log configuration as per integration-tests/src/test/resources/logback-test.xml . Note: if you are configuring logging for an application (not tests), you will need to ensure that the Logback dependencies are configured as compile dependencies, and that the configuration file is named and located in src/main/resources/logback.xml .","title":"I want to see details of the JSON-RPC requests and responses"},{"location":"references/troubleshooting/#i-want-to-obtain-some-ether-on-testnet-but-dont-want-to-have-to-mine-it-myself","text":"Please refer to the Ethereum testnets for how to obtain some Ether.","title":"I want to obtain some Ether on Testnet, but don't want to have to mine it myself"},{"location":"references/troubleshooting/#how-do-i-obtain-the-return-value-from-a-smart-contract-method-invoked-by-a-transaction","text":"You can't. It is not possible to return values from methods on smart contracts that are called as part of a transaction. If you wish to read a value during a transaction, you must use Events . To query values from smart contracts you must use a call, which is separate to a transaction. These methods should be marked as constant functions. Solidity smart contract wrappers created by web3j handle these differences for you. The following StackExchange post is useful for background.","title":"How do I obtain the return value from a smart contract method invoked by a transaction?"},{"location":"references/troubleshooting/#is-it-possible-to-send-arbitrary-text-with-transactions","text":"Yes it is. Text should be ASCII encoded and provided as a hexadecimal String in the data field of the transaction. This is demonstrated below: RawTransaction . createTransaction ( < nonce > , GAS_PRICE , GAS_LIMIT , \"0x<address>\" , < amount > , \"0x<hex encoded text>\" ); byte [] signedMessage = TransactionEncoder . signMessage ( rawTransaction , ALICE ); String hexValue = Numeric . toHexString ( signedMessage ); EthSendTransaction ethSendTransaction = web3j . ethSendRawTransaction ( hexValue ). send (); String transactionHash = ethSendTransaction . getTransactionHash (); ... Note : Please ensure you increase the gas limit on the transaction to allow for the storage of text. The following StackExchange post is useful for background.","title":"Is it possible to send arbitrary text with transactions?"},{"location":"references/troubleshooting/#ive-generated-my-smart-contract-wrapper-but-the-binary-for-the-smart-contract-is-empty","text":"If you have defined an interface in Solidity, but one of your method implementations doesn't match the original interface definitions, the produced binary will be blank. In the following example: contract Web3jToken is ERC20Basic , Ownable { ... function transfer ( address _from , address _to , uint256 _value ) onlyOwner returns ( bool ) { ... } We forgot to define the from parameter in one of the inherited contracts: contract ERC20Basic { ... function transfer ( address to , uint256 value ) returns ( bool ); ... } The Solidity compiler will not complain about this, however, the produced binary file for the Web3jToken will be blank.","title":"I've generated my smart contract wrapper, but the binary for the smart contract is empty?"},{"location":"references/troubleshooting/#my-ens-lookups-are-failing","text":"Are you sure that you are connecting to the correct network to perform the lookup? If web3j is telling you that the node is not in sync, you may need to change the syncThreshold in the ENS resolver .","title":"My ENS lookups are failing"},{"location":"references/troubleshooting/#where-can-i-get-commercial-support-for-web3j","text":"Commercial support and training is available from web3labs .","title":"Where can I get commercial support for web3j?"},{"location":"smart_contracts/application_binary_interface/","text":"Application Binary Interface \u00b6 The Application Binary Interface (ABI) is a data encoding scheme used in Ethereum for working with smart contracts. The types defined in the ABI are the same as those you encounter when writing Smart Contracts with Solidity - i.e. uint8, ..., uint256, int8, ..., int256, bool, string, etc. The ABI module in web3j provides full support for the ABI specification, and includes: Java implementations of all ABI types, including conversion from and to native Java types Function and event support ABIv2 support Plenty of unit tests Type mappings \u00b6 The native Java to ABI type mappings used within web3j are as follows: boolean -> bool BigInteger -> uint/int byte[] -> bytes String -> string and address types List<> -> dynamic/static array T -> struct/tuple types BigInteger types have to be used for numeric types, as numeric types in Ethereum are 256 bit integer values. Fixed point types have been defined for Ethereum, but are not currently implemented in Solidity , hence web3j does not currently support them (they were provided in versions prior to 3.x). Once available in Solidity, they will be reintroduced back into the web3j ABI module. Solidity structs will have a corresponding class generated for them. Currently only contract compiled with Solidity compiler version 0.6.x. The names of the corresponding classes will be the same as the name of the struct in the Solidity contract i.e. struct Foo in your smart contract will be called Foo in the smart contract wrapper. For more information on using ABI types in Java, refer to Solidity smart contract wrappers . Further details \u00b6 Please refer to the various ABI unit tests for encoding/decoding examples. A full ABI specification is maintained with the Solidity documentation . Dependencies \u00b6 This is a very lightweight module, with the only third-party dependency being Bouncy Castle for cryptographic hashing. The hope is that other projects wishing to work with Ethereum's ABI on the JVM or Android will choose to make use of this module rather then write their own implementations.","title":"Application Binary Interface"},{"location":"smart_contracts/application_binary_interface/#application-binary-interface","text":"The Application Binary Interface (ABI) is a data encoding scheme used in Ethereum for working with smart contracts. The types defined in the ABI are the same as those you encounter when writing Smart Contracts with Solidity - i.e. uint8, ..., uint256, int8, ..., int256, bool, string, etc. The ABI module in web3j provides full support for the ABI specification, and includes: Java implementations of all ABI types, including conversion from and to native Java types Function and event support ABIv2 support Plenty of unit tests","title":"Application Binary Interface"},{"location":"smart_contracts/application_binary_interface/#type-mappings","text":"The native Java to ABI type mappings used within web3j are as follows: boolean -> bool BigInteger -> uint/int byte[] -> bytes String -> string and address types List<> -> dynamic/static array T -> struct/tuple types BigInteger types have to be used for numeric types, as numeric types in Ethereum are 256 bit integer values. Fixed point types have been defined for Ethereum, but are not currently implemented in Solidity , hence web3j does not currently support them (they were provided in versions prior to 3.x). Once available in Solidity, they will be reintroduced back into the web3j ABI module. Solidity structs will have a corresponding class generated for them. Currently only contract compiled with Solidity compiler version 0.6.x. The names of the corresponding classes will be the same as the name of the struct in the Solidity contract i.e. struct Foo in your smart contract will be called Foo in the smart contract wrapper. For more information on using ABI types in Java, refer to Solidity smart contract wrappers .","title":"Type mappings"},{"location":"smart_contracts/application_binary_interface/#further-details","text":"Please refer to the various ABI unit tests for encoding/decoding examples. A full ABI specification is maintained with the Solidity documentation .","title":"Further details"},{"location":"smart_contracts/application_binary_interface/#dependencies","text":"This is a very lightweight module, with the only third-party dependency being Bouncy Castle for cryptographic hashing. The hope is that other projects wishing to work with Ethereum's ABI on the JVM or Android will choose to make use of this module rather then write their own implementations.","title":"Dependencies"},{"location":"smart_contracts/compiling_solidity/","text":"Compiling Solidity source code \u00b6 Compilation to bytecode is performed by the Solidity compiler, solc . You can install the compiler, locally following the instructions as per the project documentation . To compile the Solidity code run: $ solc <contract>.sol --bin --abi --optimize -o <output-dir>/ The --bin and --abi compiler arguments are both required to take full advantage of working with smart contracts from web3j. --bin Outputs a Solidity binary file containing the hex-encoded binary to provide with the transaction request. This is required only for deploy and isValid Solidity smart contract wrappers methods. --abi Outputs a Solidity Application Binary Interface file which details all of the publicly accessible contract methods and their associated parameters. These details along with the contract address are crucial for interacting with smart contracts. The ABI file is also used for the generation of Solidity smart contract wrappers There is also a --gas argument for providing estimates of the Gas required to create a contract and transact with its methods. Alternatively, you can write and compile Solidity code in your browser via the browser-solidity project. browser-solidity is great for smaller smart contracts, but you may run into issues working with larger contracts. You can also compile Solidity code via Ethereum clients such as Geth and OpenEthereum, using the JSON-RPC method eth_compileSolidity which is also supported in web3j. However, the Solidity compiler must be installed on the client for this to work. There are further options available, please refer to the relevant section in the Homestead documentation.","title":"Compiling Solidity source code"},{"location":"smart_contracts/compiling_solidity/#compiling-solidity-source-code","text":"Compilation to bytecode is performed by the Solidity compiler, solc . You can install the compiler, locally following the instructions as per the project documentation . To compile the Solidity code run: $ solc <contract>.sol --bin --abi --optimize -o <output-dir>/ The --bin and --abi compiler arguments are both required to take full advantage of working with smart contracts from web3j. --bin Outputs a Solidity binary file containing the hex-encoded binary to provide with the transaction request. This is required only for deploy and isValid Solidity smart contract wrappers methods. --abi Outputs a Solidity Application Binary Interface file which details all of the publicly accessible contract methods and their associated parameters. These details along with the contract address are crucial for interacting with smart contracts. The ABI file is also used for the generation of Solidity smart contract wrappers There is also a --gas argument for providing estimates of the Gas required to create a contract and transact with its methods. Alternatively, you can write and compile Solidity code in your browser via the browser-solidity project. browser-solidity is great for smaller smart contracts, but you may run into issues working with larger contracts. You can also compile Solidity code via Ethereum clients such as Geth and OpenEthereum, using the JSON-RPC method eth_compileSolidity which is also supported in web3j. However, the Solidity compiler must be installed on the client for this to work. There are further options available, please refer to the relevant section in the Homestead documentation.","title":"Compiling Solidity source code"},{"location":"smart_contracts/construction_and_deployment/","text":"Construction and deployment \u00b6 Construction and deployment of smart contracts happens with the deploy method: YourSmartContract contract = YourSmartContract . deploy ( < web3j > , < credentials > , GAS_PRICE , GAS_LIMIT , [< initialValue > , ] < param1 > , ..., < paramN > ). send (); This will create a new instance of the smart contract on the Ethereum blockchain using the supplied credentials, and constructor parameter values. The <initialValue> parameter is only required if your smart contract accepts Ether on construction. This requires the Solidity payable modifier to be present in the contract. It returns a new smart contract wrapper instance which contains the underlying address of the smart contract. If you wish to construct an instance of a smart contract wrapper with an existing smart contract, simply pass in it's address: YourSmartContract contract = YourSmartContract . load ( \"0x<address>|<ensName>\" , web3j , credentials , GAS_PRICE , GAS_LIMIT ); Deploying and interacting with smart contracts \u00b6 If you want to avoid the underlying implementation detail for working with smart contracts, Web3j provides Solidity smart contract wrappers which enable you to interact directly with all of a smart contract's methods via a generated wrapper object. Alternatively, if you wish to send regular transactions or have more control over your interactions with your smart contracts, please refer to the sections Solidity smart contract wrappers , Transacting with a smart contract and Querying the state of a smart contract for details. Solidity smart contract wrappers \u00b6 Web3j supports the auto-generation of smart contract function wrappers in Java from Solidity ABI files. The Epirus Command Line Tools tools ship with a command line utility for generating the smart contract function wrappers: $ epirus solidity generate [ -hV ] [ -jt ] [ -st ] -a = <abiFile> [ -b = <binFile> ] -o = <destinationFileDir> -p = <packageName> -h, --help Show this help message and exit. -V, --version Print version information and exit. -jt, --javaTypes use native java types. Default: true -st, --solidityTypes use solidity types. -a, --abiFile = <abiFile> abi file with contract definition. -b, --binFile = <binFile> optional bin file with contract compiled code in order to generate deploy methods. -o, --outputDir = <destinationFileDir> destination base directory. -p, --package = <packageName> base package name. <binfile> is required for Contract validity In versions prior to 3.x of Web3j, the generated smart contract wrappers used native Solidity types. From Web3j 3.x onwards, Java types are created by default. You can create Solidity types using the --solidityTypes command line argument. From Web3j version 4.6.x onwards, the generator supports ABIv2 for contract compiled with Solidity compiler version 0.6.x. This means that you can have structs as input/output/event parameters in your smart contract. You can also generate the wrappers by calling the Java class directly: org.web3j.codegen.SolidityFunctionWrapperGenerator -b /path/to/<smart-contract>.bin -a /path/to/<smart-contract>.abi -o /path/to/src/main/java -p com.your.organisation.name Where the bin and abi are obtained as per Compiling Solidity sourse code The native Java to Solidity type conversions used are detailed in the Application Binary Interface section. The smart contract wrappers support all common operations for working with smart contracts: Construction and deployment Invoking transactions and events Calling constant methods Contract validity Any method calls that requires an underlying JSON-RPC call to take place will return a Future to avoid blocking. Web3j also supports the generation of Java smart contract function wrappers directly from Truffle's Contract Schema via the Command Line Tools utility. $ epirus truffle generate [ --javaTypes | --solidityTypes ] /path/to/<truffle-smart-contract-output>.json -o /path/to/src/main/java -p com.your.organisation.name And this also can be invoked by calling the Java class: org.web3j.codegen.TruffleJsonFunctionWrapperGenerator /path/to/<truffle-smart-contract-output>.json -o /path/to/src/main/java -p com.your.organisation.name A wrapper generated this way is \"enhanced\" to expose the per-network deployed address of the contract. These addresses are from the truffle deployment at the time the wrapper is generated.","title":"Construction and Deployment"},{"location":"smart_contracts/construction_and_deployment/#construction-and-deployment","text":"Construction and deployment of smart contracts happens with the deploy method: YourSmartContract contract = YourSmartContract . deploy ( < web3j > , < credentials > , GAS_PRICE , GAS_LIMIT , [< initialValue > , ] < param1 > , ..., < paramN > ). send (); This will create a new instance of the smart contract on the Ethereum blockchain using the supplied credentials, and constructor parameter values. The <initialValue> parameter is only required if your smart contract accepts Ether on construction. This requires the Solidity payable modifier to be present in the contract. It returns a new smart contract wrapper instance which contains the underlying address of the smart contract. If you wish to construct an instance of a smart contract wrapper with an existing smart contract, simply pass in it's address: YourSmartContract contract = YourSmartContract . load ( \"0x<address>|<ensName>\" , web3j , credentials , GAS_PRICE , GAS_LIMIT );","title":"Construction and deployment"},{"location":"smart_contracts/construction_and_deployment/#deploying-and-interacting-with-smart-contracts","text":"If you want to avoid the underlying implementation detail for working with smart contracts, Web3j provides Solidity smart contract wrappers which enable you to interact directly with all of a smart contract's methods via a generated wrapper object. Alternatively, if you wish to send regular transactions or have more control over your interactions with your smart contracts, please refer to the sections Solidity smart contract wrappers , Transacting with a smart contract and Querying the state of a smart contract for details.","title":"Deploying and interacting with smart contracts"},{"location":"smart_contracts/construction_and_deployment/#solidity-smart-contract-wrappers","text":"Web3j supports the auto-generation of smart contract function wrappers in Java from Solidity ABI files. The Epirus Command Line Tools tools ship with a command line utility for generating the smart contract function wrappers: $ epirus solidity generate [ -hV ] [ -jt ] [ -st ] -a = <abiFile> [ -b = <binFile> ] -o = <destinationFileDir> -p = <packageName> -h, --help Show this help message and exit. -V, --version Print version information and exit. -jt, --javaTypes use native java types. Default: true -st, --solidityTypes use solidity types. -a, --abiFile = <abiFile> abi file with contract definition. -b, --binFile = <binFile> optional bin file with contract compiled code in order to generate deploy methods. -o, --outputDir = <destinationFileDir> destination base directory. -p, --package = <packageName> base package name. <binfile> is required for Contract validity In versions prior to 3.x of Web3j, the generated smart contract wrappers used native Solidity types. From Web3j 3.x onwards, Java types are created by default. You can create Solidity types using the --solidityTypes command line argument. From Web3j version 4.6.x onwards, the generator supports ABIv2 for contract compiled with Solidity compiler version 0.6.x. This means that you can have structs as input/output/event parameters in your smart contract. You can also generate the wrappers by calling the Java class directly: org.web3j.codegen.SolidityFunctionWrapperGenerator -b /path/to/<smart-contract>.bin -a /path/to/<smart-contract>.abi -o /path/to/src/main/java -p com.your.organisation.name Where the bin and abi are obtained as per Compiling Solidity sourse code The native Java to Solidity type conversions used are detailed in the Application Binary Interface section. The smart contract wrappers support all common operations for working with smart contracts: Construction and deployment Invoking transactions and events Calling constant methods Contract validity Any method calls that requires an underlying JSON-RPC call to take place will return a Future to avoid blocking. Web3j also supports the generation of Java smart contract function wrappers directly from Truffle's Contract Schema via the Command Line Tools utility. $ epirus truffle generate [ --javaTypes | --solidityTypes ] /path/to/<truffle-smart-contract-output>.json -o /path/to/src/main/java -p com.your.organisation.name And this also can be invoked by calling the Java class: org.web3j.codegen.TruffleJsonFunctionWrapperGenerator /path/to/<truffle-smart-contract-output>.json -o /path/to/src/main/java -p com.your.organisation.name A wrapper generated this way is \"enhanced\" to expose the per-network deployed address of the contract. These addresses are from the truffle deployment at the time the wrapper is generated.","title":"Solidity smart contract wrappers"},{"location":"smart_contracts/contract_validity/","text":"Contract validity \u00b6 Using this method, you may want to ascertain that the contract address that you have loaded is the smart contract that you expect. For this you can use the isValid smart contract method, which will only return true if the deployed bytecode at the contract address matches the bytecode in the smart contract wrapper.: contract . isValid (); // returns false if the contract bytecode does not match what's deployed // at the provided address Note: Contract wrapper has to be generated with --bin for this to work.","title":"Contract Validity"},{"location":"smart_contracts/contract_validity/#contract-validity","text":"Using this method, you may want to ascertain that the contract address that you have loaded is the smart contract that you expect. For this you can use the isValid smart contract method, which will only return true if the deployed bytecode at the contract address matches the bytecode in the smart contract wrapper.: contract . isValid (); // returns false if the contract bytecode does not match what's deployed // at the provided address Note: Contract wrapper has to be generated with --bin for this to work.","title":"Contract validity"},{"location":"smart_contracts/contracts_supported_by_web3j/","text":"Contracts supported by web3j \u00b6 EIP20 \u00b6 ERC20 tokens are supported via ERC20 contract wrapper as defined in EIP20 To fetch your token balance you can simply do: ERC20 contract = ERC20 . load ( tokenAddress , web3j , txManager , gasPriceProvider ); BigInteger balance = contract . balanceOf ( account ). send (); EIP165 \u00b6 Smart contract interfaces support and discovery as defined in EIP165 To check whether token contract supports particular interface: ERC165 contract = ERC165 . load ( tokenAddress , web3j , txManager , gasPriceProvider ); Boolean isSupported = contract . supportsInterface ( interfaceID ). send (); EIP721 \u00b6 Support for non-fungible tokens, also known as deeds as defined in EIP721 . This contains the following contract wrappers: ERC721 is a set of methods that NFT should support ERC721Metadata optional metadata extension for NFT ERC721Enumerable optional enumeration extension for NFT","title":"Contracts Supported by Web3j"},{"location":"smart_contracts/contracts_supported_by_web3j/#contracts-supported-by-web3j","text":"","title":"Contracts supported by web3j"},{"location":"smart_contracts/contracts_supported_by_web3j/#eip20","text":"ERC20 tokens are supported via ERC20 contract wrapper as defined in EIP20 To fetch your token balance you can simply do: ERC20 contract = ERC20 . load ( tokenAddress , web3j , txManager , gasPriceProvider ); BigInteger balance = contract . balanceOf ( account ). send ();","title":"EIP20"},{"location":"smart_contracts/contracts_supported_by_web3j/#eip165","text":"Smart contract interfaces support and discovery as defined in EIP165 To check whether token contract supports particular interface: ERC165 contract = ERC165 . load ( tokenAddress , web3j , txManager , gasPriceProvider ); Boolean isSupported = contract . supportsInterface ( interfaceID ). send ();","title":"EIP165"},{"location":"smart_contracts/contracts_supported_by_web3j/#eip721","text":"Support for non-fungible tokens, also known as deeds as defined in EIP721 . This contains the following contract wrappers: ERC721 is a set of methods that NFT should support ERC721Metadata optional metadata extension for NFT ERC721Enumerable optional enumeration extension for NFT","title":"EIP721"},{"location":"smart_contracts/getting_started_solidity/","text":"Getting started with Solidity \u00b6 An overview of Solidity is beyond the scope of these docs, however, the following resources are a good place to start: Introduction to Smart Contracts in the Solidity project documentation Writing a contract in the Ethereum Homestead Guide","title":"Getting Started with Solidity"},{"location":"smart_contracts/getting_started_solidity/#getting-started-with-solidity","text":"An overview of Solidity is beyond the scope of these docs, however, the following resources are a good place to start: Introduction to Smart Contracts in the Solidity project documentation Writing a contract in the Ethereum Homestead Guide","title":"Getting started with Solidity"},{"location":"smart_contracts/interacting_with_smart_contract/","text":"Transaction Managers \u00b6 web3j provides a TransactionManager abstraction to control the manner you connect to Ethereum clients with. The default mechanism uses web3j's RawTransactionManager which works with Ethereum wallet files to sign transactions offline before submitting them to the network. However, you may wish to modify the transaction manager, which you can pass to the smart contract deployment and creation methods instead of a credentials object, i.e.: YourSmartContract contract = YourSmartContract . deploy ( < web3j > , < transactionManager > , GAS_PRICE , GAS_LIMIT , < param1 > , ..., < paramN > ). send (); In addition to the RawTransactionManager, web3j provides a ClientTransactionManager which passes the responsibility of signing your transaction on to the Ethereum client you are connecting to. There is also a ReadonlyTransactionManager for when you only want to retrieve data from a smart contract, but not transact with it. Specifying the Chain Id on Transactions (EIP-155) \u00b6 The RawTransactionManager takes an optional chainId parameter to specify the chain id to be used on transactions as per EIP-155 . This prevents transactions from one chain being re-broadcast onto another chain, such as from Ropsten to Mainnet: TransactionManager transactionManager = new RawTransactionManager ( web3j , credentials , ChainId . MAINNET ); In order to avoid having to change config or code to specify which chain you are working with, web3j's default behaviour is to not specify chain ids on transactions to simplify working with the library. However, the recommendation of the Ethereum community is to use them. You can obtain the chain id of the network that your Ethereum client is connected to with the following request: web3j . netVersion (). send (). getNetVersion (); Transaction Receipt Processors \u00b6 By default, when a new transaction is submitted by web3j to an Ethereum client, web3j will continually poll the client until it receives a TransactionReceipt , indicating that the transaction has been added to the blockchain. If you are sending a number of transactions asynchronously with web3j, this can result in a number of threads polling the client concurrently. To reduce this polling overhead, web3j provides configurable TransactionReceiptProcessors . There are a number of processors provided in web3j: PollingTransactionReceiptProcessor is the default processor used in web3j, which polls periodically for a transaction receipt for each individual pending transaction. QueuingTransactionReceiptProcessor has an internal queue of all pending transactions. It contains a worker that runs periodically to query if a transaction receipt is available yet. If a receipt is found, a callback to the client is invoked. NoOpProcessor provides an EmptyTransactionReceipt to clients which only contains the transaction hash. This is for clients who do not want web3j to perform any polling for a transaction receipt. Note: the EmptyTransactionReceipt is also provided in the the initial response from the QueuingTransactionReceiptProcessor . This allows the caller to have the transaction hash for the transaction that was submitted to the network. If you do not wish to use the default processor( PollingTransactionReceiptProcessor ), you can specify the transaction receipt processor to use as follows: TransactionReceiptProcessor transactionReceiptProcessor = new QueuingTransactionReceiptProcessor ( web3j , new Callback () { @Override public void accept ( TransactionReceipt transactionReceipt ) { // process transactionReceipt } @Override public void exception ( Exception exception ) { // handle exception } TransactionManager transactionManager = new RawTransactionManager ( web3j , credentials , ChainId . MAINNET , transactionReceiptProcessor ); If you require further information, the FastRawTransactionManagerIT demonstrates the polling and queuing approaches. Invoking transactions and events \u00b6 All transactional smart contract methods are named identically to their Solidity methods, taking the same parameter values. Transactional calls do not return any values, regardless of the return type specified on the method. Hence, for all transactional methods the Transaction Receipt associated with the transaction is returned.: TransactionReceipt transactionReceipt = contract . someMethod ( < param1 > , ...). send (); The transaction receipt is useful for two reasons: It provides details of the mined block that the transaction resides in Solidity events that are called will be logged as part of the transaction, which can then be extracted Any events defined within a smart contract will be represented in the smart contract wrapper with a method named process<Event Name>Event , which takes the Transaction Receipt and from this extracts the indexed and non-indexed event parameters, which are returned decoded in an instance of the EventValues object.: EventValues eventValues = contract . processSomeEvent ( transactionReceipt ); Alternatively you can use an Flowable filter instead which will listen for events associated with the smart contract: contract . someEventFlowable ( startBlock , endBlock ). . subscribe ( event -> ...); For more information on working with Flowable filters, refer to Filters and Events . Remember that for any indexed array, bytes and string Solidity parameter types, a Keccak-256 hash of their values will be returned, see the documentation for further information. Calling constant methods \u00b6 Constant methods are those that read a value in a smart contract, and do not alter the state of the smart contract. These methods are available with the same method signature as the smart contract they were generated from: Type result = contract . someMethod ( < param1 > , ...). send (); Dynamic gas price and limit \u00b6 When working with smart contracts you may want to specify different gas price and limit values depending on the function being invoked. You can do that by creating your own ContractGasProvider for the smart contract wrapper. Every generated wrapper contains all smart contract method names listed as a constants, which facilitates compilation-time matching via a switch statement. For example, using the Greeter contract: Greeter greeter = new Greeter (...); greeter . setGasProvider ( new DefaultGasProvider () { @Override public BigInteger getGasPrice ( String contractFunc ) { switch ( contractFunc ) { case Greeter . FUNC_GREET : return BigInteger . valueOf ( 22_000_000_000L ); case Greeter . FUNC_KILL : return BigInteger . valueOf ( 44_000_000_000L ); default : throw new NotImplementedException (); } } @Override public BigInteger getGasLimit ( String contractFunc ) { switch ( contractFunc ) { case Greeter . FUNC_GREET : return BigInteger . valueOf ( 4_300_000 ); case Greeter . FUNC_KILL : return BigInteger . valueOf ( 5_300_000 ); default : throw new NotImplementedException (); } } });","title":"Interacting with Smart Contracts"},{"location":"smart_contracts/interacting_with_smart_contract/#transaction-managers","text":"web3j provides a TransactionManager abstraction to control the manner you connect to Ethereum clients with. The default mechanism uses web3j's RawTransactionManager which works with Ethereum wallet files to sign transactions offline before submitting them to the network. However, you may wish to modify the transaction manager, which you can pass to the smart contract deployment and creation methods instead of a credentials object, i.e.: YourSmartContract contract = YourSmartContract . deploy ( < web3j > , < transactionManager > , GAS_PRICE , GAS_LIMIT , < param1 > , ..., < paramN > ). send (); In addition to the RawTransactionManager, web3j provides a ClientTransactionManager which passes the responsibility of signing your transaction on to the Ethereum client you are connecting to. There is also a ReadonlyTransactionManager for when you only want to retrieve data from a smart contract, but not transact with it.","title":"Transaction Managers"},{"location":"smart_contracts/interacting_with_smart_contract/#specifying-the-chain-id-on-transactions-eip-155","text":"The RawTransactionManager takes an optional chainId parameter to specify the chain id to be used on transactions as per EIP-155 . This prevents transactions from one chain being re-broadcast onto another chain, such as from Ropsten to Mainnet: TransactionManager transactionManager = new RawTransactionManager ( web3j , credentials , ChainId . MAINNET ); In order to avoid having to change config or code to specify which chain you are working with, web3j's default behaviour is to not specify chain ids on transactions to simplify working with the library. However, the recommendation of the Ethereum community is to use them. You can obtain the chain id of the network that your Ethereum client is connected to with the following request: web3j . netVersion (). send (). getNetVersion ();","title":"Specifying the Chain Id on Transactions (EIP-155)"},{"location":"smart_contracts/interacting_with_smart_contract/#transaction-receipt-processors","text":"By default, when a new transaction is submitted by web3j to an Ethereum client, web3j will continually poll the client until it receives a TransactionReceipt , indicating that the transaction has been added to the blockchain. If you are sending a number of transactions asynchronously with web3j, this can result in a number of threads polling the client concurrently. To reduce this polling overhead, web3j provides configurable TransactionReceiptProcessors . There are a number of processors provided in web3j: PollingTransactionReceiptProcessor is the default processor used in web3j, which polls periodically for a transaction receipt for each individual pending transaction. QueuingTransactionReceiptProcessor has an internal queue of all pending transactions. It contains a worker that runs periodically to query if a transaction receipt is available yet. If a receipt is found, a callback to the client is invoked. NoOpProcessor provides an EmptyTransactionReceipt to clients which only contains the transaction hash. This is for clients who do not want web3j to perform any polling for a transaction receipt. Note: the EmptyTransactionReceipt is also provided in the the initial response from the QueuingTransactionReceiptProcessor . This allows the caller to have the transaction hash for the transaction that was submitted to the network. If you do not wish to use the default processor( PollingTransactionReceiptProcessor ), you can specify the transaction receipt processor to use as follows: TransactionReceiptProcessor transactionReceiptProcessor = new QueuingTransactionReceiptProcessor ( web3j , new Callback () { @Override public void accept ( TransactionReceipt transactionReceipt ) { // process transactionReceipt } @Override public void exception ( Exception exception ) { // handle exception } TransactionManager transactionManager = new RawTransactionManager ( web3j , credentials , ChainId . MAINNET , transactionReceiptProcessor ); If you require further information, the FastRawTransactionManagerIT demonstrates the polling and queuing approaches.","title":"Transaction Receipt Processors"},{"location":"smart_contracts/interacting_with_smart_contract/#invoking-transactions-and-events","text":"All transactional smart contract methods are named identically to their Solidity methods, taking the same parameter values. Transactional calls do not return any values, regardless of the return type specified on the method. Hence, for all transactional methods the Transaction Receipt associated with the transaction is returned.: TransactionReceipt transactionReceipt = contract . someMethod ( < param1 > , ...). send (); The transaction receipt is useful for two reasons: It provides details of the mined block that the transaction resides in Solidity events that are called will be logged as part of the transaction, which can then be extracted Any events defined within a smart contract will be represented in the smart contract wrapper with a method named process<Event Name>Event , which takes the Transaction Receipt and from this extracts the indexed and non-indexed event parameters, which are returned decoded in an instance of the EventValues object.: EventValues eventValues = contract . processSomeEvent ( transactionReceipt ); Alternatively you can use an Flowable filter instead which will listen for events associated with the smart contract: contract . someEventFlowable ( startBlock , endBlock ). . subscribe ( event -> ...); For more information on working with Flowable filters, refer to Filters and Events . Remember that for any indexed array, bytes and string Solidity parameter types, a Keccak-256 hash of their values will be returned, see the documentation for further information.","title":"Invoking transactions and events"},{"location":"smart_contracts/interacting_with_smart_contract/#calling-constant-methods","text":"Constant methods are those that read a value in a smart contract, and do not alter the state of the smart contract. These methods are available with the same method signature as the smart contract they were generated from: Type result = contract . someMethod ( < param1 > , ...). send ();","title":"Calling constant methods"},{"location":"smart_contracts/interacting_with_smart_contract/#dynamic-gas-price-and-limit","text":"When working with smart contracts you may want to specify different gas price and limit values depending on the function being invoked. You can do that by creating your own ContractGasProvider for the smart contract wrapper. Every generated wrapper contains all smart contract method names listed as a constants, which facilitates compilation-time matching via a switch statement. For example, using the Greeter contract: Greeter greeter = new Greeter (...); greeter . setGasProvider ( new DefaultGasProvider () { @Override public BigInteger getGasPrice ( String contractFunc ) { switch ( contractFunc ) { case Greeter . FUNC_GREET : return BigInteger . valueOf ( 22_000_000_000L ); case Greeter . FUNC_KILL : return BigInteger . valueOf ( 44_000_000_000L ); default : throw new NotImplementedException (); } } @Override public BigInteger getGasLimit ( String contractFunc ) { switch ( contractFunc ) { case Greeter . FUNC_GREET : return BigInteger . valueOf ( 4_300_000 ); case Greeter . FUNC_KILL : return BigInteger . valueOf ( 5_300_000 ); default : throw new NotImplementedException (); } } });","title":"Dynamic gas price and limit"},{"location":"smart_contracts/smart_contracts_overview/","text":"Smart Contracts \u00b6 Developers have the choice of two languages for writing smart contracts: Solidity The flagship language of Ethereum, and most popular language for smart contracts. LISP Like Language (LLL) A low level language, Serpent provides a superset of LLL. There's not a great deal of information for working with LLL, the following blog /var/log/syrinx and associated lll-resurrected GitHub repository is a good place to start. In order to deploy a smart contract onto the Ethereum blockchain, it must first be compiled into a bytecode format, then it can be sent as part of a transaction. Web3j can do all of this for you with its Solidity smart contract wrappers . To understand what is happening behind the scenes, you can refer to the details in Creation of a smart contract . Given that Solidity is the language of choice for writing smart contracts, it is the language supported by Web3j, and is used for all subsequent examples. Examples \u00b6 Please refer to EIP-20 Ethereum token standard smart contract","title":"Smart Contract Overview"},{"location":"smart_contracts/smart_contracts_overview/#smart-contracts","text":"Developers have the choice of two languages for writing smart contracts: Solidity The flagship language of Ethereum, and most popular language for smart contracts. LISP Like Language (LLL) A low level language, Serpent provides a superset of LLL. There's not a great deal of information for working with LLL, the following blog /var/log/syrinx and associated lll-resurrected GitHub repository is a good place to start. In order to deploy a smart contract onto the Ethereum blockchain, it must first be compiled into a bytecode format, then it can be sent as part of a transaction. Web3j can do all of this for you with its Solidity smart contract wrappers . To understand what is happening behind the scenes, you can refer to the details in Creation of a smart contract . Given that Solidity is the language of choice for writing smart contracts, it is the language supported by Web3j, and is used for all subsequent examples.","title":"Smart Contracts"},{"location":"smart_contracts/smart_contracts_overview/#examples","text":"Please refer to EIP-20 Ethereum token standard smart contract","title":"Examples"},{"location":"smart_contracts/testing_smart_contracts/","text":"Testing Smart Contracts \u00b6 You can test your Web3j app with Web3j-Unit . Usage Add the gradle dependency. repositories { mavenCentral () jcenter () } implementation \"org.web3j:core:4.5.11\" testCompile \"org.web3j:web3j-unit:4.5.11\" Deploy your contract in the test. @EVMTest public class GreeterTest { @Test public void greeterDeploys ( Web3j web3j , TransactionManager transactionManager , ContractGasProvider gasProvider ) { Greeter greeter = Greeter . deploy ( web3j , transactionManager , gasProvider , \"Hello EVM\" ). send () String greeting = greeter . greet (). send () assertEquals ( \"Hello EVM\" , greeting ) } } For more detailed information check the testing section","title":"Testing Smart Contracts"},{"location":"smart_contracts/testing_smart_contracts/#testing-smart-contracts","text":"You can test your Web3j app with Web3j-Unit .","title":"Testing Smart Contracts"},{"location":"transactions/credentials/","text":"Create Credentials \u00b6 There are two ways to create credentials in Web3j. Use Credentials object \u00b6 Credentials.create(ECKeyPair ecKeyPair) Credentials.create(String privateKey, String publicKey) Use WalletUtils functionality \u00b6 The WalletUtils class cna be used to load your credentials from various formats: WalletUtils.loadCredentials(String password,String source) WalletUtils.loadBip39Credentials(String password,String mnemonic) WalletUtils.loadBip39Credentials(String password,String mnemonic) WalletUtils.loadJsonCredentials(String password,String content)","title":"Credentials"},{"location":"transactions/credentials/#create-credentials","text":"There are two ways to create credentials in Web3j.","title":"Create Credentials"},{"location":"transactions/credentials/#use-credentials-object","text":"Credentials.create(ECKeyPair ecKeyPair) Credentials.create(String privateKey, String publicKey)","title":"Use Credentials object"},{"location":"transactions/credentials/#use-walletutils-functionality","text":"The WalletUtils class cna be used to load your credentials from various formats: WalletUtils.loadCredentials(String password,String source) WalletUtils.loadBip39Credentials(String password,String mnemonic) WalletUtils.loadBip39Credentials(String password,String mnemonic) WalletUtils.loadJsonCredentials(String password,String content)","title":"Use WalletUtils functionality"},{"location":"transactions/ethereum_testnets/","text":"Ethereum testnets \u00b6 There are a number of dedicated test networks in Ethereum, which are supported by various clients. Goerli (All clients) Rinkeby (Geth only) Kovan (OpenEthereum only) Ropsten (Geth and OpenEthereum) For development, its recommended you use the Rinkeby or Kovan test networks. This is because they use a Proof of Authority (PoA) consensus mechanism, ensuring transactions and blocks are created in a consistent and timely manner. The Ropsten testnet, although closest to the Mainnet as it uses Proof of Work (PoW) consensus, has been subject to attacks in the past and tends to be more problematic for developers. You can request Ether for the Rinkeby testnet via the Rinkeby Crypto Faucet, available at https://www.rinkeby.io/#faucet . Details of how to request Ether for the Kovan testnet are available here . (This section needs to be changed) If you need some Ether on the Ropsten testnet to get started, please post a message with your wallet address to the Web3j Community Forum and you will be sent some. Mining on testnet/private blockchains \u00b6 In the Ethereum test environment (testnet), the mining difficulty is set lower then the main environment (mainnet). This means that you can mine new Ether with a regular CPU, such as your laptop. What you'll need to do is run an Ethereum client such as Geth, Besu or OpenEthereum to start building up reserves. Further instructions are available on the respective sites. Geth https://geth.ethereum.org/docs/interface/mining Besu https://besu.hyperledger.org/en/stable/Concepts/Mining/ OpenEthereum https://openethereum.github.io/wiki/Mining Once you have mined some Ether, you can start transacting with the blockchain. However, as mentioned above it's simpler to use the Kovan or Rinkeby test networks.","title":"Ethereum Test Networks"},{"location":"transactions/ethereum_testnets/#ethereum-testnets","text":"There are a number of dedicated test networks in Ethereum, which are supported by various clients. Goerli (All clients) Rinkeby (Geth only) Kovan (OpenEthereum only) Ropsten (Geth and OpenEthereum) For development, its recommended you use the Rinkeby or Kovan test networks. This is because they use a Proof of Authority (PoA) consensus mechanism, ensuring transactions and blocks are created in a consistent and timely manner. The Ropsten testnet, although closest to the Mainnet as it uses Proof of Work (PoW) consensus, has been subject to attacks in the past and tends to be more problematic for developers. You can request Ether for the Rinkeby testnet via the Rinkeby Crypto Faucet, available at https://www.rinkeby.io/#faucet . Details of how to request Ether for the Kovan testnet are available here . (This section needs to be changed) If you need some Ether on the Ropsten testnet to get started, please post a message with your wallet address to the Web3j Community Forum and you will be sent some.","title":"Ethereum testnets"},{"location":"transactions/ethereum_testnets/#mining-on-testnetprivate-blockchains","text":"In the Ethereum test environment (testnet), the mining difficulty is set lower then the main environment (mainnet). This means that you can mine new Ether with a regular CPU, such as your laptop. What you'll need to do is run an Ethereum client such as Geth, Besu or OpenEthereum to start building up reserves. Further instructions are available on the respective sites. Geth https://geth.ethereum.org/docs/interface/mining Besu https://besu.hyperledger.org/en/stable/Concepts/Mining/ OpenEthereum https://openethereum.github.io/wiki/Mining Once you have mined some Ether, you can start transacting with the blockchain. However, as mentioned above it's simpler to use the Kovan or Rinkeby test networks.","title":"Mining on testnet/private blockchains"},{"location":"transactions/gas/","text":"Gas \u00b6 When a transaction takes place in Ethereum, a transaction cost must be paid to the client that executes the transaction on your behalf, committing the output of this transaction to the Ethereum blockchain. This cost is measure in gas, where gas is the number of instructions used to execute a transaction in the Ethereum Virtual Machine. Please refer to the Homestead documentation for further information. What this means for you when working with Ethereum clients is that there are two parameters which are used to dictate how much Ether you wish to spend in order for a transaction to complete: Gas price This is the amount you are prepared in Ether per unit of gas. web3j uses a default price of 22,000,000,000 Wei (22 x 10^-8^ Ether). This is defined in ManagedTransaction . Gas limit This is the total amount of gas you are happy to spend on the transaction execution. There is an upper limit of how large a single transaction can be in an Ethereum block which restricts this value typically to less then 6,700,000. The current gas limit is visible at https://ethstats.net/ . These parameters taken together dictate the maximum amount of Ether you are willing to spend on transaction costs. i.e. you can spend no more then gas price * gas limit. The gas price can also affect how quickly a transaction takes place depending on what other transactions are available with a more profitable gas price for miners. You may need to adjust these parameters to ensure that transactions take place in a timely manner. Picking Gas Providers \u00b6 The public Interface ContractGasProvider has two implementations that can be used in order to pass in a gas provider to the deploy method of the contract. The DefaultGasProvider is pre-defined implementation of the ContractGasProvider that has set values for gas price and gas limit. GAS_LIMIT = BigInteger.valueOf(9_000_000); GAS_PRICE = BigInteger.valueOf(4_100_000_000L)); If a more flexible approach is required then the StaticGasProvider can take custom gas price and gas limit values as BigIntegers.","title":"Gas"},{"location":"transactions/gas/#gas","text":"When a transaction takes place in Ethereum, a transaction cost must be paid to the client that executes the transaction on your behalf, committing the output of this transaction to the Ethereum blockchain. This cost is measure in gas, where gas is the number of instructions used to execute a transaction in the Ethereum Virtual Machine. Please refer to the Homestead documentation for further information. What this means for you when working with Ethereum clients is that there are two parameters which are used to dictate how much Ether you wish to spend in order for a transaction to complete: Gas price This is the amount you are prepared in Ether per unit of gas. web3j uses a default price of 22,000,000,000 Wei (22 x 10^-8^ Ether). This is defined in ManagedTransaction . Gas limit This is the total amount of gas you are happy to spend on the transaction execution. There is an upper limit of how large a single transaction can be in an Ethereum block which restricts this value typically to less then 6,700,000. The current gas limit is visible at https://ethstats.net/ . These parameters taken together dictate the maximum amount of Ether you are willing to spend on transaction costs. i.e. you can spend no more then gas price * gas limit. The gas price can also affect how quickly a transaction takes place depending on what other transactions are available with a more profitable gas price for miners. You may need to adjust these parameters to ensure that transactions take place in a timely manner.","title":"Gas"},{"location":"transactions/gas/#picking-gas-providers","text":"The public Interface ContractGasProvider has two implementations that can be used in order to pass in a gas provider to the deploy method of the contract. The DefaultGasProvider is pre-defined implementation of the ContractGasProvider that has set values for gas price and gas limit. GAS_LIMIT = BigInteger.valueOf(9_000_000); GAS_PRICE = BigInteger.valueOf(4_100_000_000L)); If a more flexible approach is required then the StaticGasProvider can take custom gas price and gas limit values as BigIntegers.","title":"Picking Gas Providers"},{"location":"transactions/obtaining_ether/","text":"Obtaining Ether \u00b6 To obtain Ether you have two options: Mine it yourself Mining it yourself in a private environment, or the public test environment (testnet) is very straight forwards. However, in the main live environment (mainnet) it requires significant dedicated GPU time which is not likely to be feasible unless you already have a gaming PC with multiple dedicated GPUs. If you wish to use a private environment, there is some guidance on the Homestead documentation . Obtain Ether from another party Testnet faucets Rinkeby Faucet Ropsten Faucet Kovan Faucet To purchase Ether you will need to go via an exchange. As different regions have different exchanges, you will need to research the best location for this yourself. The Homestead documentation contains a number of exchanges which is a good place to start.","title":"Obtaining Ether"},{"location":"transactions/obtaining_ether/#obtaining-ether","text":"To obtain Ether you have two options: Mine it yourself Mining it yourself in a private environment, or the public test environment (testnet) is very straight forwards. However, in the main live environment (mainnet) it requires significant dedicated GPU time which is not likely to be feasible unless you already have a gaming PC with multiple dedicated GPUs. If you wish to use a private environment, there is some guidance on the Homestead documentation . Obtain Ether from another party Testnet faucets Rinkeby Faucet Ropsten Faucet Kovan Faucet To purchase Ether you will need to go via an exchange. As different regions have different exchanges, you will need to research the best location for this yourself. The Homestead documentation contains a number of exchanges which is a good place to start.","title":"Obtaining Ether"},{"location":"transactions/transaction_mechanisms/","text":"Transaction mechanisms \u00b6 When you have a valid account created with some Ether, there are two mechanisms you can use to transact with Ethereum. Transaction signing via an Ethereum client Offline transaction signing Both mechanisms are supported via web3j. Transaction signing via an Ethereum client \u00b6 In order to transact via an Ethereum client, you first need to ensure that the client you're transacting with knows about your wallet address. You are best off running your own Ethereum client such as Geth/Besu/OpenEthereum in order to do this. Once you have a client running, you can create a wallet via: The Geth Wiki contains a good run down of the different mechanisms Geth supports such as importing private key files, and creating a new account via it's console Alternatively you can use a JSON-RPC admin command for your client, such as personal_newAccount for OpenEthereum (This needs to be changed) or Geth With your wallet file created, you can unlock your account via web3j by first of all creating an instance of web3j that supports Geth/Besu/OpenEthereum admin commands: Admin web3j = Admin . build ( new HttpService ()); Then you can unlock the account, and providing this was successful, send a transaction: PersonalUnlockAccount personalUnlockAccount = web3j . personalUnlockAccount ( \"0x000...\" , \"a password\" ). send (); if ( personalUnlockAccount . accountUnlocked ()) { // send a transaction } Transactions for sending in this manner should be created via EthSendTransaction , with the Transaction type: Transaction transaction = Transaction . createContractTransaction ( < from address > , < nonce > , BigInteger . valueOf ( < gas price > ), // we use default gas limit \"0x...<smart contract code to execute>\" ); org . web3j . protocol . core . methods . response . EthSendTransaction transactionResponse = parity . ethSendTransaction ( ethSendTransaction ) . send (); String transactionHash = transactionResponse . getTransactionHash (); // poll for transaction response via org.web3j.protocol.Web3j.ethGetTransactionReceipt(<txHash>) Where the <nonce> value is obtained as per below Please refer to the integration test DeployContractIT and its superclass Scenario for further details of this transaction workflow. Further details of working with the different admin commands supported by web3j are available in the section Management APIs . Offline transaction signing \u00b6 If you'd prefer not to manage your own Ethereum client, or do not want to provide wallet details such as your password to an Ethereum client, then offline transaction signing is the way to go. Offline transaction signing allows you to sign a transaction using your Ethereum Ethereum wallet within web3j, allowing you to have complete control over your private credentials. A transaction created offline can then be sent to any Ethereum client on the network, which will propagate the transaction out to other nodes, provided it is a valid transaction. You can also perform out of process transaction signing if required. This can be achieved by overriding the sign method in ECKeyPair .","title":"Transction Mechanisms"},{"location":"transactions/transaction_mechanisms/#transaction-mechanisms","text":"When you have a valid account created with some Ether, there are two mechanisms you can use to transact with Ethereum. Transaction signing via an Ethereum client Offline transaction signing Both mechanisms are supported via web3j.","title":"Transaction mechanisms"},{"location":"transactions/transaction_mechanisms/#transaction-signing-via-an-ethereum-client","text":"In order to transact via an Ethereum client, you first need to ensure that the client you're transacting with knows about your wallet address. You are best off running your own Ethereum client such as Geth/Besu/OpenEthereum in order to do this. Once you have a client running, you can create a wallet via: The Geth Wiki contains a good run down of the different mechanisms Geth supports such as importing private key files, and creating a new account via it's console Alternatively you can use a JSON-RPC admin command for your client, such as personal_newAccount for OpenEthereum (This needs to be changed) or Geth With your wallet file created, you can unlock your account via web3j by first of all creating an instance of web3j that supports Geth/Besu/OpenEthereum admin commands: Admin web3j = Admin . build ( new HttpService ()); Then you can unlock the account, and providing this was successful, send a transaction: PersonalUnlockAccount personalUnlockAccount = web3j . personalUnlockAccount ( \"0x000...\" , \"a password\" ). send (); if ( personalUnlockAccount . accountUnlocked ()) { // send a transaction } Transactions for sending in this manner should be created via EthSendTransaction , with the Transaction type: Transaction transaction = Transaction . createContractTransaction ( < from address > , < nonce > , BigInteger . valueOf ( < gas price > ), // we use default gas limit \"0x...<smart contract code to execute>\" ); org . web3j . protocol . core . methods . response . EthSendTransaction transactionResponse = parity . ethSendTransaction ( ethSendTransaction ) . send (); String transactionHash = transactionResponse . getTransactionHash (); // poll for transaction response via org.web3j.protocol.Web3j.ethGetTransactionReceipt(<txHash>) Where the <nonce> value is obtained as per below Please refer to the integration test DeployContractIT and its superclass Scenario for further details of this transaction workflow. Further details of working with the different admin commands supported by web3j are available in the section Management APIs .","title":"Transaction signing via an Ethereum client"},{"location":"transactions/transaction_mechanisms/#offline-transaction-signing","text":"If you'd prefer not to manage your own Ethereum client, or do not want to provide wallet details such as your password to an Ethereum client, then offline transaction signing is the way to go. Offline transaction signing allows you to sign a transaction using your Ethereum Ethereum wallet within web3j, allowing you to have complete control over your private credentials. A transaction created offline can then be sent to any Ethereum client on the network, which will propagate the transaction out to other nodes, provided it is a valid transaction. You can also perform out of process transaction signing if required. This can be achieved by overriding the sign method in ECKeyPair .","title":"Offline transaction signing"},{"location":"transactions/transaction_nonce/","text":"The transaction nonce \u00b6 The nonce is an increasing numeric value which is used to uniquely identify transactions. A nonce can only be used once and until a transaction is mined, it is possible to send multiple versions of a transaction with the same nonce, however, once mined, any subsequent submissions will be rejected. You can obtain the next available nonce via the eth_getTransactionCount method: EthGetTransactionCount ethGetTransactionCount = web3j . ethGetTransactionCount ( address , DefaultBlockParameterName . LATEST ). sendAsync (). get (); BigInteger nonce = ethGetTransactionCount . getTransactionCount (); The nonce can then be used to create your transaction object: RawTransaction rawTransaction = RawTransaction . createEtherTransaction ( nonce , < gas price > , < gas limit > , < toAddress > , < value > );","title":"Transction Nonce"},{"location":"transactions/transaction_nonce/#the-transaction-nonce","text":"The nonce is an increasing numeric value which is used to uniquely identify transactions. A nonce can only be used once and until a transaction is mined, it is possible to send multiple versions of a transaction with the same nonce, however, once mined, any subsequent submissions will be rejected. You can obtain the next available nonce via the eth_getTransactionCount method: EthGetTransactionCount ethGetTransactionCount = web3j . ethGetTransactionCount ( address , DefaultBlockParameterName . LATEST ). sendAsync (). get (); BigInteger nonce = ethGetTransactionCount . getTransactionCount (); The nonce can then be used to create your transaction object: RawTransaction rawTransaction = RawTransaction . createEtherTransaction ( nonce , < gas price > , < gas limit > , < toAddress > , < value > );","title":"The transaction nonce"},{"location":"transactions/transaction_types/","text":"Transaction types \u00b6 The different types of transaction in Web3j work with both Transaction and RawTransaction objects. The key difference is that Transaction objects must always have a from address, so that the Ethereum client which processes the eth_sendTransaction request know which wallet to use in order to sign and send the transaction on the message senders behalf. As mentioned above , this is not necessary for raw transactions which are signed offline. The subsequent sections outline the key transaction attributes required for the different transaction types. The following attributes remain constant for all: Gas price Gas limit Nonce From Transaction and RawTransaction objects are used interchangeably in all of the subsequent examples.","title":"Transction Types"},{"location":"transactions/transaction_types/#transaction-types","text":"The different types of transaction in Web3j work with both Transaction and RawTransaction objects. The key difference is that Transaction objects must always have a from address, so that the Ethereum client which processes the eth_sendTransaction request know which wallet to use in order to sign and send the transaction on the message senders behalf. As mentioned above , this is not necessary for raw transactions which are signed offline. The subsequent sections outline the key transaction attributes required for the different transaction types. The following attributes remain constant for all: Gas price Gas limit Nonce From Transaction and RawTransaction objects are used interchangeably in all of the subsequent examples.","title":"Transaction types"},{"location":"transactions/transactions/","text":"Transactions \u00b6 Broadly speaking there are three types transactions supported on Ethereum: Transfer of Ether from one party to another Creation of a smart contract Transacting with a smart contract To undertake any of these transactions, it is necessary to have Ether (the fuel of the Ethereum blockchain) residing in the Ethereum account which the transactions are taking place from. This is to pay for the Gas costs, which is the transaction execution cost for the Ethereum client that performs the transaction on your behalf, committing the result to the Ethereum blockchain. Instructions for obtaining Ether are described below in Obtaining Ether Additionally, it is possible to query the state of a smart contract, this is described in Querying the state of a smart contract","title":"Ethereum Transactions"},{"location":"transactions/transactions/#transactions","text":"Broadly speaking there are three types transactions supported on Ethereum: Transfer of Ether from one party to another Creation of a smart contract Transacting with a smart contract To undertake any of these transactions, it is necessary to have Ether (the fuel of the Ethereum blockchain) residing in the Ethereum account which the transactions are taking place from. This is to pay for the Gas costs, which is the transaction execution cost for the Ethereum client that performs the transaction on your behalf, committing the result to the Ethereum blockchain. Instructions for obtaining Ether are described below in Obtaining Ether Additionally, it is possible to query the state of a smart contract, this is described in Querying the state of a smart contract","title":"Transactions"},{"location":"transactions/transactions_and_smart_contracts/","text":"Recommended approach for working with smart contracts \u00b6 When working with smart contract wrappers as outlined below, you will have to perform all of the conversions from Solidity to native Java types manually. It is far more effective to use Web3j's Solidity smart contract wrappers which take care of all code generation and this conversion for you. Creation of a smart contract \u00b6 To deploy a new smart contract, the following attributes will need to be provided value the amount of Ether you wish to deposit in the smart contract (assumes zero if not provided) data the hex formatted, compiled smart contract creation code // using a raw transaction RawTransaction rawTransaction = RawTransaction . createContractTransaction ( < nonce > , < gasPrice > , < gasLimit > , < value > , \"0x <compiled smart contract code>\" ); // send... // get contract address EthGetTransactionReceipt transactionReceipt = web3j . ethGetTransactionReceipt ( transactionHash ). send (); if ( transactionReceipt . getTransactionReceipt . isPresent ()) { String contractAddress = transactionReceipt . get (). getContractAddress (); } else { // try again } If the smart contract contains a constructor, the associated constructor field values must be encoded and appended to the compiled smart contract code : String encodedConstructor = FunctionEncoder . encodeConstructor ( Arrays . asList ( new Type ( value ), ...)); // using a regular transaction Transaction transaction = Transaction . createContractTransaction ( < fromAddress > , < nonce > , < gasPrice > , < gasLimit > , < value > , \"0x <compiled smart contract code>\" + encodedConstructor ); // send... Transacting with a smart contract \u00b6 To transact with an existing smart contract, the following attributes will need to be provided: to the smart contract address value the amount of Ether you wish to deposit in the smart contract (if the smart contract accepts ether) data the encoded function selector and parameter arguments Web3j takes care of the function encoding for you, for further details on the implementation refer to the Application Binary Interface section. Function function = new Function <> ( \"functionName\" , // function we're calling Arrays . asList ( new Type ( value ), ...), // Parameters to pass as Solidity Types Arrays . asList ( new TypeReference < Type > () {}, ...)); String encodedFunction = FunctionEncoder . encode ( function ) Transaction transaction = Transaction . createFunctionCallTransaction ( < from > , < gasPrice > , < gasLimit > , contractAddress , < funds > , encodedFunction ); org . web3j . protocol . core . methods . response . EthSendTransaction transactionResponse = web3j . ethSendTransaction ( transaction ). sendAsync (). get (); String transactionHash = transactionResponse . getTransactionHash (); // wait for response using EthGetTransactionReceipt... It is not possible to return values from transactional functional calls, regardless of the return type of the message signature. However, it is possible to capture values returned by functions using filters. Please refer to the Filters and Events section for details. Querying the state of a smart contract \u00b6 This functionality is facilitated by the eth_call JSON-RPC call. eth_call allows you to call a method on a smart contract to query a value. There is no transaction cost associated with this function, this is because it does not change the state of any smart contract method's called, it simply returns the value from them: Function function = new Function <> ( \"functionName\" , Arrays . asList ( new Type ( value )), // Solidity Types in smart contract functions Arrays . asList ( new TypeReference < Type > () {}, ...)); String encodedFunction = FunctionEncoder . encode ( function ) org . web3j . protocol . core . methods . response . EthCall response = web3j . ethCall ( Transaction . createEthCallTransaction ( < from > , contractAddress , encodedFunction ), DefaultBlockParameterName . LATEST ) . sendAsync (). get (); List < Type > someTypes = FunctionReturnDecoder . decode ( response . getValue (), function . getOutputParameters ()); Note: If an invalid function call is made, or a null result is obtained, the return value will be an instance of Collections.emptyList()","title":"Transctions and Smart Contracts"},{"location":"transactions/transactions_and_smart_contracts/#recommended-approach-for-working-with-smart-contracts","text":"When working with smart contract wrappers as outlined below, you will have to perform all of the conversions from Solidity to native Java types manually. It is far more effective to use Web3j's Solidity smart contract wrappers which take care of all code generation and this conversion for you.","title":"Recommended approach for working with smart contracts"},{"location":"transactions/transactions_and_smart_contracts/#creation-of-a-smart-contract","text":"To deploy a new smart contract, the following attributes will need to be provided value the amount of Ether you wish to deposit in the smart contract (assumes zero if not provided) data the hex formatted, compiled smart contract creation code // using a raw transaction RawTransaction rawTransaction = RawTransaction . createContractTransaction ( < nonce > , < gasPrice > , < gasLimit > , < value > , \"0x <compiled smart contract code>\" ); // send... // get contract address EthGetTransactionReceipt transactionReceipt = web3j . ethGetTransactionReceipt ( transactionHash ). send (); if ( transactionReceipt . getTransactionReceipt . isPresent ()) { String contractAddress = transactionReceipt . get (). getContractAddress (); } else { // try again } If the smart contract contains a constructor, the associated constructor field values must be encoded and appended to the compiled smart contract code : String encodedConstructor = FunctionEncoder . encodeConstructor ( Arrays . asList ( new Type ( value ), ...)); // using a regular transaction Transaction transaction = Transaction . createContractTransaction ( < fromAddress > , < nonce > , < gasPrice > , < gasLimit > , < value > , \"0x <compiled smart contract code>\" + encodedConstructor ); // send...","title":"Creation of a smart contract"},{"location":"transactions/transactions_and_smart_contracts/#transacting-with-a-smart-contract","text":"To transact with an existing smart contract, the following attributes will need to be provided: to the smart contract address value the amount of Ether you wish to deposit in the smart contract (if the smart contract accepts ether) data the encoded function selector and parameter arguments Web3j takes care of the function encoding for you, for further details on the implementation refer to the Application Binary Interface section. Function function = new Function <> ( \"functionName\" , // function we're calling Arrays . asList ( new Type ( value ), ...), // Parameters to pass as Solidity Types Arrays . asList ( new TypeReference < Type > () {}, ...)); String encodedFunction = FunctionEncoder . encode ( function ) Transaction transaction = Transaction . createFunctionCallTransaction ( < from > , < gasPrice > , < gasLimit > , contractAddress , < funds > , encodedFunction ); org . web3j . protocol . core . methods . response . EthSendTransaction transactionResponse = web3j . ethSendTransaction ( transaction ). sendAsync (). get (); String transactionHash = transactionResponse . getTransactionHash (); // wait for response using EthGetTransactionReceipt... It is not possible to return values from transactional functional calls, regardless of the return type of the message signature. However, it is possible to capture values returned by functions using filters. Please refer to the Filters and Events section for details.","title":"Transacting with a smart contract"},{"location":"transactions/transactions_and_smart_contracts/#querying-the-state-of-a-smart-contract","text":"This functionality is facilitated by the eth_call JSON-RPC call. eth_call allows you to call a method on a smart contract to query a value. There is no transaction cost associated with this function, this is because it does not change the state of any smart contract method's called, it simply returns the value from them: Function function = new Function <> ( \"functionName\" , Arrays . asList ( new Type ( value )), // Solidity Types in smart contract functions Arrays . asList ( new TypeReference < Type > () {}, ...)); String encodedFunction = FunctionEncoder . encode ( function ) org . web3j . protocol . core . methods . response . EthCall response = web3j . ethCall ( Transaction . createEthCallTransaction ( < from > , contractAddress , encodedFunction ), DefaultBlockParameterName . LATEST ) . sendAsync (). get (); List < Type > someTypes = FunctionReturnDecoder . decode ( response . getValue (), function . getOutputParameters ()); Note: If an invalid function call is made, or a null result is obtained, the return value will be an instance of Collections.emptyList()","title":"Querying the state of a smart contract"},{"location":"transactions/transfer_eth/","text":"Transfer of Ether from one party to another \u00b6 The sending of Ether between two parties requires a minimal number of details of the transaction object: to the destination wallet address value the amount of Ether you wish to send to the destination address BigInteger value = Convert . toWei ( \"1.0\" , Convert . Unit . ETHER ). toBigInteger (); RawTransaction rawTransaction = RawTransaction . createEtherTransaction ( < nonce > , < gas price > , < gas limit > , < toAddress > , value ); // send... However, it is recommended that you use the Transfer class for sending Ether, which takes care of the nonce management and polling for a response for you: Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils . loadCredentials ( \"password\" , \"/path/to/walletfile\" ); TransactionReceipt transactionReceipt = Transfer . sendFunds ( web3 , credentials , \"0x<address>|<ensName>\" , BigDecimal . valueOf ( 1.0 ), Convert . Unit . ETHER ). send ();","title":"Transfer Eth"},{"location":"transactions/transfer_eth/#transfer-of-ether-from-one-party-to-another","text":"The sending of Ether between two parties requires a minimal number of details of the transaction object: to the destination wallet address value the amount of Ether you wish to send to the destination address BigInteger value = Convert . toWei ( \"1.0\" , Convert . Unit . ETHER ). toBigInteger (); RawTransaction rawTransaction = RawTransaction . createEtherTransaction ( < nonce > , < gas price > , < gas limit > , < toAddress > , value ); // send... However, it is recommended that you use the Transfer class for sending Ether, which takes care of the nonce management and polling for a response for you: Web3j web3 = Web3j . build ( new HttpService ()); // defaults to http://localhost:8545/ Credentials credentials = WalletUtils . loadCredentials ( \"password\" , \"/path/to/walletfile\" ); TransactionReceipt transactionReceipt = Transfer . sendFunds ( web3 , credentials , \"0x<address>|<ensName>\" , BigDecimal . valueOf ( 1.0 ), Convert . Unit . ETHER ). send ();","title":"Transfer of Ether from one party to another"},{"location":"transactions/wallet_files/","text":"Creating and working with wallet files \u00b6 In order to sign transactions offline, you need to have either your Ethereum wallet file or the public and private keys associated with an Ethereum wallet/account. web3j is able to both generate a new secure Ethereum wallet file for you, or work with an existing wallet file. To create a new wallet file: String fileName = WalletUtils . generateNewWalletFile ( \"your password\" , new File ( \"/path/to/destination\" )); To load the credentials from a wallet file: Credentials credentials = WalletUtils . loadCredentials ( \"your password\" , \"/path/to/walletfile\" ); These credentials are then used to sign transactions. Please refer to the Web3 Secret Storage Definition for the full wallet file specification. Signing transactions \u00b6 Transactions to be used in an offline signing capacity, should use the RawTransaction type for this purpose. The RawTransaction is similar to the previously mentioned Transaction type, however it does not require a from address, as this can be inferred from the signature. In order to create and sign a raw transaction, the sequence of events is as follows: Identify the next available nonce for the sender account Create the RawTransaction object Encode the RawTransaction object using Recursive Length Prefix encoding Sign the RawTransaction object Send the RawTransaction object to a node for processing The nonce is an increasing numeric value which is used to uniquely identify transactions. A nonce can only be used once and until a transaction is mined, it is possible to send multiple versions of a transaction with the same nonce, however, once mined, any subsequent submissions will be rejected. Once you have obtained the next available nonce , the value can then be used to create your transaction object: RawTransaction rawTransaction = RawTransaction . createEtherTransaction ( nonce , < gas price > , < gas limit > , < toAddress > , < value > ); The transaction can then be signed and encoded: byte [] signedMessage = TransactionEncoder . signMessage ( rawTransaction , < credentials > ); String hexValue = Numeric . toHexString ( signedMessage ); Where the credentials are those loaded as per Creating and working with wallet files The transaction is then sent using eth_sendRawTransaction : EthSendTransaction ethSendTransaction = web3j . ethSendRawTransaction ( hexValue ). sendAsync (). get (); String transactionHash = ethSendTransaction . getTransactionHash (); // poll for transaction response via org.web3j.protocol.Web3j.ethGetTransactionReceipt(<txHash>) Please refer to the integration test CreateRawTransactionIT for a full example of creating and sending a raw transaction.","title":"Wallet Files"},{"location":"transactions/wallet_files/#creating-and-working-with-wallet-files","text":"In order to sign transactions offline, you need to have either your Ethereum wallet file or the public and private keys associated with an Ethereum wallet/account. web3j is able to both generate a new secure Ethereum wallet file for you, or work with an existing wallet file. To create a new wallet file: String fileName = WalletUtils . generateNewWalletFile ( \"your password\" , new File ( \"/path/to/destination\" )); To load the credentials from a wallet file: Credentials credentials = WalletUtils . loadCredentials ( \"your password\" , \"/path/to/walletfile\" ); These credentials are then used to sign transactions. Please refer to the Web3 Secret Storage Definition for the full wallet file specification.","title":"Creating and working with wallet files"},{"location":"transactions/wallet_files/#signing-transactions","text":"Transactions to be used in an offline signing capacity, should use the RawTransaction type for this purpose. The RawTransaction is similar to the previously mentioned Transaction type, however it does not require a from address, as this can be inferred from the signature. In order to create and sign a raw transaction, the sequence of events is as follows: Identify the next available nonce for the sender account Create the RawTransaction object Encode the RawTransaction object using Recursive Length Prefix encoding Sign the RawTransaction object Send the RawTransaction object to a node for processing The nonce is an increasing numeric value which is used to uniquely identify transactions. A nonce can only be used once and until a transaction is mined, it is possible to send multiple versions of a transaction with the same nonce, however, once mined, any subsequent submissions will be rejected. Once you have obtained the next available nonce , the value can then be used to create your transaction object: RawTransaction rawTransaction = RawTransaction . createEtherTransaction ( nonce , < gas price > , < gas limit > , < toAddress > , < value > ); The transaction can then be signed and encoded: byte [] signedMessage = TransactionEncoder . signMessage ( rawTransaction , < credentials > ); String hexValue = Numeric . toHexString ( signedMessage ); Where the credentials are those loaded as per Creating and working with wallet files The transaction is then sent using eth_sendRawTransaction : EthSendTransaction ethSendTransaction = web3j . ethSendRawTransaction ( hexValue ). sendAsync (). get (); String transactionHash = ethSendTransaction . getTransactionHash (); // poll for transaction response via org.web3j.protocol.Web3j.ethGetTransactionReceipt(<txHash>) Please refer to the integration test CreateRawTransactionIT for a full example of creating and sending a raw transaction.","title":"Signing transactions"}]}