{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Web3j","text":"<p>Web3j is a highly modular, reactive, type safe Java and Android library for working with Smart Contracts and integrating with clients (nodes) on the Ethereum network:</p> <p></p> <p>This allows you to work with the Ethereum blockchain, without the additional overhead of having to write your own integration code for the platform.</p> <p>The Java and the Blockchain talk provides an overview of blockchain, Ethereum and web3j.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Complete implementation of Ethereum's JSON-RPC client API over HTTP and IPC</li> <li>Ethereum wallet support</li> <li>Auto-generation of Java smart contract wrappers to create, deploy, transact with and call smart contracts from native Java code (Solidity and Truffle definition formats supported)</li> <li>Reactive-functional API for working with filters</li> <li>Ethereum Name Service (ENS) support</li> <li>Support for OpenEthereum's Personal, and Geth's Personal client APIs</li> <li>Support for Alchemy and Infura, so you don't have to run an Ethereum client yourself</li> <li>Support for ERC20 and ERC721 token standards</li> <li>Support for HSM</li> <li>Comprehensive integration tests demonstrating a number of the above scenarios</li> <li>Command line tools</li> <li>Android compatible</li> <li>Support for JP Morgan's Quorum via     web3j-quorum</li> </ul>"},{"location":"#dependencies","title":"Dependencies","text":"<p>It has five runtime dependencies:</p> <ul> <li>RxJava for its reactive-functional API</li> <li>OKHttp for HTTP connections</li> <li>Jackson Core for fast JSON serialisation/deserialization</li> <li>Bouncy Castle for crypto</li> <li>Jnr-unixsocket for *nix IPC (not available on Android)</li> </ul> <p>It also uses JavaPoet for generating smart contract wrappers</p>"},{"location":"#commercial-support-and-training","title":"Commercial support and training","text":"<p>Commercial support and training is available from Web3 Labs.</p>"},{"location":"command_line_tools/","title":"CLI","text":"<p>A Web3j binary is distributed, providing an interactive command line (CLI). It supports a number of key Web3j project features including the creation of:</p> <ul> <li>Ethereum applications in Java or Kotlin</li> <li>OpenAPI services for Ethereum smart contracts</li> </ul> <p>These projects can then be run by the Web3j CLI either natively as an application binary or within a Docker container.</p> <p>Behind the scenes there are some more granular commands that you can also use, including:</p> <ul> <li>Wallet creation</li> <li>Wallet password management</li> <li>Ether transfer from one wallet to another</li> <li>Generation of Solidity smart contract wrappers</li> <li>Generation of unit tests for Java smart contract wrappers</li> <li>Smart contract auditing</li> <li>Account creation &amp; management</li> </ul>"},{"location":"command_line_tools/#installation","title":"Installation","text":"<p>The simplest way to install the Web3j CLI is via the following script:</p> <pre><code>curl -L get.web3j.io | sh &amp;&amp; source ~/.web3j/source.sh\n</code></pre> <p>You can verify the installation was successful by running <code>web3j -V</code>, which should output as follows:</p> <pre><code>$ web3j -v\n  __          __  _    ____  _                                   \\ \\        / / | |  |___ \\(_)                                  \\ \\  /\\  / /__| |__  __) |_                                   \\ \\/  \\/ / _ \\ '_ \\|__ &lt;| |                                  \\  /\\  /  __/ |_) |__) | |                                  \\/  \\/ \\___|_.__/____/| |                                  _/ |                                  |__/                     \nBY WEB3LABS\nVersion: 1.4.0\n</code></pre> <p>Alternatively you can download the latest CLI release here.</p>"},{"location":"command_line_tools/#project-creation","title":"Project creation","text":"<p>The <code>web3j new</code> and <code>web3j import</code> commands provide a convenient way to create a new Java or Kotlin project, or OpenAPI service using Web3j's Command Line Tools.</p> <p>For Java or Kotlin projects, they provide the following functionality:</p> <ul> <li>Base project creation.</li> <li>Generation of a simple Hello World Solidity contract or import an existing Solidity project from a file or directory.</li> <li>Generation of ERC20 and ERC777 Java projects using : <code>web3j new erc20 | erc777</code></li> <li>Compilation of the Solidity files.</li> <li>Configure the project to use the Gradle build tool.</li> <li>Generate Java smart contract wrappers for all provided Solidity files.</li> <li>Add the required Web3j dependencies, to run and interact with the contracts.</li> <li>Generate unit tests for the Java smart contract wrappers.</li> </ul> <p>In the case of an OpenAPI service, with the command <code>web3j openapi new</code>, Web3j creates a runnable OpenAPI service for deploying and interacting with smart contracts via OpenAPI compliant endpoints with full Swagger documentation provided.</p> <p>Web3j also gives you the ability to do more via:</p> <ul> <li>Base OpenAPI project creation : <code>web3j openapi new</code>.</li> <li>ERC20 and ERC777 OpenAPI project creation : <code>web3j openapi new erc20 | erc777</code></li> <li>Create an OpenAPI project using specific contracts : <code>web3j openapi import</code>.</li> <li>Generate an OpenAPI executable JAR : <code>web3j openapi jar</code>.</li> <li>Generate RESTful endpoints and their implementation : <code>web3j openapi generate</code>.</li> </ul>"},{"location":"command_line_tools/#create-a-new-project","title":"Create a new project","text":"<p>To generate a new project :</p> <pre><code>web3j new [--kotlin|-o &lt;output path&gt;|-n &lt;project name&gt;|-p &lt;package name&gt;] [helloworld|erc20|erc777]\n</code></pre> <p>Where supported <code>new</code> command arguments are as follows:</p> <ul> <li><code>--kotlin</code>   Creation of a new Kotlin project instead of the default Java one</li> <li><code>helloworld</code>   Use a simple Hello World Solidity smart contract (default)</li> <li><code>erc777</code>   Create an ERC777 compliant token</li> <li><code>erc20</code>   Create an ERC20 compliant token</li> </ul> <p>The ERC20 and ERC777 contracts are based on the OpenZeppelin implementations.</p> <p>The <code>project name</code> and <code>package name</code> values must comply with the JVM standards. The project name is also used as the main class name.</p> <p>If no arguments are specified, the default project creation used is:</p> <pre><code>web3j new helloworld\n</code></pre> <p>Details of the created project structure are below.</p>"},{"location":"command_line_tools/#import-an-existing-project","title":"Import an existing project","text":"<p>Similarly, to <code>web3j new</code>, <code>web3j import</code> will create a new  project but with user defined smart contracts. By default a Java project will be generated if no option is provided.</p> <pre><code>web3j import -s &lt;path to solidity sources&gt; [-o &lt;path&gt;|-n &lt;project name&gt;|-p &lt;package name&gt;] -t\n</code></pre> <p>The <code>-s</code> option will work with a single Solidity file or a folder containing Solidity files. The <code>-t</code> option is true by default. By passing <code>-t</code> unit tests will be generated for the Java wrappers.</p> <p>or </p> <pre><code>web3j import </code></pre> <p>Then, you will be prompted to set the Solidity files directory:</p> <pre><code>You will be prompted to answer a series of questions to create your project:\n\n``` shell\n  __          __  _    ____  _                                   \n \\ \\        / / | |  |___ \\(_)                                  \n  \\ \\  /\\  / /__| |__  __) |_                                   \n   \\ \\/  \\/ / _ \\ '_ \\|__ &lt;| |                                  \n    \\  /\\  /  __/ |_) |__) | |                                  \n     \\/  \\/ \\___|_.__/____/| |                                  \n                          _/ |                                  \n                         |__/                     \nBY WEB3LABS\n\nPlease enter the path to your solidity file/folder [Required Field]: \n/path/to/solidity\n...\n</code></pre>"},{"location":"command_line_tools/#running-your-application","title":"Running your application","text":"<p>The <code>web3j run &lt;network&gt;</code> command can be used to run your application on a specify an Ethereum network. Web3j will need the node endpoint the wallet path and the wallet password.</p> <p>To take advantage of this, you simply need to run the following command in your project directory:</p> <p><code>web3j run</code> </p> <p>If you created an OpenAPI service, by default it binds to port 9090 on your host. You can access the SwaggerUI for the service via the URL http://localhost:9090/swagger-ui.</p> <p>However, if you'd like your application to be bundled up as a container instead, simply run:</p> <p><code>web3j docker run [-l] &lt;network&gt; &lt;wallet_path&gt; &lt;wallet_password&gt;</code></p> <p>This will build a container containing your application.</p>"},{"location":"command_line_tools/#environment-variables","title":"Environment variables","text":"<p>A number of properties can be configured for your Web3j applications to customise them at runtime.</p> <p>The following configuration properties can be used for Java or OpenAPI projects:</p> <ul> <li><code>WEB3J_ENDPOINT</code>   Ethereum node URL</li> <li><code>WEB3J_WALLET_PATH</code>   Path to Ethereum wallet</li> <li><code>WEB3J_WALLET_PASSWORD</code>   Ethereum wallet password</li> <li><code>WEB3J_PRIVATE_KEY</code>   Hex-encoded private key string (0x...) </li> </ul> <p>Additionally, for OpenAPI services, the following properties can be used:</p> <ul> <li><code>WEB3J_OPENAPI_NAME</code>   Project name</li> <li><code>WEB3J_OPENAPI_CONTRACT_ADDRESSES</code>   Pre-deployed contract addresses as a map (Contract1=0x...,Contract2=0x...)</li> <li><code>WEB3J_OPENAPI_HOST</code>   Hostname for service, defaults to localhost</li> <li><code>WEB3J_OPENAPI_PORT</code>   Port to bind to, defaults to 9090</li> </ul>"},{"location":"command_line_tools/#running-with-the-java-runtimie-environment-jre","title":"Running with the Java Runtimie Environment (JRE)","text":"<p>These properties can be used as environment variables if running project using the Java JRE:</p> <pre><code>export VAR1=value\n...\njava -jar &lt;app&gt;.jar\n</code></pre> <p>You can find the relevent application binary in the following locations:</p> <p>Java or Kotlin projects:</p> <ul> <li><code>build/libs/&lt;project-name&gt;-0.1.0-all.jar</code></li> </ul> <p>OpenAPI projects</p> <ul> <li><code>build/libs/&lt;projectName&gt;-server-all.jar</code></li> </ul> <p>Or, for OpenAPI, you can generate an executable JAR directly using:</p> <p>```shell script $ web3j openapi jar  <pre><code>### Running with Docker\n\nIf running the built container with Docker, you should use the following syntax to pass in environment variables:\n\n``` shell\ndocker run -e VAR1=value1 -e VAR2=value2 web3app\n</code></pre>"},{"location":"command_line_tools/#running-with-gradle","title":"Running with Gradle","text":"<p>If you wish to use the Gradle build tool to run your application, you should pass in the required variables in using the following syntax, where variable names are in lowercase and understcores are replaced with hyphens in their names.</p> <pre><code>./gradlew run --args=\"--&lt;var1&gt; &lt;value1&gt; --&lt;var2&gt; &lt;value2&gt; ...\"\n</code></pre>"},{"location":"command_line_tools/#generated-javakotlin-project-structure","title":"Generated Java/Kotlin project structure","text":"<p>Your application code and tests will be located in the following project directories:</p> <p>For Java:</p> <ul> <li><code>./src/main/java</code> - Generated Java application code stub</li> <li><code>./src/test/java</code> - Generated Java test code stubs</li> <li><code>./src/main/solidity</code> - Solidity source code</li> </ul> <p>For Kotlin:</p> <ul> <li><code>./src/main/kotlin</code> - Generated Kotlin application code stub</li> <li><code>./src/test/kotlin</code> - Generated Kotlin test code stubs</li> <li><code>./src/main/solidity</code> - Solidity source code</li> </ul> <p>If you need to edit the build file, it is located in the project root directory:</p> <ul> <li><code>./build.gradle</code> - Gradle build configuration file</li> </ul> <p>Additionally, there are the following Gradle artifacts which you can ignore.</p> <ul> <li><code>/gradle</code> - local Gradle installation</li> <li><code>/.gradle</code> - local Gradle cache</li> <li><code>/build</code> - compiled classes including smart contract bindings</li> </ul> <p>If you need to view any of the generated Solidity or contract artifacts, they are available in the following locations.</p> <p>Solidity <code>bin</code> and <code>abi</code> files are located at:</p> <ul> <li><code>./build/resources/main/solidity/</code></li> </ul> <p>The source code for the generated smart contract bindings can be found at:</p> <ul> <li><code>./build/generated/sources/web3j/main/java/&lt;your-package&gt;/generated/contracts</code></li> </ul> <p>The compiled code for the generated smart contracts bindings is available at the below location. These are the artifacts used to deploy, transact and query your smart contracts.</p> <ul> <li><code>./build/classes/java/main/&lt;your-package&gt;/generated/contracts/</code></li> </ul>"},{"location":"command_line_tools/#generated-openapi-project-structure","title":"Generated OpenAPI project structure","text":"<p>Similar to the Java/Kotlin projects. The Solidity files are located in the following <code>./src/main/solidity</code>.</p> <p>Additionally, the generated OpenAPI code resides in <code>./build/generated/sources/web3j/main</code>, and is structured as follows :</p> <ul> <li>Java smart contract wrappers :  <code>java/&lt;package name&gt;/wrappers</code></li> <li>REST endpoints interfaces : <code>kotlin/&lt;package name&gt;/core</code></li> <li>REST endpoints implementations : <code>kotlin/&lt;package name&gt;/server</code></li> <li>SwaggerUI : <code>resources/static/swagger-ui</code></li> </ul>"},{"location":"command_line_tools/#build-commands","title":"Build commands","text":"<p>Web3j projects use the Gradle build tool under the covers. Gradle is a build DSL for JVM projects used widely in Java, Kotlin and Android projects. You shouldn't need to be too concerned with the semantics of Gradle beyond the following build commands:</p> <p>To build the project run:</p> <pre><code>./gradlew build\n</code></pre> <p>To update just the smart contract bindings following changes to the Solidity code run:</p> <pre><code>./gradlew generateContractWrappers\n</code></pre> <p>To update the OpenAPI code, when using an OpenAPI project, following changes to the Solidity code run:</p> <pre><code>./gradlew generateWeb3jOpenApi\n</code></pre> <p>To update the generated SwaggerUI, when using an OpenAPI project, following changes to the Solidity code run:</p> <pre><code>./gradlew generateWeb3jSwaggerUi\n</code></pre> <p>To delete all project build artifacts, creating a clean environment, run:</p> <pre><code>./gradlew clean\n</code></pre>"},{"location":"command_line_tools/#stand-alone-unit-test-generation","title":"Stand-alone unit test generation","text":"<p>When creating a new project or importing solidity contracts, by using:</p> <pre><code>web3j generate tests\n</code></pre> <p>You will be prompted to answer a series of questions to generate your tests:</p> <pre><code>  __          __  _    ____  _                                   \\ \\        / / | |  |___ \\(_)                                  \\ \\  /\\  / /__| |__  __) |_                                   \\ \\/  \\/ / _ \\ '_ \\|__ &lt;| |                                  \\  /\\  /  __/ |_) |__) | |                                  \\/  \\/ \\___|_.__/____/| |                                  _/ |                                  |__/                     \nBY WEB3LABS\n\nPlease enter the path of the generated contract wrappers.\n&lt;source contract wrappers&gt;\nWhere would you like to save your tests.\n&lt;path to tests&gt;\nUnit tests were generated successfully at location: .\n</code></pre> <p>The command can also be used non-interactively</p> <pre><code>web3j generate tests -i &lt;Solidity Java wrappers&gt; -o &lt;output path&gt;\n</code></pre> <p>When adding the path to your Java wrappers make sure you specify the path up to the package root e.g: If a class with name HelloWorld and package name <code>org.com.web3j</code> is located under <code>/home/user/code/myproject/org/com/web3j/HelloWorld.java</code>, the correct way to point to that class is <code>/home/user/code/myproject/</code></p>"},{"location":"command_line_tools/#wallet-tools","title":"Wallet tools","text":"<p>To generate a new Ethereum wallet:</p> <pre><code>$ web3j wallet create\n</code></pre> <p>To update the password for an existing wallet:</p> <pre><code>$ web3j wallet update &lt;walletfile&gt;\n</code></pre> <p>To send Ether to another address:</p> <pre><code>$ web3j wallet send &lt;walletfile&gt; 0x&lt;address&gt;|&lt;ensName&gt;\n</code></pre> <p>When sending Ether to another address you will be asked a series of questions before the transaction takes place. Check below for a full example.</p> <p>The following example demonstrates using Web3j to send Ether to another wallet.</p> <p>With the following input:</p> <pre><code>web3j wallet send &lt;walletfile&gt; 0x&lt;address&gt;|&lt;ensName&gt;\n</code></pre> <p>Web3j proceeds as follows:</p> <pre><code>  __          __  _    ____  _                                   \\ \\        / / | |  |___ \\(_)                                  \\ \\  /\\  / /__| |__  __) |_                                   \\ \\/  \\/ / _ \\ '_ \\|__ &lt;| |                                  \n    \\  /\\  /  __/ |_) |__) | |                                  \n     \\/  \\/ \\___|_.__/____/| |                                  \n                          _/ |                                  \n                         |__/                     \nBY WEB3LABS\n\nPlease enter your existing wallet file password:\nWallet for address 0x19e03255f667bdfd50a32722df860b1eeaf4d635 loaded\nPlease confirm address of running Ethereum client you wish to send the transfer request to [http://localhost:8545/]:\nConnected successfully to client: Geth/v1.4.18-stable-c72f5459/darwin/go1.7.3\nWhat amound would you like to transfer (please enter a numeric value): 0.000001\nPlease specify the unit (ether, wei, ...) [ether]:\nPlease confim that you wish to transfer 0.000001 ether (1000000000000 wei) to address 0x9c98e381edc5fe1ac514935f3cc3edaa764cf004\nPlease type 'yes' to proceed: yes\nCommencing transfer (this may take a few minutes)...................................................................................................................$\n\nFunds have been successfully transferred from 0x19e03255f667bdfd50a32722df860b1eeaf4d635 to 0x9c98e381edc5fe1ac514935f3cc3edaa764cf004\nTransaction hash: 0xb00afc5c2bb92a76d03e17bd3a0175b80609e877cb124c02d19000d529390530\nMined block number: 1849039\n</code></pre>"},{"location":"command_line_tools/#auditing-tools","title":"Auditing Tools","text":"<p>Smart contracts written in Solidity often include logic bugs and other issues which might compromise their security. These are not always obvious to programmers. Issues can include integer precision problems, re-entrancy attacks, and many other flaws. As Ethereum smart contracts are immutable once they have been deployed, it is important that they are bug-free at this point. Web3j is able to audit smart contracts for certain common issues and vulnerabilities using static code analysis. </p> <p>To audit a smart contract (in this instance, Campaign.sol):</p> <pre><code>$ web3j audit Campaign.sol\n</code></pre> <p>An example of the output from this command is as follows:</p> <pre><code>  __          __  _    ____  _                                   \\ \\        / / | |  |___ \\(_)                                  \\ \\  /\\  / /__| |__  __) |_                                   \\ \\/  \\/ / _ \\ '_ \\|__ &lt;| |                                  \\  /\\  /  __/ |_) |__) | |                                  \\/  \\/ \\___|_.__/____/| |                                  _/ |                                  |__/                     \nBY WEB3LABS\n\n./Campaign.sol\n   131:58   severity:2   Multiplication after division                  SOLIDITY_DIV_MUL_09hhh1                              91:8     severity:1   Revert inside the if-operator                  SOLIDITY_REVERT_REQUIRE_c56b12                       5:4      severity:1   Use of SafeMath                                SOLIDITY_SAFEMATH_837cac                             148:4    severity:1   Replace multiple return values with a struct   SOLIDITY_SHOULD_RETURN_STRUCT_83hf3l                 125:4    severity:1   Prefer external to public visibility level     SOLIDITY_UNUSED_FUNCTION_SHOULD_BE_EXTERNAL_73ufc1   \n\n\u2716 5 problems (5 errors)\n</code></pre> <p>The output is in the form of a list of issues/errors detected by the static analysis tool. The first column of output shows the line and the character at which the issue was encountered. The second column shows the severity; this ranges from 1 to 3, with 3 being the most severe. The next column contains a description of the issue found, and the final column provides a reference to the rule used to find the issue.</p> <p>This functionality is provided by SmartCheck.</p>"},{"location":"command_line_tools/#solidity-smart-contract-wrapper-generator","title":"Solidity smart contract wrapper generator","text":"<p>Please refer to solidity smart contract wrappers.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#install-web3j","title":"Install Web3j","text":"<p>To start using Web3j you have two options:</p>"},{"location":"quickstart/#use-web3j-cli","title":"Use Web3j CLI","text":"<p>This is the recommended option for full project creation.</p>"},{"location":"quickstart/#install-web3j-cli","title":"Install Web3j CLI","text":"<p>To install the command line tools you can follow these instructions.</p>"},{"location":"quickstart/#create-a-new-project","title":"Create a new project","text":"<p><code>$ web3j new</code></p> <p>This will create a sample project to get you started. </p> <p>It includes a <code>HelloWorld</code> smart contract and boilerplate code that is easy to follow.</p>"},{"location":"quickstart/#run-your-project","title":"Run your project","text":"<p>Then run the project with the command <code>web3j run &lt;network_url&gt; &lt;wallet_path&gt; &lt;wallet_password&gt;</code>. You can also provide custom parameters to run your project locally.</p>"},{"location":"quickstart/#use-web3j-plugins","title":"Use Web3j plugins","text":"<p>To generate Java Wrappers for Solidity Contracts in your project, you need to add one of the Web3j's plugins available for Maven and Gradle.</p>"},{"location":"quickstart/#gradle-plugin","title":"Gradle plugin","text":"<p>To add the Gradle plugin to your project:</p> <pre><code>plugins {\n    id \"org.web3j\" version \"4.9.7\"\n}\n</code></pre> <p>Once the plugin is downloaded you should see a new set of tasks under the Web3j label:</p> <p></p> <p>The simplest way is to create a new folder <code>src/main/solidity</code> and place your smart contracts there. To generate the Java wrappers simply run generateContractWrappers or <code>./gradlew/generateContractWrappers</code>. The wrappers will generate under <code>build/generated/source/web3j/main/java</code>. </p>"},{"location":"quickstart/#maven-plugin","title":"Maven plugin","text":"<p>To add the Maven plugin to your project:</p> <pre><code>&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.web3j&lt;/groupId&gt;\n            &lt;artifactId&gt;web3j-maven-plugin&lt;/artifactId&gt;\n            &lt;version&gt;4.8.1&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;soliditySourceFiles/&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre>"},{"location":"quickstart/#use-web3j","title":"Use Web3j","text":""},{"location":"quickstart/#deploying-a-smart-contract","title":"Deploying a Smart Contract","text":"<p>To deploy the HelloWorld contract from the previous example:</p> <pre><code>  Web3j web3j = Web3j.build(new HttpService(\"&lt;your_node_url&gt;\"));\nHelloWorld helloWorld = HelloWorld.deploy(web3j, Credentials.create(\"your_private_key\"), new DefaultGasProvider(), \"Hello Blockchain World\").send();\nString greeting = helloWorld.greeting().send();\nweb3j.shutdown();\n</code></pre> <p>There are many ways to create <code>Credentials</code> in Web3j, for more information go to the credentials section.</p>"},{"location":"quickstart/#loading-a-smart-contract","title":"Loading a Smart Contract","text":"<p>If you have already deployed a contract and would like to interact with it through web3j then the Java Wrappers or your smart contract have a load method.</p> <pre><code> Web3j web3j = Web3j.build(new HttpService(\"&lt;your_node_url&gt;\"));\nString greeting;\nHelloWorld helloWorld = HelloWorld.load(\"your_contract_address\", web3j, Credentials.create(\"your_private_key\"), new DefaultGasProvider());\nif (helloWorld.isValid()) {\ngreeting = helloWorld.greeting().send();\n}\nweb3j.shutdown();\n</code></pre> <p>It is important that the loaded contract is checked using the <code>isValid()</code> method. This method will return false if the contract's bytecode does not match with the deployed one.</p>"},{"location":"web3j_eth2_client/","title":"Web3j Beacon Node API Client","text":"<p>The Beacon Node API client is a thin library that will allow you to interact fluently with the new Eth2 nodes using the methods available in the Eth2.0-API specification, including event subscriptions. As a Web3j library we've kept everything as simple as possible for users to get them on their way quickly.</p> <p>In this chapter we'll guide you through the few steps required to get your application interacting with any Eth2 Beacon Chain Node.</p>"},{"location":"web3j_eth2_client/#getting-started","title":"Getting started","text":"<p>First, you\u2019ll need to add the library to your project, either using Maven:</p> <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;org.web3j.eth2&lt;/groupId&gt;\n&lt;artifactId&gt;beacon-node-api&lt;/artifactId&gt;\n&lt;version&gt;1.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>or Gradle:</p> <pre><code>implementation 'org.web3j.eth2:beacon-node-api:1.0.0'\n</code></pre> <p>At the moment of writing this, the first released version 1.0.0 corresponds to the Eth2 specification v0.12.2. Check the project releases page for the last available version.</p> <p>Once you have added the library to your project, you can create a client instance pointing to a particular Beacon Chain node in a familiar Web3j-esque way:</p> <pre><code>var service = new BeaconNodeService(\"http://...\");\nvar client = BeaconNodeClientFactory.build(service);\n</code></pre> <p>That\u2019s it! At this point, you can start calling the node endpoints, for instance to retrieve the head block:</p> <pre><code>client.getBeacon().getBlocks().findById(NamedBlockId.HEAD);\n</code></pre> <p>Or to retrieve all current attester slashings:</p> <pre><code>client.getBeacon().getPool()\n.getAttesterSlashings()\n.findAll();\n</code></pre> <p>If you don\u2019t know a Beacon Chain node where you can point your client code, in the next section we'll guide you through a few simple steps to get a test network up and running.</p>"},{"location":"web3j_eth2_client/#start-a-test-network","title":"Start a test network","text":"<p>In this section we\u2019ll be using the Teku Beacon Chain implementation to start a local test network where to point your client code (before this, make sure you are running a Docker environment).</p> <p>First, clone the Teku project in a local folder:</p> <pre><code>$ git clone https://github.com/ConsenSys/teku.git\n</code></pre> <p>Then start the Beacon Chain local network (check the Teku docs for more information on the Docker Testnet):</p> <pre><code>$ teku/test-network/launch.sh\nRecreating test-network_teku1_1       ... done\nStarting test-network_prometheus_1    ... done\nStarting test-network_node-exporter_1 ... done\nRecreating test-network_teku4_1       ... done\nRecreating test-network_teku2_1       ... done\nRecreating test-network_teku3_1       ... done\nStarting test-network_grafana_1       ... done\n</code></pre> <p>You\u2019ll get a bunch of logs, but once your network has completely started you\u2019ll be able to point to any of the four nodes at ports <code>19601</code>, <code>19602</code>, <code>19603</code> and <code>19604</code>.</p>"},{"location":"web3j_eth2_client/#listen-for-events","title":"Listen for events","text":"<p>Let\u2019s create a client and listen to some events happening in the test network:</p> <pre><code>var service = new BeaconNodeService(\"http://localhost:19601/\");\nvar client = BeaconNodeClientFactory.build(service);\n\n// We want to receive at least one event\nvar latch = new CountDownLatch(1);\n\n// At the moment we are interested in any topic\nvar topics = EnumSet.allOf(BeaconEventType.class);\n\n// Then subscribe to each event\nclient.getEvents().onEvent(topics, event -&gt; {\nSystem.out.println(\"Received event: \" + event);\nlatch.countDown();\n});\n\n// Wait for the event\nlatch.await();\n</code></pre> <p>When running this code, you should be able to see some logs showing the interaction between your client and the local node:</p> <pre><code>00:15:47.744 [jersey-client-async-executor-0] DEBUG org.web3j.eth2.api.BeaconNodeService - 2 * Sending client request on thread jersey-client-async-executor-0\n2 &gt; GET http://localhost:19601/eth/v1/events?topics=head%2Cblock%2Cattestation%2Cvoluntary_exit%2Cfinalized_checkpoint%2Cchain_reorg\n2 &gt; Accept: text/event-stream\n\n00:15:51.420 [jersey-client-async-executor-0] DEBUG org.web3j.eth2.api.BeaconNodeService - 2 * Client response received on thread jersey-client-async-executor-0\n2 &lt; 200\n2 &lt; Cache-Control: no-cache\n2 &lt; Connection: close\n2 &lt; Content-Type: text/event-stream;charset=utf-8\n2 &lt; Date: Thu, 10 Dec 2020 23:15:47 GMT\n2 &lt; Server: Javalin\nevent: head\ndata: {\"slot\":\"33207\",\"block\":\"0x1829e81553bb76ed92a7ae2d671e018b219b7eeee0cea80fac12b2a7d6924826\",\"state\":\"0xe7339bff5fbb2a30f039a900532cb936e6afbd40ef1fd41cb645687659d8833a\",\"epoch_transition\":false,\"previous_duty_dependent_root\":\"0xd34981d5ab59d4d091992099cedea95236dfcc2252f55f53e282ee847fb426e8\",\"current_duty_dependent_root\":\"0x626db3e484c19fa8f0c57ca6c390bfa8a61313564d61f4c68764239a4e0c966e\"}\n</code></pre> <p>As you can see, when running this example the first event we received was a head event. This happens after a validator committee attests for a head block at every slot (typically every few seconds).</p> <p>You can easily modify the above example to work with other topics such as epoch finality checkpoints, validator attestations or new blocks by specifying different sets of Beacon event types.</p>"},{"location":"web3j_evm/","title":"Web3j EVM","text":"<p>Web3j-evm is an embedded freestanding Ethereum EVM and ledger running within a Java process, which can be used for unit and integration testing your Web3j projects.</p> <p>As everything is local and in-process, there is no need to start up external Ethereum nodes, which helps with easy of use and performance.</p> <p>Everything runs within the JVM process, including EVM bytecode, which allows for easy debugging of Solidity smart contracts.</p>"},{"location":"web3j_evm/#getting-started","title":"Getting started","text":"<p>Often you'd use this together with the web3j-unit project, allowing you to run unit and integration tests without the need to start an Ethereum node.</p> <p>If you want to use this within our own project directly, you would need the EVM dependency + a few external libraries. Have a look at the example project on how to do this.</p> <pre><code>repositories {\nmavenCentral()\njcenter()\n}\n\ndependencies {\nimplementation \"org.web3j:core:4.9.7\"\nimplementation \"org.web3j:web3j-evm:4.9.7\"\n}\n</code></pre> <p>Below is a simple demonstration of ETH transactions, contract deployment and simple contract interactions. Using the ConsoleDebugTracer, we're able to step through the EVM bytecode, inspect the stack and also see where in the related solidity code we're currently at.</p> <p>The demo also shows to how to get started with the <code>EmbeddedWeb3jService</code> which is what you'd use when building your web3j instance.</p> <p>This demo is available on the example project.</p> <p></p>"},{"location":"web3j_evm/#debugging-smart-contracts-and-transactions","title":"Debugging smart contracts and transactions","text":"<p>While running locally with the embedded EVM it is possible to debug the internal state when deploying and invoking functions on a contract.</p> <p>You do this by giving the embedded Web3j service what's called an operation tracer. We have developed one which allows for console-based debugging sessions and code walkthroughs called <code>ConsoleDebugTracer</code>.</p> <p>To enable this simply pass an instance of this in as a second parameter on the <code>EmbeddedWeb3jService</code> constructor.</p> <pre><code>OperationTracer operationTracer = new ConsoleDebugTracer();\n\nWeb3j web3j = Web3j.build(new EmbeddedWeb3jService(configuration, operationTracer));\n</code></pre> <p>When your project leverages our gradle plugin the <code>ConsoleDebugTracer</code> will automatically pick up Solidity contract metadata and use that to display source code context. Usually, these metadata json files are stored within <code>build/resources/main/solidity</code>. If you have chosen to place these elsewhere you will need to specify their location when creating the debugger instance:</p> <pre><code>OperationTracer operationTracer = new ConsoleDebugTracer(new File(\"alternative/metadata/file/location\"));\n</code></pre>"},{"location":"web3j_evm/#options-while-debugging","title":"Options while debugging","text":"<p>The <code>ConsoleDebugTracer</code> allows you to interact with the debugging session using your terminal. Several options are available as shown below. You can also see these in the terminal by using the <code>help</code> option.</p> Command line option Description [enter] Continue running until next code section. [number] Step forward X number of opcodes. next Run until the next breakpoint. end Run until the end of current transaction. abort Terminate the function call. show|hide opcodes Show or hide opcodes. show|hide stack Show or hide the stack. break [file name] [line number] Add or remove a breakpoint. break list Show all breakpoint. break clear Remove all breakpoint. <p>For example, assume I'm debugging a Solidity contract with its source code stored in a file called Greeter.sol.</p> <p>If I want to have the debugger stop at a specific line in that file I'd add a breakpoint with the break option: <code>break Greeter.sol 13</code>. Hitting enter after adding that breakpoint will make the debugger progress until it reaches line 13 in Greeter.sol.</p> <p>Likewise, if I only want to see the Solidity source code and don't care to see opcodes and the stack, I'd execute the <code>hide opcodes</code> and <code>hide stack</code> commands.</p>"},{"location":"web3j_evm/#embedded-ethereum","title":"Embedded Ethereum","text":"<p>Usually when interacting with Ethereum you do so by connecting to an Ethereum node. This node can either be hosted externally, or it might be one you've started locally.</p> <p>In either case, you need to connect to another process to make transactions, deploy contracts or interact with these contracts. This brings with it a few drawbacks:</p> <ul> <li> <p>You need to manage this external dependency, either through connection configuration or through a separate local application</p> </li> <li> <p>Communication between your JVM, which runs your Web3j integrations, and this external Ethereum process breaks the flow and adds lag</p> </li> </ul> <p>While sometimes you do want this external dependency, for example when you are doing transactions on Ethereum mainnet or a testnet, it is often unwanted while doing local development.</p> <p>The Web3j EVM library solves this by providing an embedded EVM and associated ledger. This EVM runs within the same JVM as your code, freeing you from needing to make external connections. No other processes are needed as the EVM and the ledger are themselves coded in Java, and the Web3j EVM is simply used as a library within your code.</p> <p>If you want to use this feature within your unit and integration tests, we would recommend you explore the Web3j unit library as that provides a more complete testing experience.</p>"},{"location":"web3j_evm/#how-to-run-web3j-with-embedded-evm","title":"How to run Web3j with embedded EVM","text":"<p>As shown in the EVM example project, using the embedded EVM is as easy as adding required dependencies and then use the <code>EmbeddedWeb3jService</code>.</p> <pre><code>repositories {\nmavenCentral()\njcenter()\n}\n\ndependencies {\nimplementation \"org.web3j:core:$web3jVersion\"\nimplementation \"org.web3j:web3j-evm:$web3jVersion\"\n}\n</code></pre> <pre><code>Web3j web3j = Web3j.build(new EmbeddedWeb3jService(configuration));\n</code></pre> <p>The configuration given to the embedded Web3j service includes the address you want to make your own and also how much test Ether you want to pre-fund on this account.</p> <p>Assuming you have a Web3j wallet already, you can create this configuration object as shown next:</p> <pre><code>Credentials credentials = WalletUtils.loadCredentials(\"Wallet password\", \"wallet.json\");\n\nConfiguration configuration = new Configuration(new Address(credentials.getAddress()), 10);\n</code></pre> <p>With this configured you can now use your Web3j instance as normal.</p>"},{"location":"web3j_openapi/","title":"Web3j-OpenAPI","text":"<p>Web3j-OpenAPI is an OpenAPI client and server generator from Solidity smart contracts. It provides a way to interact with the Ethereum smart contracts using a simple RESTful API. These interactions can be done using plain HTTP requests  or via the Swagger-UI,  which is generated with every project.</p> <p>This workflow can be summed in the following steps:</p> <ul> <li> <p>Writing a Solidity smart contract</p> </li> <li> <p>Generating the corresponding Web3j-OpenAPI project using Web3j-CLI</p> </li> <li> <p>Running the generated project as a standalone server</p> </li> <li> <p>Sending HTTP requests using the <code>Swagger-UI</code>, <code>Java/Kotlin</code> client, <code>Curl</code> or other.</p> </li> </ul>"},{"location":"web3j_openapi/#example","title":"Example","text":"<p>The following Hello World contract :</p> <pre><code>// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.0;\n\n// Modified Greeter contract. Based on example at https://www.ethereum.org/greeter.\n\ncontract Mortal {\n    /* Define variable owner of the type address*/\n    address owner;\n\n    /* this function is executed at initialization and sets the owner of the contract */\n    constructor () {owner = msg.sender;}\n\n    modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"Only owner can call this function.\"\n        );\n        _;\n    }\n\n    /* Function to recover the funds on the contract */\n    function kill() onlyOwner public {selfdestruct(msg.sender);}\n}\n\ncontract HelloWorld is Mortal {\n    /* define variable greeting of the type string */\n    string greet;\n\n    /* this runs when the contract is executed */\n    constructor (string memory _greet) {\n        greet = _greet;\n    }\n\n    function newGreeting(string memory _greet) onlyOwner public {\n        emit Modified(greet, _greet, greet, _greet);\n        greet = _greet;\n    }\n\n    /* main function */\n    function greeting() public view returns (string memory)  {\n        return greet;\n    }\n\n    event Modified(\n        string indexed oldGreetingIdx, string indexed newGreetingIdx,\n        string oldGreeting, string newGreeting);\n}\n</code></pre> <p>generates the following <code>OpenAPI</code> specs : </p> <pre><code>{\n   \"openapi\":\"3.0.1\",\n   \"info\":{\n      \"title\":\"Web3j OpenApi\",\n      \"contact\":{\n         \"name\":\"Web3 Labs\",\n         \"url\":\"http://web3labs.com\",\n         \"email\":\"hi@web3labs.com\"\n      },\n      \"version\":\"4.9.7\"\n   },\n   \"tags\":[\n      {\n         \"name\":\"default\",\n         \"description\":\"Lists existing contracts and events\"\n      },\n      {\n         \"name\":\"HelloWorld Methods\",\n         \"description\":\"List HelloWorld method&amp;#39;s calls\"\n      },\n      {\n         \"name\":\"HelloWorld Events\",\n         \"description\":\"List HelloWorld event&amp;#39;s calls\"\n      }\n   ],\n   \"paths\":{\n      \"/Web3App/contracts/helloworld/{contractAddress}/Kill\":{\n         \"get\":{\n            \"tags\":[\n               \"HelloWorld Methods\"\n            ],\n            \"summary\":\"Execute the Kill method\",\n            \"operationId\":\"kill\",\n            \"parameters\":[\n               {\n                  \"name\":\"contractAddress\",\n                  \"in\":\"path\",\n                  \"required\":true,\n                  \"schema\":{\n                     \"type\":\"string\"\n                  }\n               }\n            ],\n            \"responses\":{\n               \"default\":{\n                  \"description\":\"default response\",\n                  \"content\":{\n                     \"application/json\":{\n                        \"schema\":{\n                           \"$ref\":\"#/components/schemas/TransactionReceiptModel\"\n                        }\n                     }\n                  }\n               }\n            }\n         }\n      },\n...\n</code></pre> <p>With a corresponding <code>Swagger-UI</code> :  </p> <p>The available methods are:</p> <p></p> <p>The available events are:</p> <p></p>"},{"location":"web3j_openapi/#getting-started-with-web3j-openapi","title":"Getting started with Web3j-OpenAPI","text":""},{"location":"web3j_openapi/#generate-a-project","title":"Generate a project","text":"<p>To generate an OpenAPI project using the Web3j-OpenAPI generator, you need to have the Web3j-CLI installed on your machine.  It\u2019s easy to do (for Windows instructions head here):</p> <pre><code>$ curl -L get.web3j.io | sh\n</code></pre> <p>Then, you can run the</p> <pre><code>$ web3j openapi import --help\n</code></pre> <p>To check the generator available options. </p> <p></p> <p>In this case, we will be using the above Hello World contract.</p> <p>Put that contract in a file named <code>HelloWorld.sol</code> for starters.</p> <p>Then, execute the following command: </p> <pre><code>$ web3j openapi import \\\n    -s=HelloWorld.sol \\\n    --package=com.tutorial \\\n    --project-name=HelloWorldProject \\\n    --output-dir=. \n</code></pre> <p>You should be seeing logs similar to the following: </p>"},{"location":"web3j_openapi/#configure-the-project","title":"Configure the project","text":"<p>You can run the project easily, without specifying any configuration, using the Web3j-cli.</p> <p>If not, you need to specify runtime parameters. for example, the <code>private key</code> or <code>wallet file</code> for the signing, the <code>node endpoint</code> to connect to, etc.</p> <p>To see the available options, run the distributions <code>executable</code> or the <code>JAR</code> with the <code>--help</code> flag. You'll get the following display:</p> <p></p> <p>To specify these parameters, you can set the following environment variables:</p> <pre><code>$ export WEB3J_ENDPOINT=&lt;link_to_your_Ethereum_node&gt;\n$ export WEB3J_PRIVATE_KEY=&lt;your_private_key&gt;\n$ export WEB3J_OPENAPI_HOST=localhost\n$ export WEB3J_OPENAPI_PORT=9090\n</code></pre> <p>For more ways to pass these parameters, check the configuration section below.</p>"},{"location":"web3j_openapi/#run-the-project","title":"Run the project","text":"<p>We can run the project directly : </p> <pre><code>$ ./gradlew run\n</code></pre> <p>You should be able to run the server and see the following:</p> <p></p>"},{"location":"web3j_openapi/#interact-with-the-generated-project","title":"Interact with the generated project","text":"<p>Interactions can be done in multiple ways : </p>"},{"location":"web3j_openapi/#swaggerui","title":"SwaggerUI","text":"<p>The generated <code>SwaggerUI</code> is located on <code>{host}:{port}/swagger-ui</code> and can be used to do all possible interactions with the API. eg:</p> <p></p>"},{"location":"web3j_openapi/#http-requests","title":"HTTP requests","text":"<p>Sending HTTP requests via tools like <code>Curl</code>:</p> <pre><code>$ curl -X POST \"http://{host}:{port}/HelloWorldProject/contracts/helloworld/{contract address}/NewGreeting\" -H \"accept: application/json\" -H \"Content-Type: application/json\" -d \"{\\\"_greet\\\":\\\"Hello Web3j-OpenAPI\\\"}\"\n</code></pre>"},{"location":"web3j_openapi/#client-application","title":"Client application","text":"<p>It is also possible to interact using a Java/Kotlin client application.  This latter can be done using our client implementation.</p> <p>Make sure to add the client dependency to your project.</p> <pre><code>dependencies {\nimplementation \"org.web3j.openapi:web3j-openapi-client:4.9.7\"\n}\n</code></pre> <p>Then, you will be able to interact with the API as follows:</p> <pre><code>val service = ClientService(\"http://localhost:9090\")\nval helloWorldProject = ClientFactory.create(HelloWorldProjectApi::class.java, service)\n\nprintln(\"Deploying the HelloWorld contract...\")\n\nval receipt = helloWorldProject.contracts.helloWorld.deploy(HelloWorldDeployParameters(\"Hello\"))\n\nprintln(\"Deployed contract address: ${receipt.contractAddress}\")\n\nval newGreetingHash = helloWorldProject.contracts\n    .helloWorld\n    .load(receipt.contractAddress)\n    .newGreeting(NewGreetingParameters(\"Hello Web3j-OpenAPI\"))\n    .transactionHash\n\nprintln(\"NewGreeting method execution transaction hash: $newGreetingHash\")\n\nval greeting = helloWorldProject.contracts\n    .helloWorld\n    .load(receipt.contractAddress)\n    .greeting()\n    .result\n\nprintln(\"Greeting method result: $greeting\")\n</code></pre>"},{"location":"web3j_openapi/#ways-to-generate-an-openapi-project","title":"Ways to generate an OpenAPI project","text":"<p>First, you need to install the Web3j-CLI on your  machine. </p> <p>It\u2019s easy to do (for Windows instructions head here):</p> <pre><code>$ curl -L get.web3j.io | sh\n</code></pre>"},{"location":"web3j_openapi/#generate-a-hello-world-project","title":"Generate a Hello World project","text":"<p>A Hello World project is a simple project based on a simple Solidity contract. It is generated using:</p> <pre><code>$ web3j openapi new\n</code></pre> <p>This project can be used as a minimal project to start building your custom application upon.</p>"},{"location":"web3j_openapi/#generate-using-custom-solidity-smart-contracts","title":"Generate using custom Solidity smart contracts","text":"<p>To generate a project using your desired smart contracts, use the following command:</p> <pre><code>$ web3j openapi import \\\n    --solidity-path &lt;path_to_Solidity_contracts&gt; \\\n    --project-name &lt;project name&gt; \\\n    --package &lt;package name&gt;\n</code></pre>"},{"location":"web3j_openapi/#generate-an-executable-jar","title":"Generate an executable JAR","text":"<p>The following command will generate an executable JAR ready to be run: </p> <pre><code>$ web3j openapi jar \\\n    --solidity-path &lt;path_to_Solidity_contracts&gt;\n</code></pre>"},{"location":"web3j_openapi/#generate-the-rest-api-only","title":"Generate the REST API only","text":"<p>To generate only the API, ie the defined endpoints with their implementations, use the following:</p> <pre><code>$ web3j openapi generate \\\n    --solidity-path &lt;path_to_Solidity_contracts&gt; \\\n    --with-implementations=true\n</code></pre> <p>This command will not generate a whole project structure. Thus, you will not have a runnable application. To have one, check the above sections.</p> <p>The <code>with-implementations</code> flag is set to <code>true</code> by default. This means that  the RESTful endpoints will be generated along their implementations. </p> <p>If you prefer to generate only the interfaces. Set that flag to <code>false</code>: </p> <pre><code>--with-implementations=false\n</code></pre>"},{"location":"web3j_openapi/#generate-using-the-web3j-openapi-gradle-plugin","title":"Generate using the web3j-openapi-gradle-plugin","text":"<p>It is possible to generate a Web3j-OpenAPI project directly from your <code>gradle</code> project using the <code>web3j-openapi-gradle-plugin</code>.  Check the documentation for more information.</p>"},{"location":"web3j_openapi/#run-the-project_1","title":"Run the project","text":""},{"location":"web3j_openapi/#runtime-parameters","title":"Runtime parameters","text":"<p>Before running the server, there are some parameters that need to be set. There are multiple ways of doing so:</p> <ul> <li>Environment variables</li> <li>Configuration file</li> <li>Passing the parameters directly to the JAR or the executable.</li> </ul> <p>Also, you can run the project without worrying about any of this using the Web3j-cli</p>"},{"location":"web3j_openapi/#supported-parameters","title":"Supported parameters","text":"Name Default value Description <code>name</code> <code>Generation project name</code> The project name <code>config file</code> <code>~/.web3j/web3j.openapi.&lt;extension&gt;</code> A custom configuration file to import extra parameters <code>endpoint</code> <code>none</code> Ethereum node endpoint to target when interacting with the blockchain <code>private key</code> <code>none</code> User private key in hex format prefixed by <code>0x</code> <code>wallet path</code> <code>none</code> The path to the wallet file (can be absolute or relative) <code>wallet password</code> <code>none</code> The password of the specified wallet file in plain text <code>host</code> <code>localhost</code> The server host (can be an IP address or a hostname) <code>port</code> <code>8080</code> The server port <code>contract addresses</code> <code>none</code> Use pre-deployed contract addresses: <code>contract1=0x123,contract2=0x1234</code>. All you need to provide to the generator is the ABIs. <p>The necessary parameters are:</p> <ul> <li> <p>The Ethereum node endpoint to target when  interacting with the Ethereum network <code>endpoint</code></p> </li> <li> <p>Credentials : which can be either <code>private key</code>, or <code>wallet path</code> and <code>wallet password</code></p> </li> </ul> <p>The remaining parameters are optional.</p>"},{"location":"web3j_openapi/#order-of-precedence","title":"Order of precedence","text":"<p>The parameters can be specified interchangeably between different sources. ie, you can have some defined in a default configuration file and others in environment variables etc.</p> <p>However, for duplicated values, we enforce the following order :</p> <ol> <li>CLI arguments</li> <li>Custom configuration file specified in the CLI</li> <li>Custom configuration file specified in Environment variables</li> <li>Default configuration file </li> <li>Environment variables</li> </ol> <p>Check the following sections for more information.</p>"},{"location":"web3j_openapi/#cli-arguments","title":"CLI arguments","text":"<p>The CLI arguments can be passed to the command the usual way.</p>"},{"location":"web3j_openapi/#example_1","title":"Example","text":"<p>Check the Starting the server section below to choose a command.</p> <pre><code>$ &lt;command&gt; \\\n    --private-key 0x1234 \\\n    --name OpenApiProject \\\n    --endpoint &lt;Ethereum node endpoint&gt; \\\n    --host localhost \\\n    --port 9090 \\\n    --contract-addresses contract1=0x1234,contract2=0x123\n</code></pre>"},{"location":"web3j_openapi/#configuration-file","title":"Configuration file","text":"<p>You can put the parameters in a <code>configuration file</code>. This latter, can be  <code>YAML</code>, <code>Json</code> or <code>Java properties</code> type of files.</p> <p>The configuration file can be :</p> <ul> <li>Put in the default directory : <code>~/.web3j/web3j.openapi.&lt;extension&gt;</code></li> <li>Set in an environment variable: <code>WEB3J_OPENAPI_CONFIG_FILE</code> where the value is the path to the file. eg.</li> </ul> <pre><code>export WEB3J_OPENAPI_CONFIG_FILE=&lt;path_to_the_config_file}\n</code></pre> <ul> <li>Set as an argument when running the JAR or the executable: <code>--config-file</code></li> </ul> <p>The supported extensions are :</p> <ul> <li><code>yaml</code> for a <code>YAML</code> configuration. Example:</li> </ul> <pre><code>contractAddresses: helloworld: \"0x1234\"\nhelloworld2: \"0x1234\"\ncredentials: privateKey: \"0x1234\"\nnetwork: endpoint: \"&lt;your_node_endpoint_address&gt;\"\nproject: name: \"OpenApiProject\"\nserver: host: \"localhost\"\nport: 9090\n</code></pre> <ul> <li><code>json</code> for a <code>Json</code> configuration. Example:</li> </ul> <pre><code>{\n\"contractAddresses\": {\n\"helloworld\": \"0x1234\",\n\"helloworld2\": \"0x1234\"\n},\n\"credentials\": {\n\"privateKey\": \"0x1234\"\n},\n\"network\": {\n\"endpoint\": \"your node endpoint address\"\n},\n\"project\": {\n\"name\": \"OpenApiProject\"\n},\n\"server\": {\n\"host\": \"localhost\",\n\"port\": 9090\n}\n}\n</code></pre> <ul> <li><code>properties</code> for a <code>Java properties</code> configuration. Example:</li> </ul> <pre><code>contractAddresses=helloworld=0x1234,helloworld2=0x1234\ncredentials.privateKey=0x1234\nnetwork.endpoint=your node endpoint address\nproject.name=OpenApiProject\nserver.host=localhost\nserver.port=9090\n</code></pre>"},{"location":"web3j_openapi/#environment-variables","title":"Environment variables","text":"<p>The easiest way to provide the runtime parameters is through environment variables.</p> <p>The rule is to:</p> <ul> <li> <p>Replace the <code>-</code> with a <code>_</code> : <code>private-key =&gt; private_key</code></p> </li> <li> <p>Upper case the options' names : <code>private-key =&gt; PRIVATE_KEY</code></p> </li> </ul>"},{"location":"web3j_openapi/#example_2","title":"Example","text":"<pre><code>$ export WEB3J_ENDPOINT=&lt;link_to_your_Ethereum_node&gt;\n$ export WEB3J_OPENAPI_HOST=localhost\n$ export WEB3J_OPENAPI_PORT=9090\n$ export WEB3J_OPENAPI_NAME=Web3jOpenAPI\n$ export WEB3J_OPENAPI_CONTRACT_ADDRESSES=helloworld=0x1234,helloworld2=0x12345\n$ export WEB3J_OEPNAPI_CONFIG_FILE=~/myConfig.yaml\n</code></pre> <p>And one of the following:</p> <ul> <li>A raw private key :</li> </ul> <pre><code>$ export WEB3J_PRIVATE_KEY=0x1234\n</code></pre> <ul> <li>A wallet :</li> </ul> <pre><code>$ export WEB3J_WALLET_PATH=~/myWallet.json\n$ export WEB3J_WALLET_PASSWORD=myStrongPassword\n</code></pre>"},{"location":"web3j_openapi/#start-the-server","title":"Start the server","text":"<p>Starting the server can be done in the following ways:</p>"},{"location":"web3j_openapi/#the-generated-jar","title":"The generated JAR","text":"<p>A <code>JAR</code> can be generated using the following command:</p> <pre><code>$ ./gradlew shadowJar\n</code></pre> <p>It will be found under the <code>build/libs</code> directory.</p> <p>The generated <code>JAR</code> can be run using the following:</p> <pre><code>$ java -jar build/libs/&lt;project name&gt;-all.jar &lt;parameters&gt;\n</code></pre> <p>check the parameters section above for the supported parameters.</p>"},{"location":"web3j_openapi/#the-distribution-executable","title":"The distribution executable","text":"<p>A server executable can be generated using the following:</p> <pre><code>$ ./gradlew installShadowDist &lt;parameters&gt;\n</code></pre> <p>Which can be found in <code>build/install/&lt;app name&gt;-shadow/bin/</code></p>"},{"location":"web3j_openapi/#using-gradle","title":"Using gradle","text":"<p>To run the project using gradle. Make sure to have set some environment variables or configuration file as specified above.</p> <p>Then, run the following : </p> <pre><code>$ ./gradlew run\n</code></pre>"},{"location":"web3j_openapi/#the-web3j-openapi-client","title":"The Web3j-OpenAPI client","text":"<p>Among the available ways to interact with a Web3j-OpenAPI server, there is the <code>Kotlin</code> client.</p> <p>It is easy to use.</p> <p>Start by adding dependency to the client:</p> <pre><code>dependencies {\nimplementation \"org.web3j.openapi:web3j-openapi-client:4.9.7\"\n}\n</code></pre> <p>Then, within a client application:</p> <pre><code>val service = ClientService(\"http://localhost:9090\")\nval app = ClientFactory.create(&lt;AppNameApi&gt;::class.java, service)\n\n// Then you have access to all the API resources\nval receipt = app.contracts.contractName.deploy()\n\nprintln(\"Deployment receipt: ${receipt.contractAddress}\")\n\n// ...\n</code></pre>"},{"location":"web3j_openapi/#handling-events","title":"Handling events","text":"<p>In web3j-OpenAPI, we handle events using Server-Sent Events SSE.</p> <p>In a nutshell, SSE is a one way mechanism that allows a server to asynchronously push data from the server to the client once the client-server connection is established by the client.</p> <p>To query events from <code>Kotlin/Java</code>. Add the <code>web3j-openapi-client</code> dependency as done above. Then, use the following code:</p> <pre><code>val service = ClientService(\"http://localhost:9090\")\nval app = ClientFactory.create(AppNameApi::class.java, service)\n\n// Start listening for events\nval event = app.contracts.&lt;contract_name&gt;.load(&lt;contract_Address&gt;)\n.events\n.&lt;event_name&gt;\n.onEvent { println(\"Received event: $it\") }\n\n// Trigger an event\napp.contracts\n.&lt;contract_name&gt;\n.load(&lt;contract_Address&gt;)\n.&lt;method_triggering_event&gt;(&lt;method_parameters&gt;)\n</code></pre> <p>Then run this code. You should be able to see events printing on the screen.</p>"},{"location":"web3j_sokt/","title":"Sokt","text":"<p>Sokt is a Kotlin wrapper for the Solidity compiler (solc). Given a solidity file, it can identify the ideal compiler version to use from the pragma statement at the top of the file. It can then download, install and invoke the compiler. Rather than using Dockerized versions of Solc, Sokt uses native builds and is compatible with Mac, Windows and Linux (x86/64 only)*. This means that the only dependency is a Java installation. Sokt also plays nicely with GraalVM, eliminating the Java dependency if necessary.</p> <p>Sokt is currently under active development. You can use it in one of your own projects by adding the following dependency to your <code>build.gradle</code>:</p> <pre><code>dependencies {\ncompile group: 'org.web3j', name: 'web3j-sokt', version: '0.2.1'\n}\n</code></pre> <p>For other build systems, see here.</p> <p>Example usage:</p> <pre><code>  String fileName = filePath.substringAfterLast(\"/\");\nSystem.out.println(\"sokt Processing \" + fileName);\nSolidityFile solidityFile = new SolidityFile(filePath);\nSystem.out.println(\"Resolving compiler version for \" + fileName);\nSolcInstance compilerInstance = solidityFile.getCompilerInstance();\n\nSystem.out.println(\"Resolved\" + compilerInstance.getSolcRelease().getVersion() + \" for \" + fileName);\n\nSolcOutput result = compilerInstance.execute(\nSolcArguments.OUTPUT_DIR.param(() -&gt; \"/tmp\"),\nSolcArguments.AST,\nSolcArguments.BIN,\nSolcArguments.OVERWRITE\n);\n\nSystem.out.println(\"Solc exited with code: \" + result.getExitCode());\nSystem.out.println(\"Solc standard output: \" + result.getStdOut());\nSystem.out.println(\"Solc standard error: \" + result.getStdErr());\n</code></pre> <p>*Note: Solc is not officially released for Linux arm machines, You can build it from source and copy the bin file to <code>{$USER}/.web3j/solc/&lt;solc-version&gt;/</code></p> <p>How to build from source, see here.</p>"},{"location":"web3j_unit/","title":"Web3j Unit","text":"<p>Web3j-unit is an extension to JUnit 5 which enables you to test solidity contracts like any other Java code. It allows you to test with both an embedded and dockerized Ethereum nodes, with out-of-the box support for Geth, Besu, and OpenEthereum nodes. A docker-compose network can also be configured easily for more complex setups.</p>"},{"location":"web3j_unit/#usage","title":"Usage","text":"<p>First, let's add the gradle dependency.</p> <pre><code>repositories {\nmavenCentral()\njcenter()\n}\nimplementation \"org.web3j:core:4.5.11\"\ntestCompile \"org.web3j:web3j-unit:4.5.11\"\n</code></pre>"},{"location":"web3j_unit/#using-evmtest-annotation","title":"Using EVMTest annotation","text":"<p>Create a new test with the <code>@EVMTest</code> annotation. An embedded EVM is used by default. To use Geth or Besu pass the node type into the annotation: <code>@EVMTest(NodeType.GETH)</code> or <code>@EVMTest(NodeType.BESU)</code></p> <pre><code>@EVMTest\npublic class GreeterTest {\n\n}\n</code></pre> <p>Inject instance of <code>Web3j</code>, <code>TransactionManager</code> and <code>ContractGasProvider</code> in your test method.</p> <pre><code>@EVMTest\npublic class GreeterTest {\n\n@Test\npublic void greeterDeploys(Web3j web3j, TransactionManager transactionManager, ContractGasProvider gasProvider ) {\n}\n\n}\n</code></pre> <p>Deploy your contract in the test.</p> <pre><code>@EVMTest\npublic class GreeterTest {\n\n@Test\npublic void greeterDeploys(Web3j web3j, TransactionManager transactionManager, ContractGasProvider gasProvider) {\nGreeter greeter = Greeter.deploy(web3j, transactionManager, gasProvider, \"Hello EVM\").send();\nString greeting = greeter.greet().send();\nassertEquals(\"Hello EVM\", greeting);\n}\n\n}\n</code></pre> <p>Run the test!</p>"},{"location":"web3j_unit/#using-evmcomposetest-annotation","title":"Using EVMComposeTest annotation","text":"<p>Create a new test with the <code>@EVMComposeTest</code> annotation. </p> <p>By default, it uses <code>test.yml</code> file in the project home, and runs web3j on service named <code>node1</code> exposing the port <code>8545</code>. </p> <p>Can be customised to use specific docker-compose file, service name and port by <code>@EVMComposeTest(\"src/test/resources/geth.yml\", \"ethnode1\", 8080)</code> Here, we connect to the service named <code>ethnode1</code> in the <code>src/test/resources/geth.yml</code> docker-compose file which exposes the port <code>8080</code> for web3j to connect to.</p> <pre><code>@EVMComposeTest(\"src/test/resources/geth.yml\", \"ethnode1\", 8080)\npublic class GreeterTest {\n\n}\n</code></pre> <p>Inject instance of <code>Web3j</code>, <code>TransactionManager</code> and <code>ContractGasProvider</code> in your test method.</p> <pre><code>@EVMComposeTest(\"src/test/resources/geth.yml\", \"ethnode1\", 8080)\npublic class GreeterTest {\n\n@Test\npublic void greeterDeploys(Web3j web3j, TransactionManager transactionManager, ContractGasProvider gasProvider) {\n}\n\n}\n</code></pre> <p>Deploy your contract in the test.</p> <pre><code>@EVMComposeTest(\"src/test/resources/geth.yml\", \"ethnode1\", 8080)\npublic class GreeterTest {\n\n@Test\npublic void greeterDeploys(Web3j web3j, TransactionManager transactionManager, ContractGasProvider gasProvider) {\nGreeter greeter = Greeter.deploy(web3j, transactionManager, gasProvider, \"Hello EVM\").send();\nString greeting = greeter.greet().send();\nassertEquals(\"Hello EVM\", greeting);\n}\n\n}\n</code></pre> <p>Run the test!</p>"},{"location":"web3j_unit/#sample-projects","title":"Sample projects","text":"<ol> <li> <p>Sample project using <code>@EVMTest</code> can be found here.</p> </li> <li> <p>This uses <code>@EVMComposeTest</code> to test the Greeter contract using VMWare Concord nodes using a docker-compose file.</p> </li> </ol>"},{"location":"advanced/HSM_transaction_signing/","title":"HSM Transaction Signing","text":"<p>Hardware Security Modules, HSMs, are cryptographic hardware devices that protects and manages data or assets and facilitates signing, verification, encryption and decryption. In the blockchain space they are typically used for protecting the cryptographic keys that are used for signing transactions. As these types of keys are heavily used in signing and validating transactions, they can be directly used from HSM in order to avoid any security leaks that might be met by in an online environment. Starting with web3j-4.9.0 HSM modules are supported in signing blockchain transactions.</p>"},{"location":"advanced/HSM_transaction_signing/#web3j-implementation","title":"Web3j implementation","text":"<p>To make this possible, a new transaction signing class has been created: TxHSMSignService. This extends TxSignService so it can be easily added to the transaction manager instantiation in order to sign transactions.</p> <p></p> <p>TxHSMSignService is based on other two classes. First is HSMPass that holds the address and the public key in order to can perform a request to a HSM. Second one is HSMRequestProcessor which process the request to HSM.</p> <p></p>"},{"location":"advanced/HSM_transaction_signing/#usage-in-web3j","title":"Usage in web3j","text":"<p>To implement and sign transactions with HSM using Web3j do the following:</p> <ul> <li>Implement HSMRequestProcessor in order to handle requests submitted to the HSM. Currently Web3J handles HTTP request to HSM which is implemented in the classes HSMHTTPRequestProcessor and HSMHTTPPass, see class diagram below:</li> </ul> <p> NOTE! HSMHTTPRequestProcessor is an abstract class so you need to extend it and to implement proper handling for createRequest and readRespons methods. Check this unit test to inspire.</p> <ul> <li>Instantiate new HSMPass object:</li> </ul> <pre><code>HSMHTTPPass hsmhttpPass = new HSMHTTPPass(\n&lt;account_address&gt;, &lt;account_public_key&gt;, &lt;hms_url&gt;);\n</code></pre> <ul> <li>Instantiate the new implementation of HSMHTTPRequestProcessor:</li> </ul> <pre><code>HSMHTTPRequestProcessor hsmRequestProcessor = new HSMHTTPRequestProcessorTestImpl&lt;&gt;(&lt;http_client&gt;);\n</code></pre> <ul> <li>Create new HSM sing service:</li> </ul> <pre><code>TxSignService txHSMSignService = new TxHSMSignService&lt;&gt;(hsmRequestProcessor, hsmhttpPass);\n</code></pre> <ul> <li>Submit the transaction service to a transaction manager and sign the transaction:</li> </ul> <pre><code>RawTransactionManager transactionManager = new RawTransactionManager(\nweb3j, txHSMSignService, &lt;chain_id&gt;); String sign = transactionManager.sign();\n</code></pre> <p>After executing all the steps should have been signed with the private key stored on the HSM.</p>"},{"location":"advanced/ethereum_name_service/","title":"Ethereum Name Service","text":"<p>The Ethereum Name Service (ENS) provides a human readable names to identify addresses on the Ethereum network. It is similar to the internet's domain name service (DNS) which provides human-readable domain names which are mapped to IP addresses.</p> <p>In the case of ENS, the addresses are either wallet or smart contract addresses.</p> <p>E.g. instead of using the wallet address <code>0x19e03255f667bdfd50a32722df860b1eeaf4d635</code>, you can use <code>web3j.eth</code>.</p>"},{"location":"advanced/ethereum_name_service/#usage-in-web3j","title":"Usage in web3j","text":"<p>You can use ENS names anywhere you wish to transact in web3j. In practice this means, in smart contract wrappers, when you load them, such as:</p> <pre><code>YourSmartContract contract = YourSmartContract.load(\n\"0x&lt;address&gt;|&lt;ensName&gt;\", web3j, credentials, contractGasProvider);\n</code></pre> <p>Also, when performing Ether transfers, such as using the command line tools:</p> <pre><code>$ web3j wallet send &lt;walletfile&gt; 0x&lt;address&gt;|&lt;ensName&gt;\n</code></pre>"},{"location":"advanced/ethereum_name_service/#web3j-implementation","title":"web3j implementation","text":"<p>Behind the scenes, whenever you using web3j's transaction managers (which are derived from the ManagedTransaction class), the EnsResolver is invoked to perform an ENS lookup if applicable.</p> <p>The resolution process is as follows:</p> <ul> <li>Check to see if our Ethereum node is fully synced</li> <li>If not fail</li> <li> <p>If it is synced, check the timestamp on the most recent block it has.</p> <ul> <li>If it's more than 3 minutes old, fail.</li> <li>Otherwise perform the lookup</li> </ul> </li> </ul> <p>If you need to change the threshold parameter of what constitutes being synced to something other then 3 minutes, this can be done via the <code>setSyncThreshold</code> method in the ManagedTransaction class.</p>"},{"location":"advanced/ethereum_name_service/#unicode-technical-standard-uts-46","title":"Unicode Technical Standard (UTS) #46","text":"<p>UTS #46 is the standard used to sanitise input on domain names. The web3j ENS implementation performs this sanitation on all inputs before attempting resolution. For details of the implementation, refer to the NameHash class.</p>"},{"location":"advanced/ethereum_name_service/#registering-domain-names","title":"Registering domain names","text":"<p>Currently, web3j only supports the resolution of ENS domains. It does not support the registration. For instructions on how to do this, refer to the ENS documentation.</p>"},{"location":"advanced/filters_and_events/","title":"Filters and Events","text":"<p>Filters provide notifications of certain events taking place in the Ethereum network. There are three classes of filter supported in Ethereum:</p> <ol> <li>Block filters</li> <li>Pending transaction filters</li> <li>Topic filters</li> </ol> <p>Block filters and pending transaction filters provide notification of the creation of new transactions or blocks on the network.</p> <p>Topic filters are more flexible. These allow you to create a filter based on specific criteria that you provide.</p> <p>Unfortunately, unless you are using a WebSocket connection to Geth, working with filters via the JSON-RPC API is a tedious process, where you need to poll the Ethereum client in order to find out if there are any updates to your filters due to the synchronous nature of HTTP and IPC requests. Additionally the block and transaction filters only provide the transaction or block hash, so a further request is required to obtain the actual transaction or block referred to by the hash.</p> <p>web3j's managed Filter implementation address these issues, so you have a fully asynchronous event based API for working with filters. It uses RxJava's Flowables which provides a consistent API for working with events, which facilitates the chaining together of JSON-RPC calls via functional composition.</p> <p>Note: filters are not supported on Infura.</p>"},{"location":"advanced/filters_and_events/#block-and-transaction-filters","title":"Block and transaction filters","text":"<p>To receive all new blocks as they are added to the blockchain (the false parameter specifies that we only want the blocks, not the embedded transactions too):</p> <pre><code>Subscription subscription = web3j.blockFlowable(false).subscribe(block -&gt; {\n...\n});\n</code></pre> <p>To receive all new transactions as they are added to the blockchain:</p> <pre><code>Subscription subscription = web3j.transactionFlowable().subscribe(tx -&gt; {\n...\n});\n</code></pre> <p>To receive all pending transactions as they are submitted to the network (i.e. before they have been grouped into a block together):</p> <pre><code>Subscription subscription = web3j.pendingTransactionFlowable().subscribe(tx -&gt; {\n...\n});\n</code></pre> <p>Subscriptions should always be cancelled when no longer required via unsubscribe:</p> <pre><code>subscription.unsubscribe();\n</code></pre> <p>Other callbacks are also provided which provide simply the block or transaction hashes, for details of these refer to the Web3jRx interface.</p>"},{"location":"advanced/filters_and_events/#replay-filters","title":"Replay filters","text":"<p>web3j also provides filters for replaying block and transaction history.</p> <p>To replay a range of blocks from the blockchain:</p> <pre><code>Subscription subscription = web3j.replayBlocksFlowable(\n&lt;startBlockNumber&gt;, &lt;endBlockNumber&gt;, &lt;fullTxObjects&gt;)\n.subscribe(block -&gt; {\n...\n});\n</code></pre> <p>To replay the individual transactions contained within a range of blocks:</p> <pre><code>Subscription subscription = web3j.replayTransactionsFlowable(\n&lt;startBlockNumber&gt;, &lt;endBlockNumber&gt;)\n.subscribe(tx -&gt; {\n...\n});\n</code></pre> <p>You can also get web3j to replay all blocks up to the most current, and provide notification (via the submitted Flowable) once you've caught up:</p> <pre><code>Subscription subscription = web3j.replayPastBlocksFlowable(\n&lt;startBlockNumber&gt;, &lt;fullTxObjects&gt;, &lt;onCompleteFlowable&gt;)\n.subscribe(block -&gt; {\n...\n});\n</code></pre> <p>Or, if you'd rather replay all blocks to the most current, then be notified of new subsequent blocks being created:</p> <pre><code>Subscription subscription = web3j.replayPastAndFutureBlocksFlowable(\n&lt;startBlockNumber&gt;, &lt;fullTxObjects&gt;)\n.subscribe(block -&gt; {\n...\n});\n</code></pre> <p>As above, but with transactions contained within blocks:</p> <pre><code>Subscription subscription = web3j.replayPastAndFutureTransactionsFlowable(\n&lt;startBlockNumber&gt;)\n.subscribe(tx -&gt; {\n...\n});\n</code></pre> <p>All of the above filters are exported via the Web3jRx interface.</p>"},{"location":"advanced/filters_and_events/#topic-filters-and-evm-events","title":"Topic filters and EVM events","text":"<p>Topic filters capture details of Ethereum Virtual Machine (EVM) events taking place in the network. These events are created by smart contracts and stored in the transaction log associated with a smart contract.</p> <p>The Solidity documentation provides a good overview of EVM events.</p> <p>You use the EthFilter type to specify the topics that you wish to apply to the filter. This can include the address of the smart contract you wish to apply the filter to. You can also provide specific topics to filter on. Where the individual topics represent indexed parameters on the smart contract:</p> <pre><code>EthFilter filter = new EthFilter(DefaultBlockParameterName.EARLIEST,\nDefaultBlockParameterName.LATEST, &lt;contract-address&gt;)\n[.addSingleTopic(...) | .addOptionalTopics(..., ...) | ...];\n</code></pre> <p>This filter can then be created using a similar syntax to the block and transaction filters above:</p> <pre><code>web3j.ethLogFlowable(filter).subscribe(log -&gt; {\n...\n});\n</code></pre> <p>The filter topics can only refer to the indexed Solidity event parameters. It is not possible to filter on the non-indexed event parameters. Additionally, for any indexed event parameters that are variable length array types such as string and bytes, the Keccak-256 hash of their value is stored on the EVM log. It is not possible to store or filter using their full value.</p> <p>If you create a filter instance with no topics associated with it, all EVM events taking place in the network will be captured by the filter.</p>"},{"location":"advanced/filters_and_events/#a-note-on-functional-composition","title":"A note on functional composition","text":"<p>In addition to send() and sendAsync, all JSON-RPC method implementations in web3j support the flowable() method to create a Flowable to execute the request asynchronously. This makes it very straight forwards to compose JSON-RPC calls together into new functions.</p> <p>For instance, the blockFlowable is itself composed of a number of separate JSON-RPC calls:</p> <pre><code>public Flowable&lt;EthBlock&gt; blockFlowable(\nboolean fullTransactionObjects, long pollingInterval) {\nreturn this.ethBlockHashFlowable(pollingInterval)\n.flatMap(blockHash -&gt;\nweb3j.ethGetBlockByHash(blockHash, fullTransactionObjects).flowable());\n}\n</code></pre> <p>Here we first create a flowable that provides notifications of the block hash of each newly created block. We then use flatMap to invoke a call to ethGetBlockByHash to obtain the full block details which is what is passed to the subscriber of the flowable.</p>"},{"location":"advanced/filters_and_events/#further-examples","title":"Further examples","text":"<p>Please refer to the integration test FlowableIT for further examples.</p> <p>For a demonstration of using the manual filter API, you can take a look at the test EventFilterIT.</p>"},{"location":"advanced/management_apis/","title":"Management APIs","text":"<p>In addition to implementing the standard JSON-RPC API, Ethereum clients, such as Geth and OpenEthereum provide additional management via JSON-RPC.</p> <p>One of the key common pieces of functionality that they provide is the ability to create and unlock Ethereum accounts for transacting on the network. In Geth and OpenEthereum, this is implemented in their Personal modules, details of which are available below:</p> <ul> <li>OpenEthereum</li> <li>Geth</li> </ul> <p>Support for the personal modules is available in web3j. Those methods that are common to both Geth and OpenEthereum reside in the Admin module of web3j.</p> <p>You can initialise a new web3j connector that supports this module using the factory method:</p> <pre><code>Admin web3j = Admin.build(new HttpService());  // defaults to http://localhost:8545/\nPersonalUnlockAccount personalUnlockAccount = admin.personalUnlockAccount(\"0x000...\", \"a password\").send();\nif (personalUnlockAccount.accountUnlocked()) {\n// send a transaction\n}\n</code></pre> <p>For Geth specific methods, you can use the Geth connector, and for OpenEthereum you can use the associated OpenEthereum connector. The <code>Parity</code> connector also provides support for OpenEthereum's Trace module. These connectors are available in the web3j geth and parity modules respectively.</p> <p>You can refer to the integration test ParityIT for further examples of working with these APIs.</p>"},{"location":"advanced/recursive_length_prefix/","title":"Recursive Length Prefix","text":"<p>The Recursive Length Prefix (RLP) encoding scheme is a space efficient object serialization scheme used in Ethereum.</p> <p>The specification itself is defined in the Yellow Paper, and the following page on the Ethereum Wiki.</p>"},{"location":"advanced/recursive_length_prefix/#rlp-types","title":"RLP Types","text":"<p>The RLP encoder defined two supported types:</p> <ul> <li>string</li> <li>list</li> </ul> <p>The list type can be nested an arbitrary number of times allowing complex data structures to be encoded.</p> <p>The RLP module in web3j provides RLP encoding capabilities, with the RlpEncoderTest demonstrating encoding of a number of different values.</p>"},{"location":"advanced/recursive_length_prefix/#transaction-encoding","title":"Transaction encoding","text":"<p>Within web3j, RLP encoding is used to encode Ethereum transaction objects into a byte array which is signed before submission to the network. The transaction types and signing logic are located within the Crypto module, with the TransactionEncoderTest providing examples of transaction signing and encoding.</p>"},{"location":"advanced/recursive_length_prefix/#dependencies","title":"Dependencies","text":"<p>This is a very lightweight module, with no other dependencies. The hope is that other projects wishing to work with Ethereum's RLP encoding on the JVM or Android will choose to make use of this module rather then write their own implementations.</p>"},{"location":"advanced/tls_http_websockets/","title":"TLS over HTTP and Websockets","text":""},{"location":"advanced/tls_http_websockets/#tls-over-http-and-websockets","title":"TLS over HTTP and Websockets","text":"<p>It is also possible to use TLS with the WebSocketConnection, remember to change your protocol from <code>ws</code> to <code>wss</code>. For stricter requirements one can define a custom keystore for their SSL certificates by passing in a modified <code>WebSocketClient</code> to the <code>WebSocketService</code>:</p> <pre><code>final WebSocketClient webSocketClient = new WebSocketClient(new URI(\"&lt;WSS-ENDPOINT&gt;\"));\n\nfinal WebSocketService webSocketService =\nnew WebSocketService(webSocketClient, false);\n\n// Load the keystore\nfinal KeyStore ks = KeyStore.getInstance(STORETYPE);\nfinal File kf = new File(KEYSTORE_PATH);\nks.load(new FileInputStream(kf), STOREPASSWORD.toCharArray());\nfinal KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\nkmf.init(ks, KEYPASSWORD.toCharArray());\nfinal TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\ntmf.init(ks);\n\n// Create SSL socket\nfinal SSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\nfinal SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();\n\n// Use SSL socket in websocket client\nwebSocketClient.setSocket(sslSocketFactory.createSocket());\nwebSocketService.connect();\n\nfinal Web3j web3j = Web3j.build(webSocketService);\n</code></pre> <p>Similarly to use TLS over HTTP we will pass modified <code>OkHttpClient</code> client to <code>HttpService</code>:</p> <pre><code>// Load the Keystore\nfinal KeyStore keyStore = KeyStore.getInstance(KEYSTORE_TYPE);\nkeyStore.load(new FileInputStream(KEYSTORE_PATH), KEYSTORE_PASSWORD.toCharArray());\n\nfinal KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\nkeyManagerFactory.init(keyStore, KEY_PASSWORD.toCharArray());\n\nfinal TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(\"SunX509\");\ntrustManagerFactory.init(keyStore);\n\nfinal SSLContext sslContext = SSLContext.getInstance(\"TLS\");\nsslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n\n// Create an OkHttpClient with the custom certificate\nOkHttpClient client = new OkHttpClient.Builder()\n.sslSocketFactory(sslContext.getSocketFactory(), (X509TrustManager) trustManagerFactory.getTrustManagers()[0])\n.build();\n\nfinal HttpService httpService = new HttpService(\"https://&lt;web3j-endpoint&gt;\", client, false);\nfinal Web3j web3j = Web3j.build(httpService);\n</code></pre> <p>Source: okHttp  TLS  docs </p>"},{"location":"advanced/web3j_core_modules/","title":"Web3j Core Modules","text":"<p>To provide greater flexibility for developers wishing to work with web3j, the project is made up of a number of modules.</p> <p>In dependency order, they are as follows:</p> <ul> <li>utils - Minimal set of utility classes</li> <li>rlp - Recursive Length Prefix (RLP) encoders</li> <li>abi - Application Binary Interface (ABI) encoders</li> <li>crypto - cryptographic library for transaction signing and key/wallet management in Ethereum</li> <li>tuples - Simple tuples library</li> <li>core - Much like the previous web3j core artifact without the code generators</li> <li>codegen - code generators</li> <li>console - command-line tools</li> </ul> <p>The below modules only depend on the core module.</p> <ul> <li>geth - Geth specific JSON-RPC module</li> <li>parity - OpenEthereum specific JSON-RPC module</li> <li>infura - Infura specific HTTP header support</li> <li>contracts - Support for specific EIP's (Ethereum Improvement Proposals)</li> <li>besu - Support for private transactions on Hyperledger Besu</li> </ul> <p>For most use cases (interacting with the network and smart contracts) the core module should be all you need. The dependencies of the core module are very granular and only likely to be of use if your project is focussed on a very specific interaction with the Ethereum network (such as ABI/RLP encoding, transaction signing but not submission, etc).</p> <p>All modules are published to both Maven Central and Bintray, with the published artifact names using the names listed above, i.e.:</p> <p>For Java:</p> <p><code>org.web3j: &lt;module-name\\&gt; : &lt;version\\&gt;</code></p> <p>For Android:</p> <p><code>org.web3j: &lt;module-name\\&gt; : &lt;version\\&gt;-android</code></p>"},{"location":"advanced/web3j_core_modules/#further-details","title":"Further details","text":"<p>In the Java  build:</p> <ul> <li>Web3j provides type safe access to all responses. Optional or null responses are wrapped in Java's Optional type.</li> <li>Asynchronous requests are wrapped in a Java CompletableFutures. Web3j provides a wrapper around all async requests to ensure that any exceptions during execution will be captured rather then silently discarded. This is due to the lack of support in CompletableFutures for checked exceptions, which are often rethrown as unchecked exception causing problems with detection. See the Async.run() and its associated test for details.</li> </ul> <p>In both the Java and Android builds:</p> <ul> <li>Quantity payload types are returned as BigIntegers. For simple results, you can obtain the quantity as a String via Response.getResult().</li> <li>It's also possible to include the raw JSON payload in responses via the includeRawResponse parameter, present in the HttpService and IpcService classes.</li> </ul>"},{"location":"getting_started/deploy_interact_smart_contracts/","title":"Deploy and Interact with Smart Contracts","text":""},{"location":"getting_started/deploy_interact_smart_contracts/#working-with-smart-contracts-and-java-smart-contract-wrappers","title":"Working with smart contracts and Java smart contract wrappers","text":"<p>Web3j can auto-generate smart contract wrapper code to deploy and interact with smart contracts without leaving the JVM.</p> <p>To generate the wrapper code, compile your smart contract:</p> <pre><code>$ solc &lt;contract&gt;.sol --bin --abi --optimize -o &lt;output-dir&gt;/\n</code></pre> <p>Then generate the wrapper code using the Web3j CLI:</p> <pre><code>web3j generate solidity -b /path/to/&lt;smart-contract&gt;.bin -a /path/to/&lt;smart-contract&gt;.abi -o /path/to/src/main/java -p com.your.organisation.name\n</code></pre> <p>Now you can create and deploy your smart contract:</p> <pre><code>Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/\nCredentials credentials = WalletUtils.loadCredentials(\"password\", \"/path/to/walletfile\");\n\nYourSmartContract contract = YourSmartContract.deploy(\n&lt;web3j&gt;, &lt;credentials&gt;,\n&lt;contractGasProvider&gt;,\n&lt;param1&gt;, ..., &lt;paramN&gt;).send();  // constructor params\n</code></pre> <p>Or use an existing contract:</p> <pre><code>YourSmartContract contract = YourSmartContract.load(\n\"0x&lt;address&gt;|&lt;ensName&gt;\", &lt;web3j&gt;, &lt;credentials&gt;, &lt;contractGasProvider&gt;);\n</code></pre> <p>To transact with a smart contract:</p> <pre><code>TransactionReceipt transactionReceipt = contract.someMethod(\n&lt;param1&gt;,\n...).send();\n</code></pre> <p>To call a smart contract:</p> <pre><code>Type result = contract.someMethod(&lt;param1&gt;, ...).send();\n</code></pre> <p>For more information refer to Solidity smart contract wrappers.</p>"},{"location":"getting_started/deploy_interact_smart_contracts/#smart-contract-examples","title":"Smart contract examples","text":"<p>Web3j provides a number of smart contract examples in the project directory codegen/src/test/resources/solidity</p> <p>It also provides integration tests for demonstrating the deploying and working with those smart contracts in the integration-tests/src/test/java/org/web3j/protocol/scenarios module.</p> <p></p>"},{"location":"getting_started/deploy_interact_smart_contracts/#eip-20-ethereum-token-standard-smart-contract","title":"EIP-20 Ethereum token standard smart contract","text":"<p>There is an Ethereum standard, EIP-20 which started off as an Ethereum Improvement Proposal (EIP), that defines the standard functions that a smart contract providing tokens should implement.</p> <p>The EIP-20 standard provides function definitions, but does not provide an implementation example. However, there is an implementation provided in codegen/src/test/resources/solidity/contracts, which has been taken from ConsenSys' Tokens project.</p> <p>Open Zeppelin also provides an example implementation on GitHub.</p> <p>There are two integration tests that have been written to fully demonstrate the functionality of this token smart contract.</p> <p>HumanStandardTokenGeneratedIT uses the generated HumanStandardTokenGenerated Solidity smart contract wrappers to demonstrate this.</p> <p>Alternatively, if you do not wish to use a smart contract wrapper and would like to work directly with the underlying JSON-RPC calls, please refer to HumanStandardTokenIT.</p>"},{"location":"getting_started/interacting_with_node/","title":"Interacting with a Node","text":""},{"location":"getting_started/interacting_with_node/#start-sending-requests","title":"Start sending requests","text":"<p>To send synchronous requests:</p> <pre><code>Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/\nWeb3ClientVersion web3ClientVersion = web3.web3ClientVersion().send();\nString clientVersion = web3ClientVersion.getWeb3ClientVersion();\n</code></pre> <p>To send asynchronous requests using a CompletableFuture (Future on Android):</p> <pre><code>Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/\nWeb3ClientVersion web3ClientVersion = web3.web3ClientVersion().sendAsync().get();\nString clientVersion = web3ClientVersion.getWeb3ClientVersion();\n</code></pre> <p>To use an RxJava Flowable:</p> <pre><code>Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/\nweb3.web3ClientVersion().flowable().subscribe(x -&gt; {\nString clientVersion = x.getWeb3ClientVersion();\n...\n});\n</code></pre>"},{"location":"getting_started/interacting_with_node/#ipc","title":"IPC","text":"<p>Web3j also supports fast inter-process communication (IPC) via file sockets to clients running on the same host as web3j. To connect simply use the relevant <code>IpcService</code> implementation instead of <code>HttpService</code> when you create your service:</p> <pre><code>// OS X/Linux/Unix:\nWeb3j web3 = Web3j.build(new UnixIpcService(\"/path/to/socketfile\"));\n...\n\n// Windows\nWeb3j web3 = Web3j.build(new WindowsIpcService(\"/path/to/namedpipefile\"));\n...\n</code></pre> <p>Note: IPC is not available on web3j-android.</p>"},{"location":"getting_started/interacting_with_node/#transactions","title":"Transactions","text":"<p>Web3j provides support for both working with Ethereum wallet files (recommended) and Ethereum client admin commands for sending transactions.</p>"},{"location":"getting_started/interacting_with_node/#send-ether","title":"Send Ether","text":"<p>To send Ether to another party using your Ethereum wallet file:</p> <pre><code>Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/\nCredentials credentials = WalletUtils.loadCredentials(\"password\", \"/path/to/walletfile\");\nTransactionReceipt transactionReceipt = Transfer.sendFunds(\nweb3, credentials, \"0x&lt;address&gt;|&lt;ensName&gt;\",\nBigDecimal.valueOf(1.0), Convert.Unit.ETHER)\n.send();\n</code></pre>"},{"location":"getting_started/interacting_with_node/#custom-transaction","title":"Custom Transaction","text":"<p>Or if you wish to create your own custom transaction:</p> <pre><code>Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/\nCredentials credentials = WalletUtils.loadCredentials(\"password\", \"/path/to/walletfile\");\n\n// get the next available nonce\nEthGetTransactionCount ethGetTransactionCount = web3j.ethGetTransactionCount(\naddress, DefaultBlockParameterName.LATEST).send();\nBigInteger nonce = ethGetTransactionCount.getTransactionCount();\n\n// create our transaction\nRawTransaction rawTransaction  = RawTransaction.createEtherTransaction(\nnonce, &lt;gas price&gt;, &lt;gas limit&gt;, &lt;toAddress&gt;, &lt;value&gt;);\n\n// sign &amp; send our transaction\nbyte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, credentials);\nString hexValue = Numeric.toHexString(signedMessage);\nEthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(hexValue).send();\n// ...\n</code></pre> <p>Although it's far simpler using Web3j's Transfer for transacting with Ether.</p> <p>Using an Ethereum client's admin commands (make sure you have your wallet in the client's keystore):</p> <pre><code>Admin web3j = Admin.build(new HttpService());  // defaults to http://localhost:8545/\nPersonalUnlockAccount personalUnlockAccount = web3j.personalUnlockAccount(\"0x000...\", \"a password\").sendAsync().get();\nif (personalUnlockAccount.accountUnlocked()) {\n// send a transaction\n}\n</code></pre> <p>If you want to make use of OpenEthereum's Personal  or Trace, or  Geth's Personal  client APIs, you can use the <code>org.web3j:parity</code> and <code>org.web3j:geth</code> modules respectively.</p>"},{"location":"getting_started/manual_configuration/","title":"Manual Configuration","text":"<p>The simplest way to get started with Web3j is via the powerful Web3j CLI. </p> <p>However, if you wish to configure your project manually, you can follow the steps outlined here.</p> <p>Add the latest Web3j version to your project build configuration.</p>"},{"location":"getting_started/manual_configuration/#maven","title":"Maven","text":"<p>Java:</p> <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;org.web3j&lt;/groupId&gt;\n&lt;artifactId&gt;core&lt;/artifactId&gt;\n&lt;version&gt;4.9.7&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Android:</p> <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;org.web3j&lt;/groupId&gt;\n&lt;artifactId&gt;core&lt;/artifactId&gt;\n&lt;version&gt;4.6.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"getting_started/manual_configuration/#gradle","title":"Gradle","text":"<p>Java:</p> <pre><code>compile ('org.web3j:core:4.9.7')\n</code></pre> <p>Android:</p> <pre><code>compile ('org.web3j:core:4.6.0')\n</code></pre>"},{"location":"getting_started/manual_configuration/#plugins","title":"Plugins","text":"<p>There are also gradle and maven plugins to help you generate Web3j Java wrappers for your Solidity smart contracts, thus allowing you to integrate such activities into your project lifecycle. Take a look at the project homepage for the web3j-gradle-plugin  and web3j-maven-plugin for details on how to use these plugins.</p>"},{"location":"getting_started/pub_sub/","title":"Filters and Flowables","text":""},{"location":"getting_started/pub_sub/#filters","title":"Filters","text":"<p>Web3j functional-reactive nature makes it really simple to setup observers that notify subscribers of events taking place on the blockchain.</p> <p>To receive all new blocks as they are added to the blockchain:</p> <pre><code>Subscription subscription = web3j.blockFlowable(false).subscribe(block -&gt; {\n...\n});\n</code></pre> <p>To receive all new transactions as they are added to the blockchain:</p> <pre><code>Subscription subscription = web3j.transactionFlowable().subscribe(tx -&gt; {\n...\n});\n</code></pre> <p>To receive all pending transactions as they are submitted to the network (i.e. before they have been grouped into a block together):</p> <pre><code>Subscription subscription = web3j.pendingTransactionFlowable().subscribe(tx -&gt; {\n...\n});\n</code></pre> <p>Or, if you'd rather replay all blocks to the most current, and be notified of new subsequent blocks being created:</p> <pre><code>Subscription subscription = replayPastAndFutureBlocksFlowable(\n&lt;startBlockNumber&gt;, &lt;fullTxObjects&gt;)\n.subscribe(block -&gt; {\n...\n});\n</code></pre> <p>There are a number of other transaction and block replay Flowables described in Filters and Events.</p> <p>Topic filters are also supported:</p> <pre><code>EthFilter filter = new EthFilter(DefaultBlockParameterName.EARLIEST,\nDefaultBlockParameterName.LATEST, &lt;contract-address&gt;)\n.addSingleTopic(...)|.addOptionalTopics(..., ...)|...;\nweb3j.ethLogFlowable(filter).subscribe(log -&gt; {\n...\n});\n</code></pre> <p>Subscriptions should always be cancelled when no longer required:</p> <pre><code>subscription.unsubscribe();\n</code></pre> <p>Note: filters are not supported on Infura.</p> <p>For further information refer to Filters and Events and the Web3jRx interface.</p>"},{"location":"getting_started/pub_sub/#publishsubscribe","title":"Publish/Subscribe","text":"<p>Ethereum clients implement the pub/sub mechanism that provides the capability to subscribe to events from the network, allowing these clients to take custom actions as needed. In doing so it alleviates the need to use polling and is more efficient. This is achieved by using the WebSocket protocol instead of HTTP protocol.</p> <p>Pub/Sub methods are available via the WebSocketService class, and allows the client to:</p> <ul> <li>send an RPC call over WebSocket protocol</li> <li>subscribe to WebSocket events</li> <li>unsubscribe from a stream of events</li> </ul> <p>To create an instance of the WebSocketService class you need to first to create an instance of the WebSocketClient that connects to an Ethereum client via WebSocket protocol, and then pass it to the WebSocketService constructor:</p> <pre><code>final WebSocketClient webSocketClient = new WebSocketClient(new URI(\"ws://localhost/\"));\nfinal boolean includeRawResponses = false;\nfinal WebSocketService webSocketService = new WebSocketService(webSocketClient, includeRawResponses)\n</code></pre> <p>To send an RPC request using the WebSocket protocol one need to use the sendAsync method on the WebSocketService instance:</p> <pre><code>// Request to get a version of an Ethereum client\nfinal Request&lt;?, Web3ClientVersion&gt; request = new Request&lt;&gt;(\n// Name of an RPC method to call\n\"web3_clientVersion\",\n// Parameters for the method. \"web3_clientVersion\" does not expect any\nCollections.&lt;String&gt;emptyList(),\n// Service that is used to send a request\nwebSocketService,\n// Type of an RPC call to get an Ethereum client version\nWeb3ClientVersion.class);\n\n// Send an asynchronous request via WebSocket protocol\nfinal CompletableFuture&lt;Web3ClientVersion&gt; reply = webSocketService.sendAsync(\nrequest,\nWeb3ClientVersion.class);\n\n// Get result of the reply\nfinal Web3ClientVersion clientVersion = reply.get();\n</code></pre> <p>To use synchronous communication (i.e send a request and await a response) one would need to use the sync method instead:</p> <pre><code>// Send a (synchronous) request via WebSocket protocol\nfinal Web3ClientVersion clientVersion = webSocketService.send(\nrequest,\nWeb3ClientVersion.class);\n</code></pre> <p>To subscribe to WebSocket events WebSocketService provides the subscribe method. subscribe returns an instance of the Flowable interface from the RxJava library, which allows the processing of incoming events from an Ethereum network as a reactive stream.</p> <p>To subscribe to a stream of events you should use WebSocketService to send an RPC method via WebSocket; this is usually eth_subscribe. Events that it subscribes to depend on parameters to the eth_subscribe method. You can find more in the RPC documentation:</p> <pre><code>// A request to subscribe to a stream of events\nfinal Request&lt;?, EthSubscribe&gt; subscribeRequest = new Request&lt;&gt;(\n// RPC method to subscribe to events\n\"eth_subscribe\",\n// Parameters that specify what events to subscribe to\nArrays.asList(\"newHeads\", Collections.emptyMap()),\n// Service that is used to send a request\nwebSocketService,\nEthSubscribe.class);\n\nfinal Flowable&lt;NewHeadsNotification&gt; events = webSocketService.subscribe(\nsubscribeRequest,\n// RPC method that should be used to unsubscribe from events\n\"eth_unsubscribe\",\n// Type of events returned by a request\nNewHeadsNotification.class\n);\n\n// Subscribe to incoming events and process incoming events\nfinal Disposable disposable = events.subscribe(event -&gt; {\n// Process new heads event\n});\n</code></pre> <p>Notice that we need to provide a name of a method to WebSocketService that needs to be called to unsubscribe from a stream of events. This is because different Ethereum clients may have different methods to unsubscribe from particular events. For example, the OpenEthereum client requires use of the parity_unsubscribe method to unsubscribe from pub/sub events.</p> <p>To unsubscribe from a stream of events one needs to use a Flowable instance for a particular events stream:</p> <pre><code>final Flowable&lt;NewHeadsNotification&gt; events = ...\nfinal Disposable disposable = events.subscribe(...)\ndisposable.dispose();\n</code></pre> <p>The methods described above are quite low-level, so we can use Web3j implementation instead:</p> <pre><code>final WebSocketService webSocketService = ...\nfinal Web3j web3j = Web3j.build(webSocketService)\nfinal Flowable&lt;NewHeadsNotification&gt; notifications = web3j.newHeadsNotifications()\n</code></pre>"},{"location":"getting_started/run_node_locally/","title":"Run a Node locally","text":"<p>Web3j interacts with Ethereum client nodes. If you don't want to connect to one of the existing networks, you have different options to start a local node.</p>"},{"location":"getting_started/run_node_locally/#use-geth-besu-or-openethereum","title":"Use Geth, Besu or OpenEthereum","text":"<p>Geth:</p> <pre><code>$ geth --rpcapi personal,db,eth,net,web3 --rpc --testnet\n</code></pre> <p>Hyperledger Besu:</p> <pre><code>$ besu ----network=dev\n</code></pre> <p>The <code>dev</code> network uses has some handy default parameters.</p> <p>OpenEthereum:</p> <pre><code>$ openethereum --chain testnet  </code></pre> <p>Instructions on obtaining Ether to transact on the network can be found in the testnet section of the docs.</p>"},{"location":"getting_started/run_node_locally/#use-epirus-local","title":"Use Epirus Local","text":"<p>Epirus-local is a local ethereum client, similar to what Ganache provides, written in Kotlin.</p> <p>This project relies on web3-evm to execute user requests.</p>"},{"location":"getting_started/run_node_locally/#features","title":"Features","text":"<ul> <li>Allows json-rpc interactions with a local ethereum blockchain.</li> <li>Generates a default genesis file containing 10 ethereum accounts or lets you use your own genesis.</li> <li>Provides a CLI to run the client.</li> <li>Handles these operations:<ul> <li><code>eth_blockNumber</code></li> <li><code>eth_getTransactionCount</code></li> <li><code>eth_getBalance</code></li> <li><code>eth_sendTransaction</code></li> <li><code>eth_sendRawTransaction</code></li> <li><code>eth_estimateGas</code></li> <li><code>eth_getBlockTransactionCountByHash</code></li> <li><code>eth_getBlockTransactionCountByNumber</code></li> <li><code>eth_getTransactionReceipt</code></li> <li><code>eth_getCode</code></li> <li><code>eth_call</code></li> </ul> </li> </ul>"},{"location":"getting_started/run_node_locally/#getting-started","title":"Getting started","text":"<p><code>git clone https://github.com/epirus-io/epirus-local &amp;&amp; cd epirus-local</code></p> <p><code>./gradlew installDist</code></p>"},{"location":"getting_started/run_node_locally/#run-in-linux","title":"Run in Linux:","text":"<p><code>build/install/epirus-local/bin/epirus-local [command]</code></p>"},{"location":"getting_started/run_node_locally/#run-in-windows","title":"Run in Windows","text":"<p><code>build\\install\\epirus-local\\bin\\epirus-local.bat [command]</code></p>"},{"location":"getting_started/run_node_locally/#start-the-client","title":"Start the client","text":"<pre><code>epirus-local start -d=/path/to/directory -p=9090\n</code></pre> <p>This command generates a new genesis file with 10 accounts filled with 100 ether.</p> <p></p>"},{"location":"getting_started/run_node_locally/#load-from-previous-configuration","title":"Load from previous configuration","text":"<pre><code>epirus-local load -g=/path/to/genesis\n</code></pre> <p>This command loads a pre-existing genesis-file from a certain path.</p> <p></p>"},{"location":"getting_started/run_node_locally/#send-requests","title":"Send requests","text":""},{"location":"getting_started/run_node_locally/#example-of-a-request","title":"Example of a request","text":"<pre><code>curl -X POST --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\",\"params\":[{\n  \"from\": \"0x8f496c16955a7bb9b5e1ea0383d01f87372ab520\",\n  \"to\": \"0xd46e8dd67c5d32be8058bb8eb970870f07244567\",\n  \"gas\": \"0x76c0\", \n  \"gasPrice\": \"0x9184e72a000\", \n  \"value\": \"0x9184e72a\",\n  \"nonce\": \"0x1\"\n}],\"id\":1}' host:port\n</code></pre>"},{"location":"getting_started/run_node_locally/#example-of-a-response","title":"Example of a response","text":"<pre><code>{\"id\" : 1, \"jsonrpc\" : \"2.0\", \"result\" : \"0xc631caa67cab48ead77a58321bbb0c76f4060751a4bb3d5b45b99c4a68b1a7b7\"}\n</code></pre> <p>For more information about the requests, check out the Ethereum json-rpc api.</p>"},{"location":"plugins/solidity_gradle_plugin/","title":"Solidity Gradle Plugin","text":"<p>Simple Gradle plugin used by the Web3j plugin  to compile Solidity contracts, but it can be used in any standalone project for this purpose.</p>"},{"location":"plugins/solidity_gradle_plugin/#plugin-configuration","title":"Plugin configuration","text":"<p>To configure the Solidity Gradle Plugin using the plugins DSL or the legacy plugin application,  check the plugin page.  The minimum Gradle version to run the plugin is <code>5.+</code>.</p> <p>Then run this command from your project containing Solidity contracts:</p> <pre><code>./gradlew build\n</code></pre> <p>After the task execution, the base directory for compiled code (by default  <code>$buildDir/resources/solidity</code>) will contain a directory for each source set  (by default <code>main</code> and <code>test</code>), and each of those a directory with the compiled code.</p>"},{"location":"plugins/solidity_gradle_plugin/#code-generation","title":"Code generation","text":"<p>The <code>solidity</code> DSL allows to configure the generated code, e.g.:</p> <pre><code>solidity {\noutputComponents = [BIN, ABI, ASM_JSON]\noptimizeRuns = 500\n}\n</code></pre> <p>The properties accepted by the DSL are listed in the following table:</p> Name Type Default value Description <code>executable</code> <code>String</code> <code>null</code> (bundled with the plugin) Solidity compiler path. <code>version</code> <code>String</code> <code>null</code> (defined by contract's pragma) Solidity compiler version. <code>overwrite</code> <code>Boolean</code> <code>true</code> Overwrite existing files. <code>resolvePackages</code> <code>Boolean</code> <code>true</code> Resolve third-party contract packages. <code>optimize</code> <code>Boolean</code> <code>true</code> Enable byte code optimizer. <code>optimizeRuns</code> <code>Integer</code> <code>200</code> Set for how many contract runs to optimize. <code>prettyJson</code> <code>Boolean</code> <code>false</code> Output JSON in pretty format. Enables the combined JSON output. <code>ignoreMissing</code> <code>Boolean</code> <code>false</code> Ignore missing files. <code>allowPaths</code> <code>List&lt;String&gt;</code> <code>['src/main/solidity', 'src/test/solidity', ...]</code> Allow a given path for imports. <code>pathRemappings</code> <code>Map&lt;String,String&gt;</code> <code>[ : ]</code> Remaps contract imports to target path. <code>evmVersion</code> <code>EVMVersion</code> <code>BYZANTIUM</code> Select desired EVM version. <code>outputComponents</code> <code>OutputComponent[]</code> <code>[BIN, ABI]</code> List of output components to produce. <code>combinedOutputComponents</code> <code>CombinedOutputComponent[]</code> <code>[BIN, BIN_RUNTIME, SRCMAP, SRCMAP_RUNTIME]</code> List of output components in combined JSON output. <p>Notes:</p> <ul> <li>Setting the <code>executable</code> property will disable the bundled <code>solc</code> and use your local or containerized executable:</li> </ul> <pre><code>solidity {\nexecutable = \"docker run --rm -v $projectDir/src:/src -v $projectDir/build:/build ethereum/solc:0.6.4-alpine\"\nversion = '0.4.15'\n}\n</code></pre> <ul> <li>Use <code>version</code> to change the bundled Solidity version.      Check the Solidity releases      for all available versions.</li> <li><code>allowPaths</code> contains all project's Solidity source sets by default.</li> </ul>"},{"location":"plugins/solidity_gradle_plugin/#source-sets","title":"Source sets","text":"<p>By default, all <code>.sol</code> files in <code>$projectDir/src/main/solidity</code> will be processed by the plugin. To specify and add different source sets, use the <code>sourceSets</code> DSL. You can also set your preferred output directory for compiled code.</p> <pre><code>sourceSets {\nmain {\nsolidity {\nsrcDir {\n\"my/custom/path/to/solidity\"\n}\noutput.resourcesDir = file('out/bin/compiledSol') }\n}\n}\n</code></pre>"},{"location":"plugins/solidity_gradle_plugin/#gradle-node-plugin","title":"Gradle Node Plugin","text":"<p>The plugin makes use of the Node plugin to resolve third-party contract dependencies.  It currently supports:</p> <ul> <li>Open Zeppelin </li> <li>Uniswap </li> </ul> <p>When importing libraries from <code>@openzeppeling/contracts</code> in your Solidity contract the plugin will use the task <code>resolveSolidity</code> to generate  a <code>package.json</code> file in order to be used by the Node plugin. By default, <code>package.json</code> will be generated under the <code>build/</code> directory. If you with do define your own <code>package.json</code> you need to add the following snippet in your <code>build.gradle</code> file. </p> <pre><code>node {\n    nodeProjectDir = file(\"my/custom/node/directory\")\n}\n</code></pre> <p>The plugin will look for the <code>package.json</code> file in the directory set and will also download the node modules under the same directory.</p>"},{"location":"plugins/solidity_gradle_plugin/#plugin-tasks","title":"Plugin tasks","text":"<p>The Java Plugin adds tasks to your project build using a naming convention on a per source set basis (i.e. <code>compileJava</code>, <code>compileTestJava</code>).</p> <p>Similarly, the Solidity plugin will add a:</p> <ul> <li><code>resolveSolidity</code> task for all project Solidity sources.</li> <li><code>compileSolidity</code> task for the project <code>main</code> source set.</li> <li><code>compile&lt;SourceSet&gt;Solidity</code> for each remaining source set. (e.g. <code>compileTestSolidity</code> for the <code>test</code> source set, etc.). </li> </ul> <p>To obtain a list and description of all added tasks, run the command:</p> <pre><code>./gradlew tasks --all\n</code></pre>"},{"location":"plugins/web3j_gradle_plugin/","title":"Web3j Gradle Plugin","text":"<p>Gradle plugin that generates Web3j Java wrappers from Solidity smart contracts. It smoothly integrates with your project's build lifecycle by adding specific tasks that can be also run independently.</p>"},{"location":"plugins/web3j_gradle_plugin/#plugin-configuration","title":"Plugin configuration","text":"<p>To configure the Web3j Gradle Plugin using the plugins DSL or the legacy plugin application,  check the plugin page.  The minimum Gradle version to run the plugin is <code>5.+</code>.</p> <p>Then run your project containing Solidity contracts:</p> <pre><code>./gradlew build\n</code></pre> <p>After applying the plugin, the base directory for generated code (by default  <code>$buildDir/generated/sources/web3j</code>) will contain a directory for each source set  (by default <code>main</code> and <code>test</code>) containing the smart contract wrappers Java classes.</p>"},{"location":"plugins/web3j_gradle_plugin/#code-generation","title":"Code generation","text":"<p>The <code>web3j</code> DSL allows to configure the generated code, e.g.:</p> <pre><code>web3j {\ngeneratedPackageName = 'com.mycompany.{0}'\ngeneratedFilesBaseDir = \"$buildDir/custom/destination\"\nexcludedContracts = ['Ownable']\nuseNativeJavaTypes = false\n}\n</code></pre> <p>The properties accepted by the DSL are listed in the following table: </p> Name Type Default value Description <code>generatedPackageName</code> <code>String</code> <code>${group}.web3j</code> or <code>org.web3j.{0}</code> Generated contract wrappers package. <code>generatedFilesBaseDir</code> <code>String</code> <code>$buildDir/generated/sources/web3j</code> Generated Java code output directory. <code>excludedContracts</code> <code>String[]</code> <code>[]</code> Excluded contract names from wrapper generation. <code>includedContracts</code> <code>String[]</code> <code>[]</code> Included contract names from wrapper generation. Has preference over <code>excludedContracts</code>. <code>useNativeJavaTypes</code> <code>Boolean</code> <code>true</code> Generate smart contract wrappers using native Java types. <code>addressBitLength</code> <code>int</code> <code>160</code> Supported address length in bits, by default Ethereum addresses. <p>The <code>generatedPackageName</code> is evaluated as a message format  string accepting a single parameter between curly brackets (<code>{0}</code>), allowing to format the generated value using the contract name. For convenience, when applied to a Java package name it will be converted to lower case. </p> <p>For instance, a <code>generatedPackageName</code> set to <code>${group}.{0}</code> in a project with group  <code>com.mycompany</code>, a Solidity contract named <code>MyToken.sol</code> will be generated in the package <code>com.mycompany.mytoken</code>.</p> <p>Also, the default value contains the <code>${group}</code> property, which corresponds to your project artifact  group (e.g. <code>com.mycompany</code>). If the project does not define a <code>group</code> property, the generated package name will be <code>org.web3j.{0}</code>.</p> <p>Note that message format parameters are not Gradle properties and should not be preceded by <code>$</code>.</p>"},{"location":"plugins/web3j_gradle_plugin/#source-sets","title":"Source sets","text":"<p>By default, all <code>.sol</code> files in <code>$projectDir/src/main/solidity</code> will be processed by the plugin. To specify and add different source sets, use the <code>sourceSets</code> DSL:</p> <pre><code>sourceSets {\nmain {\nsolidity {\nsrcDir { \"my/custom/path/to/solidity\" }\n}\n}\n}\n</code></pre> <p>Check the Solidity Plugin documentation to configure the smart contracts source code directories.</p> <p>Output directories for generated smart contract wrappers Java code  will be added to your build automatically.</p>"},{"location":"plugins/web3j_gradle_plugin/#plugin-tasks","title":"Plugin tasks","text":"<p>The Java Plugin adds tasks to your project build using a naming convention on a per source set basis (i.e. <code>compileJava</code>, <code>compileTestJava</code>).</p> <p>Similarly, the Solidity plugin will add the <code>generateContractWrappers</code> task for the project <code>main</code> source set, and a <code>generate[SourceSet]ContractWrappers</code> for each remaining source set (e.g. <code>test</code>). </p> <p>To obtain a list and description of all added tasks, run the command:</p> <pre><code>./gradlew tasks --all\n</code></pre>"},{"location":"plugins/web3j_maven_plugin/","title":"Web3j-maven-plugin","text":"<p>Web3j maven plugin is used to create java classes based on the solidity contract files.</p>"},{"location":"plugins/web3j_maven_plugin/#usage","title":"Usage","text":"<p>The base configuration for the plugin will take the solidity files from <code>src/main/resources</code> and generates  the java classes into the folder <code>src/main/java</code>.</p> <pre><code>&lt;build&gt;\n&lt;plugins&gt;\n&lt;plugin&gt;\n&lt;groupId&gt;org.web3j&lt;/groupId&gt;\n&lt;artifactId&gt;web3j-maven-plugin&lt;/artifactId&gt;\n&lt;version&gt;4.8.1&lt;/version&gt;\n&lt;configuration&gt;\n&lt;soliditySourceFiles/&gt;\n&lt;/configuration&gt;\n&lt;/plugin&gt;\n&lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre> <p>to run the plugin execute the goal <code>generate-sources</code></p> <pre><code>mvn web3j:generate-sources\n</code></pre>"},{"location":"plugins/web3j_maven_plugin/#configuration","title":"Configuration","text":"<p>The are several variable to select the solidity source files, define a source destination path or change the package name.</p> Name Format Default value <code>&lt;packageName/&gt;</code> valid java package name <code>org.web3j.model</code> <code>&lt;outputDirectory&gt;&lt;java/&gt;&lt;/outputDirectory&gt;</code> relative or absolute path of the generated for 'Java files value in <code>&lt;sourceDestination/&gt;</code> <code>&lt;outputDirectory&gt;&lt;bin/&gt;&lt;/outputDirectory&gt;</code> relative or absolute path of the generated for 'Bin' files value in <code>&lt;sourceDestination/&gt;</code> <code>&lt;outputDirectory&gt;&lt;abi/&gt;&lt;/outputDirectory&gt;</code> relative or absolute path of the generated for 'ABI' files value in <code>&lt;sourceDestination/&gt;</code> <code>&lt;sourceDestination/&gt;</code> relative or absolute path of the generated files (java, bin, abi) <code>src/main/java</code> <code>&lt;outputFormat/&gt;</code> generate Java Classes(<code>java</code>), ABI(<code>abi</code>) and/or BIN (<code>bin</code>) Files (comma separated) <code>java</code> <code>&lt;nativeJavaType/&gt;</code> Creates Java Native Types (instead of Solidity Types) <code>true</code> <code>&lt;soliditySourceFiles&gt;</code> Standard maven fileset <code>&lt;soliditySourceFiles&gt;</code><code>&lt;directory&gt;src/main/resources&lt;/directory&gt;</code><code>&lt;includes&gt;</code><code>&lt;include&gt;**/*.sol&lt;/include&gt;</code><code>&lt;/includes&gt;</code><code>&lt;/soliditySourceFiles&gt;</code> <code>&lt;contract&gt;</code> Filter (<code>&lt;include&gt;</code> or <code>&lt;exclude&gt;</code>) contracts based on the name. <code>&lt;contract&gt;</code><code>&lt;includes&gt;</code><code>&lt;include&gt;greeter&lt;/include&gt;</code><code>&lt;/includes&gt;</code><code>&lt;excludes&gt;</code><code>&lt;exclude&gt;mortal&lt;/exclude&gt;</code><code>&lt;excludes&gt;</code><code>&lt;/contracts&gt;</code> <code>&lt;pathPrefixes&gt;</code> A list (<code>&lt;pathPrefix&gt;</code>) of replacements of dependency replacements inside Solidity contract. <p>Configuration of <code>outputDirectory</code> has priority over <code>sourceDestination</code></p>"},{"location":"plugins/web3j_maven_plugin/#getting-started","title":"Getting Started","text":"<p>Create a standard java maven project. Add following <code>&lt;plugin&gt;</code> - configuration into the <code>pom.xml</code> file:</p> <pre><code>&lt;plugin&gt;\n&lt;groupId&gt;org.web3j&lt;/groupId&gt;\n&lt;artifactId&gt;web3j-maven-plugin&lt;/artifactId&gt;\n&lt;version&gt;4.5.11&lt;/version&gt;\n&lt;configuration&gt;\n&lt;packageName&gt;com.zuehlke.blockchain.model&lt;/packageName&gt;\n&lt;sourceDestination&gt;src/main/java/generated&lt;/sourceDestination&gt;\n&lt;nativeJavaType&gt;true&lt;/nativeJavaType&gt;\n&lt;outputFormat&gt;java,bin&lt;/outputFormat&gt;\n&lt;soliditySourceFiles&gt;\n&lt;directory&gt;src/main/resources&lt;/directory&gt;\n&lt;includes&gt;\n&lt;include&gt;**/*.sol&lt;/include&gt;\n&lt;/includes&gt;\n&lt;/soliditySourceFiles&gt;\n&lt;outputDirectory&gt;\n&lt;java&gt;src/java/generated&lt;/java&gt;\n&lt;bin&gt;src/bin/generated&lt;/bin&gt;\n&lt;abi&gt;src/abi/generated&lt;/abi&gt;\n&lt;/outputDirectory&gt;\n&lt;contract&gt;\n&lt;includes&gt;\n&lt;include&gt;greeter&lt;/include&gt;\n&lt;/includes&gt;\n&lt;excludes&gt;\n&lt;exclude&gt;mortal&lt;/exclude&gt;\n&lt;/excludes&gt;\n&lt;/contract&gt;\n&lt;pathPrefixes&gt;\n&lt;pathPrefix&gt;dep=../dependencies&lt;/pathPrefix&gt;\n&lt;/pathPrefixes&gt;\n&lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Add your solidity contract files into the folder <code>src/main/resources</code>. Make sure that the solidity files  ends with <code>.sol</code>.</p> <p>Start the generating process:</p> <pre><code>&gt; mvn web3j:generate-sources\n\n[INFO] --- web3j-maven-plugin:0.1.2:generate-sources (default-cli) @ hotel-showcase ---\n[INFO] process 'HotelShowCaseProxy.sol'\n[INFO]  Built Class for contract 'HotelShowCaseProxy'\n[INFO]  Built Class for contract 'HotelShowCaseV2'\n[INFO]  Built Class for contract 'Owned'\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD SUCCESS\n[INFO] ------------------------------------------------------------------------\n[INFO] Total time: 4.681 s\n[INFO] Finished at: 2017-06-13T07:07:04+02:00\n[INFO] Final Memory: 14M/187M\n[INFO] ------------------------------------------------------------------------\n\nProcess finished with exit code 0\n</code></pre> <p>You find the generated java classes inside the directory <code>src/main/java/generated/</code>.</p> <p>Next step is to interact with the smart contract. See for that  deploying and interacting with smart contracts  in the official web3j documentation.</p> <p>For a multi module project configuration see following post  from @fcorneli. In short:  For pick up the generated java source  files, you need the build-helper-maven-plugin configuration. Also, <code>${basedir}</code> prefix is required  within a multi-module project.</p>"},{"location":"privacy/besu_quickstart/","title":"Besu Quickstart","text":""},{"location":"privacy/besu_quickstart/#besu-quickstart","title":"Besu Quickstart","text":"<p>In order to get off the group quickly with Web3j and privacy on Besu, Besu Quickstart should be used. Besu quickstart is a collection of dockerfiles and associated configuration files which allows you to start up a local private-transaction-enabled Ethereum network. In order to get started, ensure you have Docker and Docker Compose installed on your system. Then clone the Besu Quickstart repository likeso:</p> <pre><code>git clone https://github.com/PegaSysEng/besu-quickstart.git\n</code></pre> <p>In order to start an Ethereum network with privacy enabled, invoke the <code>run-privacy.sh</code> shell script. This should result in a number of containers being started, including 3 Besu nodes which will communicate using the ports <code>localhost:20000-20004</code>. It should be noted that starting the full network generally uses 12GB+ of RAM.</p> <p>Once the network has been started, the output of the <code>netstat</code> command should indicate that ports 20000-20004 are in use.</p>"},{"location":"privacy/privacy_support_web3j/","title":"Privacy Support in Web3j","text":""},{"location":"privacy/privacy_support_web3j/#privacy-support-in-web3j","title":"Privacy Support in Web3j","text":"<p>As mentioned earlier, the Besu module in Web3j can be used to create privacy groups and send private transactions in Besu. The Besu privacy quickstart starts up three nodes with their associated Orion instances, which will henceforth be called Alice, Bob and Charlie for ease of use. The keys associated with each are predetermined, and can be represented in Java as follows:</p> <pre><code>private static final Credentials ALICE =\nCredentials.create(\"8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63\");\nprivate static final Credentials BOB =\nCredentials.create(\"c87509a1c067bbde78beb793e6fa76530b6382a4c0241e5e4a9ec0a0f44dc0d3\");\nprivate static final Credentials CHARLIE =\nCredentials.create(\"ae6ae8e5ccbfb04590405997ee2d52d2b330726137b875053c36d94e974d162f\");\n\nprivate static final Base64String ENCLAVE_KEY_ALICE =\nBase64String.wrap(\"A1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\");\nprivate static final Base64String ENCLAVE_KEY_BOB =\nBase64String.wrap(\"Ko2bVqD+nNlNYL5EE7y3IdOnviftjiizpjRt+HTuFBs=\");\nprivate static final Base64String ENCLAVE_KEY_CHARLIE =\nBase64String.wrap(\"k2zXEin4Ip/qBGlRkJejnGWdP9cjkK+DAvKNW31L2C8=\");\n</code></pre> <p>The instances of the class <code>Credentials</code> above are the private keys associated with the default account of each Besu node in the network. These are configured in the config files for Besu in the privacy quickstart. The <code>Base64Strings</code> are the Orion keys associated with each member, and are configured in the config files for Orion in the privacy quickstart. If you choose to create your own network, these values will differ from the defaults as specified in the privacy quickstart.</p> <p>Web3j provides the class <code>org.web3j.protocol.besu.Besu</code> which encapsulates all Besu specific methods with all of the usual Web3j commands. We can use several instances of these to talk to the running quickstart instance:</p> <pre><code>private static Besu nodeAlice = Besu.build(new HttpService(\"http://localhost:20000\"));\nprivate static Besu nodeBob = Besu.build(new HttpService(\"http://localhost:20002\"));\nprivate static Besu nodeCharlie = Besu.build(new HttpService(\"http://localhost:20004\"));\nprivate static PollingPrivateTransactionReceiptProcessor processor = new PollingPrivateTransactionReceiptProcessor(nodeAlice, 1000, 15);\n</code></pre>"},{"location":"privacy/privacy_support_web3j/#creating-a-privacy-group","title":"Creating a privacy group","text":"<p>In order to create a new privacy group, first a random 32 byte base64 string is generated to form the group ID. Then the create group function is called, and we wait for the transaction receipt to be returned. Finally, we can call the <code>privOnChainFindPrivacyGroup</code> method, which will find the privacy group which was just created by using the two Orion keys of the group members. </p> <pre><code>// Generate a new random Base64 string for the privacy group ID\nBase64String privacyGroupId = Base64String.wrap(generateRandomBytes(32));\n\n// Create the privacy group\nfinal String txHash =\nnodeAlice\n.privOnChainCreatePrivacyGroup(\nprivacyGroupId,\nALICE,\nENCLAVE_KEY_ALICE,\nCollections.singletonList(ENCLAVE_KEY_BOB))\n.send()\n.getTransactionHash();\n\n// Wait for the transaction to be mined &amp; get the receipt\nTransactionReceipt receipt = processor.waitForTransactionReceipt(txHash);\n\n// Find the privacy group based on the two members\nOptional&lt;PrivacyGroup&gt; group =\nnodeAlice\n.privOnChainFindPrivacyGroup(\nArrays.asList(ENCLAVE_KEY_ALICE, ENCLAVE_KEY_BOB))\n.send()\n.getGroups().stream().filter(x -&gt; x.getPrivacyGroupId().equals(privacyGroupId)).findFirst();\n</code></pre>"},{"location":"privacy/privacy_support_web3j/#adding-removing-members","title":"Adding &amp; removing members","text":"<p>After a privacy group has been created, users can be added to the group using the <code>privOnChainAddToPrivacyGroup</code> method, and removed from the group using the <code>privOnChainRemoveFromPrivacyGroup</code> method.</p> <pre><code>Base64String privacyGroupId = Base64String.wrap(generateRandomBytes(32));\nfinal String createTxHash =\nnodeAlice\n.privOnChainCreatePrivacyGroup(\nprivacyGroupId,\nALICE,\nENCLAVE_KEY_ALICE,\nCollections.singletonList(ENCLAVE_KEY_BOB))\n.send()\n.getTransactionHash();\n\nTransactionReceipt createReceipt = processor.waitForTransactionReceipt(createTxHash);\n\n// Once the group has been created, add Charlie from Alice's node\nfinal String addTxHash =\nnodeAlice\n.privOnChainAddToPrivacyGroup(\nprivacyGroupId,\nALICE,\nENCLAVE_KEY_ALICE,\nCollections.singletonList(ENCLAVE_KEY_CHARLIE))\n.send()\n.getTransactionHash();\n\nTransactionReceipt addReceipt = processor.waitForTransactionReceipt(addTxHash);\n\n// Once the add transaction has been mined, find the privacy group which contains Alice, Bob &amp; Charlie\nList&lt;PrivacyGroup&gt; groups =\nnodeAlice\n.privOnChainFindPrivacyGroup(\nArrays.asList(\nENCLAVE_KEY_ALICE, ENCLAVE_KEY_BOB, ENCLAVE_KEY_CHARLIE))\n.send()\n.getGroups();\n\n// Remove Charlie from the privacy group\nfinal String removeTxHash =\nnodeAlice\n.privOnChainRemoveFromPrivacyGroup(\nprivacyGroupId, ALICE, ENCLAVE_KEY_ALICE, ENCLAVE_KEY_CHARLIE)\n.send()\n.getTransactionHash();\n\nTransactionReceipt removeReceipt = processor.waitForTransactionReceipt(removeTxHash);\n\n// Get the privacy group with only Alice and Bob now in it.\nList&lt;PrivacyGroup&gt; removedGroups =\nnodeAlice\n.privOnChainFindPrivacyGroup(\nArrays.asList(ENCLAVE_KEY_ALICE, ENCLAVE_KEY_BOB))\n.send()\n.getGroups();\n</code></pre>"},{"location":"privacy/privacy_support_web3j/#creating-interacting-with-a-smart-contract","title":"Creating &amp; interacting with a smart contract","text":"<p>Once a privacy group has been created, smart contracts can be created &amp; executed within the privacy group. The state of the contract and all of the associated transactions will only be viewable to those within the privacy group. In this example, an instance of a <code>HumanStandardToken</code> is deployed within the group, and is visible to each member:</p> <pre><code>// Create a new privacy group\nBase64String aliceBobGroup = Base64String.wrap(generateRandomBytes(32));\nfinal String createTxHash =\nnodeAlice\n.privOnChainCreatePrivacyGroup(\naliceBobGroup,\nALICE,\nENCLAVE_KEY_ALICE,\nCollections.singletonList(ENCLAVE_KEY_BOB))\n.send()\n.getTransactionHash();\n\nTransactionReceipt createReceipt = processor.waitForTransactionReceipt(createTxHash);\n\n// Find the privacy group that was built by Alice from Bob's node\nfinal Base64String aliceBobGroupFromBobNode =\nnodeBob\n.privOnChainFindPrivacyGroup(\nArrays.asList(ENCLAVE_KEY_ALICE, ENCLAVE_KEY_BOB))\n.send().getGroups().stream()\n.filter(g -&gt; g.getPrivacyGroupId().equals(aliceBobGroup))\n.findFirst()\n.orElseThrow(RuntimeException::new)\n.getPrivacyGroupId();\n\n// Create two private transaction manager instances for Alice and Bob in order to interact with smart contracts\nfinal PrivateTransactionManager tmAlice =\nnew BesuPrivateTransactionManager(\nnodeAlice,\nZERO_GAS_PROVIDER,\nALICE,\n2018,\nENCLAVE_KEY_ALICE,\naliceBobGroup);\nfinal PrivateTransactionManager tmBob =\nnew BesuPrivateTransactionManager(\nnodeBob,\nZERO_GAS_PROVIDER,\nBOB,\n2018,\nENCLAVE_KEY_BOB,\naliceBobGroupFromBobNode);\n\n// Deploy the token from Alice's node\nfinal HumanStandardToken tokenAlice =\nHumanStandardToken.deploy(\nnodeAlice,\ntmAlice,\nZERO_GAS_PROVIDER,\nBigInteger.TEN,\n\"eea_token\",\nBigInteger.TEN,\n\"EEATKN\")\n.send();\n\n// Get an instance of the token from Bob's node\nfinal HumanStandardToken tokenBob =\nHumanStandardToken.load(\ntokenAlice.getContractAddress(), nodeBob, tmBob, ZERO_GAS_PROVIDER);\n</code></pre>"},{"location":"privacy/privacy_with_besu/","title":"Privacy with Hyperledger Besu","text":""},{"location":"privacy/privacy_with_besu/#privacy-with-hyperledger-besu","title":"Privacy with Hyperledger Besu","text":"<p>The Besu module in Web3j provides support for creating private transactions and privacy groups on Hyperledger Besu. For information as to how privacy is implemented in Besu, please see the Besu privacy documentation.</p> <p>Privacy in Besu refers to the ability to keep transactions private between the involved participants. Other participants cannot access the transaction content or list of participants. Besu uses Orion, a separate software component, to manage private transactions. Orion is able to maintain public/private keypair, store privacy group details, and discover other Orion nodes on a network. A privacy group is a group of nodes identified by a unique privacy group ID in Orion. Each private transaction is stored in Orion and is associated with the privacy group ID.</p> <p>The Besu nodes maintain the public world state for the blockchain and a private state for each privacy group. The private states contain data that is not shared in the globally replicated public world state.</p> <p>Private transactions have additional attributes to public Ethereum transactions:</p> <ul> <li><code>privateFrom</code> - Orion public key of transaction sender</li> <li><code>privacyGroupId</code> - Privacy group to receive transaction</li> <li><code>restriction</code> - Private transactions are restricted or unrestricted:<ul> <li>In restricted private transactions the payload of the private transaction is received and stored only by the nodes participating in the transaction.</li> <li>In unrestricted private transactions the payload of the private transaction is transmitted to all nodes in the network but is readable only by nodes participating in the transaction.</li> </ul> </li> </ul>"},{"location":"references/companies_using_web3j/","title":"Companies using Web3j","text":"<ul> <li>Amberdata</li> <li>Web3Labs</li> <li>comitFS</li> <li>ConsenSys</li> <li>ING</li> <li>Othera</li> <li>Pactum</li> <li>TrustWallet</li> <li>Impetus</li> <li>Argent Labs</li> <li>Alpha Wallet</li> <li>Lab10 Collective</li> <li>BinarApps</li> <li>PegaSys</li> <li>Arkane</li> <li>FreightTrust</li> <li>Othera</li> </ul>"},{"location":"references/developer_guide/","title":"Developer Guide","text":""},{"location":"references/developer_guide/#dependency-management","title":"Dependency management","text":"<p>We recommend you use formal releases of web3j, these can be found on most public maven repositories.</p> <p>Release versions follow the <code>&lt;major&gt;.&lt;minor&gt;.&lt;build&gt;</code> convention, for example: 4.2.0</p> <p>Snapshot versions of web3j follow the ..-SNAPSHOT` convention, for example:      4.2.0-SNAPSHOT. <p>If you would like to use snapshots instead please add a new maven repository pointing to:</p> <pre><code>https://oss.sonatype.org/content/repositories/snapshots\n</code></pre> <p>Please refer to the Maven or Gradle documentation for further detail.</p> <p>Sample gradle configuration:</p> <pre><code>repositories {\nmaven {\nurl \"https://oss.sonatype.org/content/repositories/snapshots\"\n}\n}\n</code></pre> <p>Sample maven configuration:</p> <pre><code>&lt;repositories&gt;\n&lt;repository&gt;\n&lt;id&gt;sonatype-snasphots&lt;/id&gt;\n&lt;name&gt;Sonatype snapshots repo&lt;/name&gt;\n&lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;\n&lt;/repository&gt;\n&lt;/repositories&gt;\n</code></pre>"},{"location":"references/developer_guide/#building-web3j","title":"Building web3j","text":"<p>web3j includes integration tests for running against a live Ethereum client. If you do not have a client running, you can exclude their execution as per the below instructions.</p> <p>To run a full build (excluding integration tests):</p> <pre><code>$ ./gradlew check\n</code></pre> <p>To run the integration tests:</p> <pre><code>$ ./gradlew  -Pintegration-tests=true :integration-tests:test\n</code></pre>"},{"location":"references/developer_guide/#generating-documentation","title":"Generating documentation","text":"<p>web3j uses the Sphinx documentation generator.</p> <p>All documentation (apart from the project README.md) resides under the /docs directory.</p> <p>To build a copy of the documentation, from the project root:</p> <pre><code>$ cd docs\n$ make clean html\n</code></pre> <p>Then browse the build documentation via:</p> <pre><code>$ open build/html/index.html\n</code></pre>"},{"location":"references/links_and_useful_resources/","title":"Links and Useful Resources","text":"<ul> <li>Ethereum Homestead Documentation</li> <li>Ethereum Wiki</li> <li>Ethereum JSON-RPC specification</li> <li>Ethereum Yellow Paper on the GitHub repository</li> <li>Solidity docs</li> <li>Layout of variables in storage</li> <li>Ethereum tests contains lots of common tests for clients</li> <li>Etherscan is very useful for exploring blocks and transactions.</li> <li>Ethstats provides a useful network dashboard. There is also a dedicated Rinkeby testnet dashboard.</li> <li>Ethereum reddit</li> </ul>"},{"location":"references/projects_using_web3j/","title":"Projects using Web3j","text":"<ul> <li>AlphaWallet Android Wallet</li> <li>Minerva Digital Wallet</li> <li>ERC-20 RESTful Service</li> <li>Trust Ethereum Wallet</li> <li>Presto Ethereum</li> <li>Ethereum JDBC Connector by @impetus-opensource</li> <li>Kundera-Ethereum data importer and sync utility by @impetus-opensource</li> <li>Ethereum Tool for secure offline key management. </li> <li>Ethereum Java EE JCA Resource Adapter Provides integration of Ethereum within Java EE 6+.</li> <li>Etherlinker for UE4 Interact with Ethereum blockchain from Unreal Engine 4.</li> <li>Ethereum ingest utility Import and stream blocks/transactions into Hazelcast, Elasticsearch and MongoDB.</li> <li>EtherWallet by @vikulin</li> <li>Apache Camel Ethereum Component by @bibryam</li> <li>eth-contract-api by @adridadou</li> <li>Ethereum Paper Wallet by @matthiaszimmermann</li> <li>web3j-scala by @mslinn</li> </ul>"},{"location":"references/thanks_and_credits/","title":"Thanks and Credits","text":"<ul> <li>The Nethereum project for the inspiration</li> <li>Othera for the great things they are building on the platform</li> <li>Finhaus guys for putting me onto Nethereum</li> <li>bitcoinj for the reference Elliptic Curve crypto implementation</li> <li>Everyone involved in the Ethererum project and its surrounding ecosystem</li> <li>And of course the users of the library, who've provided valuable input &amp; feedback</li> </ul>"},{"location":"references/troubleshooting/","title":"Troubleshooting","text":""},{"location":"references/troubleshooting/#do-you-have-a-sample-web3j-project","title":"Do you have a sample web3j project","text":"<p>Yes, refer to the web3j sample project outlined in the Quickstart.</p>"},{"location":"references/troubleshooting/#im-submitting-a-transaction-but-its-not-being-mined","title":"I'm submitting a transaction, but it's not being mined","text":"<p>After creating and sending a transaction, you receive a transaction hash, however calling eth_getTransactionReceipt always returns a blank value, indicating the transaction has not been mined:</p> <pre><code>String transactionHash = sendTransaction(...);\n\n// you loop through the following expecting to eventually get a receipt once the transaction\n// is mined\nEthGetTransactionReceipt.TransactionReceipt transactionReceipt =\nweb3j.ethGetTransactionReceipt(transactionHash).sendAsync().get();\n\nif (!transactionReceipt.isPresent()) {\n// try again, ad infinitum\n}\n</code></pre> <p>However, you never receive a transaction receipt. Unfortunately there may not be a an error in your Ethereum client indicating any issues with the transaction:</p> <pre><code>I1025 18:13:32.817691 eth/api.go:1185] Tx(0xeaac9aab7f9aeab189acd8714c5a60c7424f86820884b815c4448cfcd4d9fc79) to: 0x9c98e381edc5fe1ac514935f3cc3edaa764cf004\n</code></pre> <p>The easiest way to see if the submission is waiting to mined is to refer to Etherscan and search for the address the transaction was sent using https://testnet.etherscan.io/address/0x... If the submission has been successful it should be visible in Etherscan within seconds of you performing the transaction submission. The wait is for the mining to take place.</p> <p></p> <p>If there is no sign of it then the transaction has vanished into the ether (sorry). The likely cause of this is likely to be to do with the transaction's nonce either not being set, or being too low. Please refer to the section Transaction nonce for more information.</p>"},{"location":"references/troubleshooting/#i-want-to-see-details-of-the-json-rpc-requests-and-responses","title":"I want to see details of the JSON-RPC requests and responses","text":"<p>web3j uses the SLF4J logging facade, which you can easily integrate with your preferred logging framework. One lightweight approach is to use LOGBack, which is already configured in the integration-tests module.</p> <p>Include the LOGBack dependencies listed in integration-tests/build.gradle and associated log configuration as per integration-tests/src/test/resources/logback-test.xml.</p> <p>Note: if you are configuring logging for an application (not tests), you will need to ensure that the Logback dependencies are configured as compile dependencies, and that the configuration file is named and located in src/main/resources/logback.xml.</p>"},{"location":"references/troubleshooting/#i-want-to-obtain-some-ether-on-testnet-but-dont-want-to-have-to-mine-it-myself","title":"I want to obtain some Ether on Testnet, but don't want to have to mine it myself","text":"<p>Please refer to the Ethereum testnets for how to obtain some Ether.</p>"},{"location":"references/troubleshooting/#how-do-i-obtain-the-return-value-from-a-smart-contract-method-invoked-by-a-transaction","title":"How do I obtain the return value from a smart contract method invoked by a transaction?","text":"<p>You can't. It is not possible to return values from methods on smart contracts that are called as part of a transaction. If you wish to read a value during a transaction, you must use Events. To query values from smart contracts you must use a call, which is separate to a transaction. These methods should be marked as constant functions. Solidity smart contract wrappers created by web3j handle these differences for you.</p> <p>The following StackExchange post is useful for background.</p>"},{"location":"references/troubleshooting/#is-it-possible-to-send-arbitrary-text-with-transactions","title":"Is it possible to send arbitrary text with transactions?","text":"<p>Yes it is. Text should be ASCII encoded and provided as a hexadecimal String in the data field of the transaction. This is demonstrated below:</p> <pre><code>RawTransaction.createTransaction(\n&lt;nonce&gt;, GAS_PRICE, GAS_LIMIT, \"0x&lt;address&gt;\", &lt;amount&gt;, \"0x&lt;hex encoded text&gt;\");\n\nbyte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, ALICE);\nString hexValue = Numeric.toHexString(signedMessage);\n\nEthSendTransaction ethSendTransaction =\nweb3j.ethSendRawTransaction(hexValue).send();\nString transactionHash = ethSendTransaction.getTransactionHash();\n...\n</code></pre> <p>Note: Please ensure you increase the gas limit on the transaction to allow for the storage of text.</p> <p>The following StackExchange post is useful for background.</p>"},{"location":"references/troubleshooting/#ive-generated-my-smart-contract-wrapper-but-the-binary-for-the-smart-contract-is-empty","title":"I've generated my smart contract wrapper, but the binary for the smart contract is empty?","text":"<p>If you have defined an interface in Solidity, but one of your method implementations doesn't match the original interface definitions, the produced binary will be blank.</p> <p>In the following example:</p> <pre><code>contract Web3jToken is ERC20Basic, Ownable {\n...\nfunction transfer(address _from, address _to, uint256 _value) onlyOwner returns (bool) {\n...\n}\n</code></pre> <p>We forgot to define the from parameter in one of the inherited contracts:</p> <pre><code>contract ERC20Basic {\n...\nfunction transfer(address to, uint256 value) returns (bool);\n...\n}\n</code></pre> <p>The Solidity compiler will not complain about this, however, the produced binary file for the Web3jToken will be blank.</p>"},{"location":"references/troubleshooting/#my-ens-lookups-are-failing","title":"My ENS lookups are failing","text":"<p>Are you sure that you are connecting to the correct network to perform the lookup?</p> <p>If web3j is telling you that the node is not in sync, you may need to change the syncThreshold in the ENS resolver.</p>"},{"location":"references/troubleshooting/#where-can-i-get-commercial-support-for-web3j","title":"Where can I get commercial support for web3j?","text":"<p>Commercial support and training is available from web3labs.</p>"},{"location":"smart_contracts/application_binary_interface/","title":"Application Binary Interface","text":"<p>The Application Binary Interface (ABI) is a data encoding scheme used in Ethereum for working with smart contracts. The types defined in the ABI are the same as those you encounter when writing Smart Contracts with Solidity - i.e. uint8, ..., uint256, int8, ..., int256, bool, string, etc.</p> <p>The ABI module in web3j provides full support for the ABI specification, and includes:</p> <ul> <li>Java implementations of all ABI types, including conversion from and to native Java types</li> <li>Function and event support</li> <li>ABIv2 support</li> <li>Plenty of unit tests</li> </ul>"},{"location":"smart_contracts/application_binary_interface/#type-mappings","title":"Type mappings","text":"<p>The native Java to ABI type mappings used within web3j are as follows:</p> <ul> <li>boolean -&gt; bool</li> <li>BigInteger -&gt; uint/int</li> <li>byte[] -&gt; bytes</li> <li>String -&gt; string and address types</li> <li>List&lt;&gt; -&gt; dynamic/static array</li> <li>T -&gt; struct/tuple types</li> </ul> <p>BigInteger types have to be used for numeric types, as numeric types in Ethereum are 256 bit integer values.</p> <p>Fixed point types have been defined for Ethereum, but are not currently implemented in Solidity, hence web3j does not currently support them (they were provided in versions prior to 3.x). Once available in Solidity, they will be reintroduced back into the web3j ABI module.</p> <p>Solidity structs will have a corresponding class generated for them. Currently only contract compiled with Solidity compiler version 0.6.x. The names of the corresponding classes will be the same as the name of the struct in the Solidity contract i.e. <code>struct Foo</code> in your smart contract will be called <code>Foo</code> in the smart contract wrapper.</p> <p>For more information on using ABI types in Java, refer to Solidity smart contract wrappers.</p>"},{"location":"smart_contracts/application_binary_interface/#further-details","title":"Further details","text":"<p>Please refer to the various ABI unit tests for encoding/decoding examples.</p> <p>A full ABI specification is maintained with the Solidity documentation.</p>"},{"location":"smart_contracts/application_binary_interface/#dependencies","title":"Dependencies","text":"<p>This is a very lightweight module, with the only third-party dependency being Bouncy Castle for cryptographic hashing. The hope is that other projects wishing to work with Ethereum's ABI on the JVM or Android will choose to make use of this module rather then write their own implementations.</p>"},{"location":"smart_contracts/compiling_solidity/","title":"Compiling Solidity source code","text":""},{"location":"smart_contracts/compiling_solidity/#compiling-solidity-source-code","title":"Compiling Solidity source code","text":"<p>Compilation to bytecode is performed by the Solidity compiler, <code>solc</code>. You can install the compiler, locally following the instructions as per the project documentation.</p> <p>To compile the Solidity code run:</p> <pre><code>$ solc &lt;contract&gt;.sol --bin --abi --optimize -o &lt;output-dir&gt;/\n</code></pre> <p>The <code>--bin</code> and <code>--abi</code> compiler arguments are both required to take full advantage of working with smart contracts from web3j.</p> <p><code>--bin</code></p> <p>Outputs a Solidity binary file containing the hex-encoded binary to provide with the transaction request. This is required only for <code>deploy</code> and <code>isValid</code> Solidity smart contract wrappers methods.</p> <p><code>--abi</code></p> <p>Outputs a Solidity Application Binary Interface file which details all of the publicly accessible contract methods and their associated parameters. These details along with the contract address are crucial for interacting with smart contracts. The ABI file is also used for the generation of Solidity smart contract wrappers</p> <p>There is also a <code>--gas</code> argument for providing estimates of the Gas required to create a contract and transact with its methods.</p> <p>Alternatively, you can write and compile Solidity code in your browser via the browser-solidity project. browser-solidity is great for smaller smart contracts, but you may run into issues working with larger contracts.</p> <p>You can also compile Solidity code via Ethereum clients such as Geth and OpenEthereum, using the JSON-RPC method eth_compileSolidity which is also supported in web3j. However, the Solidity compiler must be installed on the client for this to work.</p> <p>There are further options available, please refer to the relevant section in the Homestead documentation.</p>"},{"location":"smart_contracts/construction_and_deployment/","title":"Construction and Deployment","text":""},{"location":"smart_contracts/construction_and_deployment/#construction-and-deployment","title":"Construction and deployment","text":"<p>Construction and deployment of smart contracts happens with the deploy method:</p> <pre><code>YourSmartContract contract = YourSmartContract.deploy(\n&lt;web3j&gt;, &lt;credentials&gt;, &lt;contractGasProvider&gt;,\n[&lt;initialValue&gt;,]\n&lt;param1&gt;, ..., &lt;paramN&gt;).send();\n</code></pre> <p>This will create a new instance of the smart contract on the Ethereum blockchain using the supplied credentials, and constructor parameter values.</p> <p>The &lt;initialValue&gt; parameter is only required if your smart contract accepts Ether on construction. This requires the Solidity payable modifier to be present in the contract.</p> <p>It returns a new smart contract wrapper instance which contains the underlying address of the smart contract. If you wish to construct an instance of a smart contract wrapper with an existing smart contract, simply pass in it's address:</p> <pre><code>YourSmartContract contract = YourSmartContract.load(\n\"0x&lt;address&gt;|&lt;ensName&gt;\", web3j, credentials, contractGasProvider);\n</code></pre>"},{"location":"smart_contracts/construction_and_deployment/#deploying-and-interacting-with-smart-contracts","title":"Deploying and interacting with smart contracts","text":"<p>If you want to avoid the underlying implementation detail for working with smart contracts, Web3j provides Solidity smart contract wrappers which enable you to interact directly with all of a smart contract's methods via a generated wrapper object.</p> <p>Alternatively, if you wish to send regular transactions or have more control over your interactions with your smart contracts, please refer to the sections Solidity smart contract wrappers, Transacting with a smart contract and Querying the state of a smart contract for details.</p>"},{"location":"smart_contracts/construction_and_deployment/#solidity-smart-contract-wrappers","title":"Solidity smart contract wrappers","text":"<p>Web3j supports the auto-generation of smart contract function wrappers in Java from Solidity ABI files.</p> <p>The Web3j Command Line Tools tools ship with a command line utility for generating the smart contract function wrappers:</p> <pre><code>$ web3j generate solidity [-hV] [-jt] [-st] -a=&lt;abiFile&gt; [-b=&lt;binFile&gt;] -o=&lt;destinationFileDir&gt; -p=&lt;packageName&gt;\n\n   -h, --help                        Show this help message and exit.\n   -V, --version                     Print version information and exit.\n   -jt, --javaTypes                  use native java types. Default: true\n-st, --solidityTypes              use solidity types.\n   -a, --abiFile=&lt;abiFile&gt;           abi file with contract definition.\n   -b, --binFile=&lt;binFile&gt;           optional bin file with contract compiled code in order to generate deploy methods.\n   -o, --outputDir=&lt;destinationFileDir&gt; destination base directory.\n   -p, --package=&lt;packageName&gt;       base package name.\n</code></pre> <p><code>&lt;binfile&gt;</code> is required for Contract validity</p> <p>In versions prior to 3.x of Web3j, the generated smart contract wrappers used native Solidity types. From Web3j 3.x onwards, Java types are created by default. You can create Solidity types using the --solidityTypes command line argument.</p> <p>From Web3j version 4.6.x onwards, the generator supports ABIv2 for contract compiled with Solidity compiler version 0.6.x. This means that you can have structs as input/output/event parameters in your smart contract.</p> <p>You can also generate the wrappers by calling the Java class directly:</p> <pre><code>org.web3j.codegen.SolidityFunctionWrapperGenerator -b /path/to/&lt;smart-contract&gt;.bin -a /path/to/&lt;smart-contract&gt;.abi -o /path/to/src/main/java -p com.your.organisation.name\n</code></pre> <p>Where the bin and abi are obtained as per Compiling Solidity source code</p> <p>The native Java to Solidity type conversions used are detailed in the Application Binary Interface section.</p> <p>The smart contract wrappers support all common operations for working with smart contracts:</p> <ul> <li>Construction and deployment</li> <li>Invoking transactions and events</li> <li>Calling constant methods</li> <li>Contract validity</li> </ul> <p>Any method calls that requires an underlying JSON-RPC call to take place will return a Future to avoid blocking.</p> <p>Web3j also supports the generation of Java smart contract function wrappers directly from Truffle's Contract Schema via the Command Line Tools utility.</p> <pre><code>$ web3j generate truffle [--javaTypes|--solidityTypes] /path/to/&lt;truffle-smart-contract-output&gt;.json -o /path/to/src/main/java -p com.your.organisation.name\n</code></pre> <p>And this also can be invoked by calling the Java class:</p> <pre><code>org.web3j.codegen.TruffleJsonFunctionWrapperGenerator /path/to/&lt;truffle-smart-contract-output&gt;.json -o /path/to/src/main/java -p com.your.organisation.name\n</code></pre> <p>A wrapper generated this way is \"enhanced\" to expose the per-network deployed address of the contract. These addresses are from the truffle deployment at the time the wrapper is generated.</p>"},{"location":"smart_contracts/contract_validity/","title":"Contract Validity","text":""},{"location":"smart_contracts/contract_validity/#contract-validity","title":"Contract validity","text":"<p>Using this method, you may want to ascertain that the contract address that you have loaded is the smart contract that you expect. For this you can use the isValid smart contract method, which will only return true if the deployed bytecode at the contract address matches the bytecode in the smart contract wrapper.:</p> <pre><code>contract.isValid();  // returns false if the contract bytecode does not match what's deployed\n// at the provided address\n</code></pre> <p>Note: Contract wrapper has to be generated with --bin for this to work.</p>"},{"location":"smart_contracts/contracts_supported_by_web3j/","title":"Contracts supported by web3j","text":""},{"location":"smart_contracts/contracts_supported_by_web3j/#eip20","title":"EIP20","text":"<p>ERC20 tokens are supported via ERC20 contract wrapper as defined in EIP20 To fetch your token balance you can simply do:</p> <pre><code>ERC20 contract = ERC20.load(tokenAddress, web3j, txManager, gasPriceProvider);\nBigInteger balance = contract.balanceOf(account).send();\n</code></pre>"},{"location":"smart_contracts/contracts_supported_by_web3j/#eip165","title":"EIP165","text":"<p>Smart contract interfaces support and discovery as defined in EIP165 To check whether token contract supports particular interface:</p> <pre><code>ERC165 contract = ERC165.load(tokenAddress, web3j, txManager, gasPriceProvider);\nBoolean isSupported = contract.supportsInterface(interfaceID).send();\n</code></pre>"},{"location":"smart_contracts/contracts_supported_by_web3j/#eip721","title":"EIP721","text":"<p>Support for non-fungible tokens, also known as deeds as defined in EIP721. This contains the following contract wrappers:</p> <ul> <li>ERC721 is a set of methods that NFT should support</li> <li>ERC721Metadata optional metadata extension for NFT</li> <li>ERC721Enumerable optional enumeration extension for NFT</li> </ul>"},{"location":"smart_contracts/getting_started_solidity/","title":"Getting Started with Solidity","text":""},{"location":"smart_contracts/getting_started_solidity/#getting-started-with-solidity","title":"Getting started with Solidity","text":"<p>An overview of Solidity is beyond the scope of these docs, however, the following resources are a good place to start:</p> <ul> <li>Introduction to Smart Contracts in the Solidity project documentation</li> <li>Writing a contract in the Ethereum Homestead Guide</li> </ul>"},{"location":"smart_contracts/interacting_with_smart_contract/","title":"Interacting with Smart Contracts","text":""},{"location":"smart_contracts/interacting_with_smart_contract/#transaction-managers","title":"Transaction Managers","text":"<p>web3j provides a TransactionManager abstraction to control the manner you connect to Ethereum clients with. The default mechanism uses web3j's RawTransactionManager which works with Ethereum wallet files to sign transactions offline before submitting them to the network.</p> <p>However, you may wish to modify the transaction manager, which you can pass to the smart contract deployment and creation methods instead of a credentials object, i.e.:</p> <pre><code>YourSmartContract contract = YourSmartContract.deploy(\n&lt;web3j&gt;, &lt;transactionManager&gt;, &lt;contractGasProvider&gt;,\n&lt;param1&gt;, ..., &lt;paramN&gt;).send();\n</code></pre> <p>In addition to the RawTransactionManager, web3j provides a ClientTransactionManager which passes the responsibility of signing your transaction on to the Ethereum client you are connecting to.</p> <p>There is also a ReadonlyTransactionManager for when you only want to retrieve data from a smart contract, but not transact with it.</p>"},{"location":"smart_contracts/interacting_with_smart_contract/#specifying-the-chain-id-on-transactions-eip-155","title":"Specifying the Chain Id on Transactions (EIP-155)","text":"<p>The RawTransactionManager takes an optional chainId parameter to specify the chain id to be used on transactions as per EIP-155. This prevents transactions from one chain being re-broadcast onto another chain, such as from Ropsten to Mainnet:</p> <pre><code>TransactionManager transactionManager = new RawTransactionManager(\nweb3j, credentials, ChainId.MAINNET);\n</code></pre> <p>In order to avoid having to change config or code to specify which chain you are working with, web3j's default behaviour is to not specify chain ids on transactions to simplify working with the library. However, the recommendation of the Ethereum community is to use them.</p> <p>You can obtain the chain id of the network that your Ethereum client is connected to with the following request:</p> <pre><code>web3j.netVersion().send().getNetVersion();\n</code></pre>"},{"location":"smart_contracts/interacting_with_smart_contract/#transaction-receipt-processors","title":"Transaction Receipt Processors","text":"<p>By default, when a new transaction is submitted by web3j to an Ethereum client, web3j will continually poll the client until it receives a TransactionReceipt, indicating that the transaction has been added to the blockchain. If you are sending a number of transactions asynchronously with web3j, this can result in a number of threads polling the client concurrently.</p> <p>To reduce this polling overhead, web3j provides configurable TransactionReceiptProcessors.</p> <p>There are a number of processors provided in web3j:</p> <ul> <li>PollingTransactionReceiptProcessor is the default processor used in web3j, which polls periodically for a transaction receipt for each individual pending transaction.</li> <li>QueuingTransactionReceiptProcessor has an internal queue of all pending transactions. It contains a     worker that runs periodically to query if a transaction receipt is available yet. If a receipt is found, a callback to the client is invoked.</li> <li>NoOpProcessor provides an EmptyTransactionReceipt to clients which only contains the transaction hash. This is for clients who do not want web3j to perform any polling for a transaction receipt.</li> </ul> <p>Note: the EmptyTransactionReceipt is also provided in the the initial response from the QueuingTransactionReceiptProcessor. This allows the caller to have the transaction hash for the transaction that was submitted to the network.</p> <p>If you do not wish to use the default processor(PollingTransactionReceiptProcessor), you can specify the transaction receipt processor to use as follows:</p> <pre><code>TransactionReceiptProcessor transactionReceiptProcessor =\nnew QueuingTransactionReceiptProcessor(web3j, new Callback() {\n@Override\npublic void accept(TransactionReceipt transactionReceipt) {\n// process transactionReceipt\n}\n\n@Override\npublic void exception(Exception exception) {\n// handle exception\n}\nTransactionManager transactionManager = new RawTransactionManager(\nweb3j, credentials, ChainId.MAINNET, transactionReceiptProcessor);\n</code></pre> <p>If you require further information, the FastRawTransactionManagerIT demonstrates the polling and queuing approaches.</p>"},{"location":"smart_contracts/interacting_with_smart_contract/#invoking-transactions-and-events","title":"Invoking transactions and events","text":"<p>All transactional smart contract methods are named identically to their Solidity methods, taking the same parameter values. Transactional calls do not return any values, regardless of the return type specified on the method. Hence, for all transactional methods the Transaction Receipt associated with the transaction is returned.:</p> <pre><code>TransactionReceipt transactionReceipt = contract.someMethod(\n&lt;param1&gt;,\n...).send();\n</code></pre> <p>The transaction receipt is useful for two reasons:</p> <ol> <li>It provides details of the mined block that the transaction resides in</li> <li>Solidity events that are called will be logged as part of the transaction, which can then be extracted</li> </ol> <p>Any events defined within a smart contract will be represented in the smart contract wrapper with a method named process&lt;Event Name&gt;Event, which takes the Transaction Receipt and from this extracts the indexed and non-indexed event parameters, which are returned decoded in an instance of the EventValues object.:</p> <pre><code>EventValues eventValues = contract.processSomeEvent(transactionReceipt);\n</code></pre> <p>Alternatively you can use an Flowable filter instead which will listen for events associated with the smart contract:</p> <pre><code>contract.someEventFlowable(startBlock, endBlock).\n.subscribe(event -&gt; ...);\n</code></pre> <p>For more information on working with Flowable filters, refer to Filters and Events.</p> <p>Remember that for any indexed array, bytes and string Solidity parameter types, a Keccak-256 hash of their values will be returned, see the documentation for further information.</p>"},{"location":"smart_contracts/interacting_with_smart_contract/#calling-constant-methods","title":"Calling constant methods","text":"<p>Constant methods are those that read a value in a smart contract, and do not alter the state of the smart contract. These methods are available with the same method signature as the smart contract they were generated from:</p> <pre><code>Type result = contract.someMethod(&lt;param1&gt;, ...).send();\n</code></pre>"},{"location":"smart_contracts/interacting_with_smart_contract/#dynamic-gas-price-and-limit","title":"Dynamic gas price and limit","text":"<p>When working with smart contracts you may want to specify different gas price and limit values depending on the function being invoked. You can do that by creating your own ContractGasProvider for the smart contract wrapper.</p> <p>Every generated wrapper contains all smart contract method names listed as a constants, which facilitates compilation-time matching via a switch statement.</p> <p>For example, using the Greeter contract:</p> <pre><code>Greeter greeter = new Greeter(...);\ngreeter.setGasProvider(new DefaultGasProvider() {\n@Override\npublic BigInteger getGasPrice(String contractFunc) {\nswitch (contractFunc) {\ncase Greeter.FUNC_GREET: return BigInteger.valueOf(22_000_000_000L);\ncase Greeter.FUNC_KILL: return BigInteger.valueOf(44_000_000_000L);\ndefault: throw new NotImplementedException();\n}\n}\n\n@Override\npublic BigInteger getGasLimit(String contractFunc) {\nswitch (contractFunc) {\ncase Greeter.FUNC_GREET: return BigInteger.valueOf(4_300_000);\ncase Greeter.FUNC_KILL: return BigInteger.valueOf(5_300_000);\ndefault: throw new NotImplementedException();\n}\n}\n});\n</code></pre>"},{"location":"smart_contracts/smart_contracts_overview/","title":"Smart Contracts","text":"<p>Developers have the choice of two languages for writing smart contracts:</p> <p>Solidity</p> <p>The flagship language of Ethereum, and most popular language for smart contracts.</p> <p>LISP Like Language (LLL)</p> <p>A low level language, Serpent provides a superset of LLL. There's not a great deal of information for working with LLL, the following blog /var/log/syrinx and associated lll-resurrected GitHub repository is a  good place to start.</p> <p>In order to deploy a smart contract onto the Ethereum blockchain, it must first be compiled into a bytecode format,  then it can be sent as part of a transaction. Web3j can do all of this for you with its Solidity smart contract wrappers. To understand what is happening behind the scenes, you can refer to the details in Creation of a smart contract. Given that Solidity is the language of choice for writing smart contracts, it is the language supported by Web3j, and is used for all subsequent examples.</p>"},{"location":"smart_contracts/smart_contracts_overview/#examples","title":"Examples","text":"<p>Please refer to EIP-20 Ethereum token standard smart contract</p>"},{"location":"smart_contracts/testing_smart_contracts/","title":"Testing Smart Contracts","text":""},{"location":"smart_contracts/testing_smart_contracts/#testing-smart-contracts","title":"Testing Smart Contracts","text":"<p>You can test your Web3j app with Web3j-Unit.</p>"},{"location":"smart_contracts/testing_smart_contracts/#usage","title":"Usage","text":"<p>Add the gradle dependency.</p> <pre><code>repositories {\nmavenCentral()\njcenter()\n}\nimplementation \"org.web3j:core:4.5.11\"\ntestCompile \"org.web3j:web3j-unit:4.5.11\"\n</code></pre> <p>Deploy your contract in the test.</p> <pre><code>@EVMTest\npublic class GreeterTest {\n\n@Test\npublic void greeterDeploys(Web3j web3j, TransactionManager transactionManager, ContractGasProvider gasProvider) {\nGreeter greeter = Greeter.deploy(web3j, transactionManager, gasProvider, \"Hello EVM\").send()\nString greeting = greeter.greet().send()\nassertEquals(\"Hello EVM\", greeting)\n}\n\n}\n</code></pre> <p>For more detailed information check the testing section</p>"},{"location":"transactions/credentials/","title":"Credentials","text":""},{"location":"transactions/credentials/#create-credentials","title":"Create Credentials","text":"<p>There are two ways to create credentials in Web3j.</p>"},{"location":"transactions/credentials/#use-credentials-object","title":"Use Credentials object","text":"<ul> <li><code>Credentials.create(ECKeyPair ecKeyPair)</code></li> <li><code>Credentials.create(String privateKey, String publicKey)</code></li> </ul>"},{"location":"transactions/credentials/#use-walletutils-functionality","title":"Use WalletUtils functionality","text":"<p>The <code>WalletUtils</code> class can be used to load your credentials from various formats:</p> <ul> <li><code>WalletUtils.loadCredentials(String password,String source)</code></li> <li><code>WalletUtils.loadBip39Credentials(String password,String mnemonic)</code></li> <li><code>WalletUtils.loadBip39Credentials(String password,String mnemonic)</code></li> <li><code>WalletUtils.loadJsonCredentials(String password,String content)</code></li> </ul>"},{"location":"transactions/ethereum_testnets/","title":"Ethereum Test Networks","text":""},{"location":"transactions/ethereum_testnets/#ethereum-testnets","title":"Ethereum testnets","text":"<p>There are a number of dedicated test networks in Ethereum, which are supported by various clients.</p> <ul> <li>Goerli (All clients)</li> <li>Rinkeby (Geth only)</li> <li>Kovan (OpenEthereum only)</li> <li>Ropsten (Geth and OpenEthereum)</li> </ul> <p>For development, its recommended you use the Rinkeby or Kovan test networks. This is because they use a Proof of Authority (PoA) consensus mechanism, ensuring transactions and blocks are created in a consistent and timely manner. The Ropsten testnet, although closest to the Mainnet as it uses Proof of Work (PoW) consensus, has been subject to attacks in the past and tends to be more problematic for developers.</p> <p>You can request Ether for the Rinkeby testnet via the Rinkeby Crypto Faucet, available at https://www.rinkeby.io/#faucet.</p> <p>Details of how to request Ether for the Kovan testnet are available here.</p> <p>(This section needs to be changed) If you need some Ether on the Ropsten testnet to get started, please post a message with your wallet address to the Web3j Community Forum and you will be sent some.</p>"},{"location":"transactions/ethereum_testnets/#mining-on-testnetprivate-blockchains","title":"Mining on testnet/private blockchains","text":"<p>In the Ethereum test environment (testnet), the mining difficulty is set lower then the main environment (mainnet). This means that you can mine new Ether with a regular CPU, such as your laptop. What you'll need to do is run an Ethereum client such as Geth, Besu or OpenEthereum to start building up reserves. Further instructions are available on the respective sites.</p> <p>Geth</p> <p>https://geth.ethereum.org/docs/interface/mining</p> <p>Besu</p> <p>https://besu.hyperledger.org/en/stable/Concepts/Mining/</p> <p>OpenEthereum</p> <p>https://openethereum.github.io/wiki/Mining</p> <p>Once you have mined some Ether, you can start transacting with the blockchain.</p> <p>However, as mentioned above it's simpler to use the Kovan or Rinkeby test networks.</p>"},{"location":"transactions/gas/","title":"Gas","text":""},{"location":"transactions/gas/#gas","title":"Gas","text":"<p>When a transaction takes place in Ethereum, a transaction cost must be paid to the client that executes the transaction on your behalf, committing the output of this transaction to the Ethereum blockchain.</p> <p>This cost is measure in gas, where gas is the number of instructions used to execute a transaction in the Ethereum Virtual Machine. Please refer to the Homestead documentation for further information.</p> <p>What this means for you when working with Ethereum clients is that there are two parameters which are used to dictate how much Ether you wish to spend in order for a transaction to complete:</p> <p>Gas price</p> <p>This is the amount you are prepared in Ether per unit of gas. web3j uses a default price of 22,000,000,000 Wei (22 x 10^-8^ Ether). This is defined in ManagedTransaction.</p> <p>Gas limit</p> <p>This is the total amount of gas you are happy to spend on the transaction execution. There is an upper limit of how large a single transaction can be in an Ethereum block which restricts this value typically to less then 6,700,000. The current gas limit is visible at https://ethstats.net/.</p> <p>These parameters taken together dictate the maximum amount of Ether you are willing to spend on transaction costs. i.e. you can spend no more then gas price * gas limit. The gas price can also affect how quickly a transaction takes place depending on what other transactions are available with a more profitable gas price for miners.</p> <p>You may need to adjust these parameters to ensure that transactions take place in a timely manner.</p>"},{"location":"transactions/gas/#picking-gas-providers","title":"Picking Gas Providers","text":"<p>The public Interface <code>ContractGasProvider</code> has two implementations that can be used in order to pass in a gas provider to the deploy method of the contract.</p> <p>The <code>DefaultGasProvider</code> is pre-defined implementation of the <code>ContractGasProvider</code> that has set values for gas price and gas limit.</p> <ul> <li><code>GAS_LIMIT = BigInteger.valueOf(9_000_000);</code></li> <li><code>GAS_PRICE = BigInteger.valueOf(4_100_000_000L));</code></li> </ul> <p>If a more flexible approach is required then the <code>StaticGasProvider</code> can take custom gas price and gas limit values as BigIntegers.</p>"},{"location":"transactions/obtaining_ether/","title":"Obtaining Ether","text":""},{"location":"transactions/obtaining_ether/#obtaining-ether","title":"Obtaining Ether","text":"<p>To obtain Ether you have two options:</p> <ul> <li> <p>Mine it yourself</p> <p>Mining it yourself in a private environment, or the public test environment (testnet) is very straight forwards. However, in the main live environment (mainnet) it requires significant dedicated GPU time which is not likely to be feasible unless you already have a gaming PC with multiple dedicated GPUs. If you wish to use a private environment, there is some guidance on the Homestead documentation.</p> </li> <li> <p>Obtain Ether from another party</p> <ul> <li>Testnet faucets<ul> <li>Rinkeby Faucet</li> <li>Ropsten Faucet</li> <li>Kovan Faucet</li> </ul> </li> </ul> <p>To purchase Ether you will need to go via an exchange. As different regions have different exchanges, you will need to research the best location for this yourself. The Homestead documentation contains a number of exchanges which is a good place to start.</p> </li> </ul>"},{"location":"transactions/transaction_mechanisms/","title":"Transaction Mechanisms","text":""},{"location":"transactions/transaction_mechanisms/#transaction-mechanisms","title":"Transaction mechanisms","text":"<p>When you have a valid account created with some Ether, there are two mechanisms you can use to transact with Ethereum.</p> <ol> <li>Transaction signing via an Ethereum client</li> <li>Offline transaction signing</li> </ol> <p>Both mechanisms are supported via web3j.</p>"},{"location":"transactions/transaction_mechanisms/#transaction-signing-via-an-ethereum-client","title":"Transaction signing via an Ethereum client","text":"<p>In order to transact via an Ethereum client, you first need to ensure that the client you're transacting with knows about your wallet address. You are best off running your own Ethereum client such as Geth/Besu/OpenEthereum in order to do this. Once you have a client running, you can create a wallet via:</p> <ul> <li>The Geth Wiki contains a good run down of the different mechanisms Geth supports such as importing private key files, and creating a new account via it's console</li> <li>Alternatively you can use a JSON-RPC admin command for your client, such as personal_newAccount for   OpenEthereum (This needs to be changed) or Geth</li> </ul> <p>With your wallet file created, you can unlock your account via web3j by first of all creating an instance of web3j that supports Geth/Besu/OpenEthereum admin commands:</p> <pre><code>Admin web3j = Admin.build(new HttpService());\n</code></pre> <p>Then you can unlock the account, and providing this was successful, send a transaction:</p> <pre><code>PersonalUnlockAccount personalUnlockAccount = web3j.personalUnlockAccount(\"0x000...\", \"a password\").send();\nif (personalUnlockAccount.accountUnlocked()) {\n// send a transaction\n}\n</code></pre> <p>Transactions for sending in this manner should be created via EthSendTransaction, with the Transaction type:</p> <pre><code>Transaction transaction = Transaction.createContractTransaction(\n&lt;from address&gt;,\n&lt;nonce&gt;,\nBigInteger.valueOf(&lt;gas price&gt;),  // we use default gas limit\n\"0x...&lt;smart contract code to execute&gt;\"\n);\n\norg.web3j.protocol.core.methods.response.EthSendTransaction\ntransactionResponse = parity.ethSendTransaction(ethSendTransaction)\n.send();\n\nString transactionHash = transactionResponse.getTransactionHash();\n\n// poll for transaction response via org.web3j.protocol.Web3j.ethGetTransactionReceipt(&lt;txHash&gt;)\n</code></pre> <p>Where the &lt;nonce&gt; value is obtained as per below</p> <p>Please refer to the integration test DeployContractIT and its superclass Scenario for further details of this transaction workflow.</p> <p>Further details of working with the different admin commands supported by web3j are available in the section Management APIs.</p>"},{"location":"transactions/transaction_mechanisms/#offline-transaction-signing","title":"Offline transaction signing","text":"<p>If you'd prefer not to manage your own Ethereum client, or do not want to provide wallet details such as your password to an Ethereum client, then offline transaction signing is the way to go.</p> <p>Offline transaction signing allows you to sign a transaction using your Ethereum Ethereum wallet within web3j, allowing you to have complete control over your private credentials. A transaction created offline can then be sent to any Ethereum client on the network, which will propagate the transaction out to other nodes, provided it is a valid transaction.</p> <p>You can also perform out of process transaction signing if required. This can be achieved by overriding the sign method in ECKeyPair.</p>"},{"location":"transactions/transaction_nonce/","title":"Transaction Nonce","text":""},{"location":"transactions/transaction_nonce/#the-transaction-nonce","title":"The transaction nonce","text":"<p>The nonce is an increasing numeric value which is used to uniquely identify transactions. A nonce can only be used once and until a transaction is mined, it is possible to send multiple versions of a transaction with the same nonce, however, once mined, any subsequent submissions will be rejected.</p> <p>You can obtain the next available nonce via the eth_getTransactionCount method:</p> <pre><code>EthGetTransactionCount ethGetTransactionCount = web3j.ethGetTransactionCount(\naddress, DefaultBlockParameterName.LATEST).sendAsync().get();\n\nBigInteger nonce = ethGetTransactionCount.getTransactionCount();\n</code></pre> <p>The nonce can then be used to create your transaction object:</p> <pre><code>RawTransaction rawTransaction  = RawTransaction.createEtherTransaction(\nnonce, &lt;gas price&gt;, &lt;gas limit&gt;, &lt;toAddress&gt;, &lt;value&gt;);\n</code></pre>"},{"location":"transactions/transaction_types/","title":"Transaction Types","text":""},{"location":"transactions/transaction_types/#transaction-types","title":"Transaction types","text":"<p>The different types of transaction in Web3j work with both Transaction and RawTransaction objects. The key difference is that Transaction objects must always have a from address, so that the Ethereum client which processes the eth_sendTransaction request know which wallet to use in order to sign and send the transaction on the message senders behalf. As mentioned above, this is not necessary for raw transactions which are signed offline.</p> <p>The subsequent sections outline the key transaction attributes required for the different transaction types. The following attributes remain constant for all:</p> <ul> <li>Gas price</li> <li>Gas limit</li> <li>Nonce</li> <li>From</li> </ul> <p>Transaction and RawTransaction objects are used interchangeably in all of the subsequent examples.</p>"},{"location":"transactions/transactions/","title":"Transactions","text":"<p>Broadly speaking there are three types transactions supported on Ethereum:</p> <ol> <li>Transfer of Ether from one party to another</li> <li>Creation of a smart contract</li> <li>Transacting with a smart contract</li> </ol> <p>To undertake any of these transactions, it is necessary to have Ether (the fuel of the Ethereum blockchain) residing in the Ethereum account which the transactions are taking place from. This is to pay for the Gas costs, which is the transaction execution cost for the Ethereum client that performs the transaction on your behalf, committing the result to the Ethereum blockchain. Instructions for obtaining Ether are described below in Obtaining Ether</p> <p>Additionally, it is possible to query the state of a smart contract, this is described in Querying the state of a smart contract</p> <p></p>"},{"location":"transactions/transactions_and_smart_contracts/","title":"Transactions and Smart Contracts","text":""},{"location":"transactions/transactions_and_smart_contracts/#recommended-approach-for-working-with-smart-contracts","title":"Recommended approach for working with smart contracts","text":"<p>When working with smart contract wrappers as outlined below, you will have to perform all of the conversions from Solidity to native Java types manually. It is far more effective to use Web3j's Solidity smart contract wrappers which take care of all code generation and this conversion for you.</p>"},{"location":"transactions/transactions_and_smart_contracts/#creation-of-a-smart-contract","title":"Creation of a smart contract","text":"<p>To deploy a new smart contract, the following attributes will need to be provided</p> <p><code>value</code></p> <p>the amount of Ether you wish to deposit in the smart contract  (assumes zero if not provided)</p> <p><code>data</code></p> <p>the hex formatted, compiled smart contract creation code</p> <pre><code>// using a raw transaction\nRawTransaction rawTransaction = RawTransaction.createContractTransaction(\n&lt;nonce&gt;,\n&lt;gasPrice&gt;,\n&lt;gasLimit&gt;,\n&lt;value&gt;,\n\"0x &lt;compiled smart contract code&gt;\");\n// send...\n\n// get contract address\nEthGetTransactionReceipt transactionReceipt =\nweb3j.ethGetTransactionReceipt(transactionHash).send();\n\nif (transactionReceipt.getTransactionReceipt.isPresent()) {\nString contractAddress = transactionReceipt.get().getContractAddress();\n} else {\n// try again\n}\n</code></pre> <p>If the smart contract contains a constructor, the associated constructor field values must be encoded and appended to the compiled smart contract code:</p> <pre><code>String encodedConstructor =\nFunctionEncoder.encodeConstructor(Arrays.asList(new Type(value), ...));\n\n// using a regular transaction\nTransaction transaction = Transaction.createContractTransaction(\n&lt;fromAddress&gt;,\n&lt;nonce&gt;,\n&lt;gasPrice&gt;,\n&lt;gasLimit&gt;,\n&lt;value&gt;,\n\"0x &lt;compiled smart contract code&gt;\" + encodedConstructor);\n\n// send...\n</code></pre>"},{"location":"transactions/transactions_and_smart_contracts/#transacting-with-a-smart-contract","title":"Transacting with a smart contract","text":"<p>To transact with an existing smart contract, the following attributes will need to be provided:</p> <p><code>to</code></p> <p>the smart contract address</p> <p><code>value</code></p> <p>the amount of Ether you wish to deposit in the smart contract (if  the smart contract accepts ether)</p> <p><code>data</code></p> <p>the encoded function selector and parameter arguments</p> <p>Web3j takes care of the function encoding for you, for further details on the implementation refer to the Application Binary Interface section.</p> <pre><code>Function function = new Function&lt;&gt;(\n\"functionName\",  // function we're calling\nArrays.asList(new Type(value), ...),  // Parameters to pass as Solidity Types\nArrays.asList(new TypeReference&lt;Type&gt;() {}, ...));\n\nString encodedFunction = FunctionEncoder.encode(function)\nTransaction transaction = Transaction.createFunctionCallTransaction(\n&lt;from&gt;, &lt;gasPrice&gt;, &lt;gasLimit&gt;, contractAddress, &lt;funds&gt;, encodedFunction);\n\norg.web3j.protocol.core.methods.response.EthSendTransaction transactionResponse =\nweb3j.ethSendTransaction(transaction).sendAsync().get();\n\nString transactionHash = transactionResponse.getTransactionHash();\n\n// wait for response using EthGetTransactionReceipt...\n</code></pre> <p>It is not possible to return values from transactional functional calls, regardless of the return type of the message signature. However, it is possible to capture values returned by functions using filters. Please refer to the Filters and Events section for details.</p>"},{"location":"transactions/transactions_and_smart_contracts/#querying-the-state-of-a-smart-contract","title":"Querying the state of a smart contract","text":"<p>This functionality is facilitated by the eth_call JSON-RPC call.</p> <p>eth_call allows you to call a method on a smart contract to query a value. There is no transaction cost associated with this function, this is because it does not change the state of any smart contract method's called, it simply returns the value from them:</p> <pre><code>Function function = new Function&lt;&gt;(\n\"functionName\",\nArrays.asList(new Type(value)),  // Solidity Types in smart contract functions\nArrays.asList(new TypeReference&lt;Type&gt;() {}, ...));\n\nString encodedFunction = FunctionEncoder.encode(function)\norg.web3j.protocol.core.methods.response.EthCall response = web3j.ethCall(\nTransaction.createEthCallTransaction(&lt;from&gt;, contractAddress, encodedFunction),\nDefaultBlockParameterName.LATEST)\n.sendAsync().get();\n\nList&lt;Type&gt; someTypes = FunctionReturnDecoder.decode(\nresponse.getValue(), function.getOutputParameters());\n</code></pre> <p>Note: If an invalid function call is made, or a null result is obtained, the return value will be an instance of Collections.emptyList()</p>"},{"location":"transactions/transfer_eth/","title":"Transfer Eth","text":""},{"location":"transactions/transfer_eth/#transfer-of-ether-from-one-party-to-another","title":"Transfer of Ether from one party to another","text":"<p>The sending of Ether between two parties requires a minimal number of details of the transaction object:</p> <p><code>to</code></p> <p>the destination wallet address</p> <p><code>value</code></p> <p>the amount of Ether you wish to send to the destination address</p> <pre><code>BigInteger value = Convert.toWei(\"1.0\", Convert.Unit.ETHER).toBigInteger();\nRawTransaction rawTransaction  = RawTransaction.createEtherTransaction(\n&lt;nonce&gt;, &lt;gas price&gt;, &lt;gas limit&gt;, &lt;toAddress&gt;, value);\n// send...\n</code></pre> <p>However, it is recommended that you use the Transfer class for sending Ether, which takes care of the nonce management and polling for a response for you:</p> <pre><code>Web3j web3 = Web3j.build(new HttpService());  // defaults to http://localhost:8545/\nCredentials credentials = WalletUtils.loadCredentials(\"password\", \"/path/to/walletfile\");\nTransactionReceipt transactionReceipt = Transfer.sendFunds(\nweb3, credentials, \"0x&lt;address&gt;|&lt;ensName&gt;\",\nBigDecimal.valueOf(1.0), Convert.Unit.ETHER).send();\n</code></pre> <p>Use EIP1559 for sending Ether:</p> <pre><code>Web3j web3 = Web3j.build(new HttpService());\nCredentials credentials = WalletUtils.loadCredentials(\"password\", \"/path/to/walletfile\");\nTransactionReceipt transactionReceipt = Transfer.sendFundsEIP1559(\nweb3, credentials, \"0x&lt;address&gt;|&lt;ensName&gt;\", //toAddress\nBigDecimal.ONE.valueOf(1), //value\nConvert.Unit.ETHER, //unit\nBigInteger.valueOf(8_000_000), gasLimit\nDefaultGasProvider.GAS_LIMIT, //maxPriorityFeePerGas (max fee per gas transaction willing to give to miners)\nBigInteger.valueOf(3_100_000_000L) //maxFeePerGas (max fee transaction willing to pay)\n).send();\n</code></pre> <p>Access new attributes effectiveGasPrice and type through TransactionReceipt:-</p> <pre><code>transactionReceipt.getType();\n\ntransactionReceipt.effectiveGasPrice();\n</code></pre> <p>Use Web3j to get block and access new fields:-</p> <pre><code>EthBlock.Block block = web3j.ethGetBlockByNumber(\nDefaultBlockParameter.valueOf(\u201c&lt;block number&gt;\u201d),\ntrue  //returnFullTransactionObjects\n).send().get().getBlock();\n\nblock.getBaseFeePerGas();\n</code></pre> <p>Also other options to get block or get uncle like:-</p> <pre><code>EthBlock.Block block = web3j.ethGetBlockByHash(String blockHash, boolean returnFullTransactionObjects);\n\nEthBlock.Block block = web3j.ethGetUncleByBlockHashAndIndex(String blockHash, BigInteger transactionIndex);\n\nEthBlock.Block block = web3j.ethGetUncleByBlockNumberAndIndex(DefaultBlockParameter defaultBlockParameter, BigInteger transactionIndex);\n</code></pre> <p>Also access Transactions new field through Web3j </p> <pre><code>EthTransaction ethTransaction = web3j.ethGetTransactionByHash(String transactionHash).send();\n\nEthTransaction ethTransaction = web3j.ethGetTransactionByBlockHashAndIndex\n(String blockHash, BigInteger transactionIndex).send();\nEthTransaction ethTransaction = web3j.ethGetTransactionByBlockNumberAndIndex(\nDefaultBlockParameter defaultBlockParameter, BigInteger transactionIndex).send();\n</code></pre>"},{"location":"transactions/wallet_files/","title":"Wallet Files","text":""},{"location":"transactions/wallet_files/#creating-and-working-with-wallet-files","title":"Creating and working with wallet files","text":"<p>In order to sign transactions offline, you need to have either your Ethereum wallet file or the public and private keys associated with an Ethereum wallet/account.</p> <p>web3j is able to both generate a new secure Ethereum wallet file for you, or work with an existing wallet file.</p> <p>To create a new wallet file:</p> <pre><code>String fileName = WalletUtils.generateNewWalletFile(\n\"your password\",\nnew File(\"/path/to/destination\"));\n</code></pre> <p>To load the credentials from a wallet file:</p> <pre><code>Credentials credentials = WalletUtils.loadCredentials(\n\"your password\",\n\"/path/to/walletfile\");\n</code></pre> <p>These credentials are then used to sign transactions.</p> <p>Please refer to the Web3 Secret Storage Definition for the full wallet file specification.</p>"},{"location":"transactions/wallet_files/#signing-transactions","title":"Signing transactions","text":"<p>Transactions to be used in an offline signing capacity, should use the RawTransaction type for this purpose. The RawTransaction is similar to the previously mentioned Transaction type, however it does not require a from address, as this can be inferred from the signature.</p> <p>In order to create and sign a raw transaction, the sequence of events is as follows:</p> <ol> <li>Identify the next available nonce for the sender account</li> <li>Create the RawTransaction object</li> <li>Encode the RawTransaction object using Recursive Length Prefix encoding</li> <li>Sign the RawTransaction object</li> <li>Send the RawTransaction object to a node for processing</li> </ol> <p>The nonce is an increasing numeric value which is used to uniquely identify transactions. A nonce can only be used once and until a transaction is mined, it is possible to send multiple versions of a transaction with the same nonce, however, once mined, any subsequent submissions will be rejected.</p> <p>Once you have obtained the next available nonce, the value can then be used to create your transaction object:</p> <pre><code>RawTransaction rawTransaction  = RawTransaction.createEtherTransaction(\nnonce, &lt;gas price&gt;, &lt;gas limit&gt;, &lt;toAddress&gt;, &lt;value&gt;);\n</code></pre> <p>The transaction can then be signed and encoded:</p> <pre><code>byte[] signedMessage = TransactionEncoder.signMessage(rawTransaction, &lt;credentials&gt;);\nString hexValue = Numeric.toHexString(signedMessage);\n</code></pre> <p>Where the credentials are those loaded as per Creating and working with wallet files</p> <p>The transaction is then sent using eth_sendRawTransaction:</p> <pre><code>EthSendTransaction ethSendTransaction = web3j.ethSendRawTransaction(hexValue).sendAsync().get();\nString transactionHash = ethSendTransaction.getTransactionHash();\n// poll for transaction response via org.web3j.protocol.Web3j.ethGetTransactionReceipt(&lt;txHash&gt;)\n</code></pre> <p>Please refer to the integration test CreateRawTransactionIT for a full example of creating and sending a raw transaction.</p>"}]}